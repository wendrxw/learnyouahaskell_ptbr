<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aprenda Haskell para o Bem de Todos!</title>
    <link rel="stylesheet" href="assets/css/reset.css" type="text/css" />
    <link rel="stylesheet" href="assets/css/style.css" type="text/css" />
    <link rel="stylesheet" href="sh/Styles/SyntaxHighlighter.css" type="text/css" />
    <link rel="shortcut icon" href="assets/images/favicon.png" type="image/png" />
</head>
<body>
    <div class="bgwrapper">
        <div id="content">
<div class="footdiv">
    <ul>
<li class="prev"><a href="modules.html">Anterior</a></li>
        <li class="toc"><a href="index.html">Sumário</a></li>
<li class="next"><a href="input-and-output.html">Próximo</a></li>
    </ul>
</div>

            <article>
<h1>Criando Nossos Próprios Tipos e Typeclasses (Making Our Own Types
and Typeclasses)</h1>
<p>Nos capítulos anteriores, cobrimos alguns tipos e typeclasses
existentes em Haskell. Neste capítulo, aprenderemos como criar os nossos
e como colocá-los para trabalhar!</p>
<h2>Introdução a tipos de dados algébricos (Algebraic data types intro)
{#algebraic-data-types}</h2>
<p>Até agora, encontramos muitos tipos de dados. <code>Bool</code>,
<code>Int</code>, <code>Char</code>, <code>Maybe</code>, etc. Mas como
fazemos o nosso? Bem, uma maneira é usar a palavra-chave
<strong>data</strong> para definir um tipo. Vamos ver como o tipo
<code>Bool</code> é definido na biblioteca padrão.</p>
<p><code>{.haskell:hs} data Bool = False | True</code></p>
<p><code>data</code> significa que estamos definindo um novo tipo de
dados. A parte antes do <code>=</code> denota o tipo, que é
<code>Bool</code>. As partes após o <code>=</code> são
<strong>construtores de valor</strong> (value constructors). Eles
especificam os diferentes valores que esse tipo pode ter. O
<code>|</code> é lido como <em>ou</em>. Então, podemos ler isso como: o
tipo <code>Bool</code> pode ter um valor de <code>True</code> ou
<code>False</code>. Tanto o nome do tipo quanto os construtores de valor
devem ser iniciados com letra maiúscula.</p>
<p>De maneira semelhante, podemos pensar no tipo <code>Int</code> sendo
definido assim:</p>
<p><code>{.haskell:hs} data Int = -2147483648 | -2147483647 | ... | -1 | 0 | 1 | 2 | ... | 2147483647</code></p>
<p><img
src="assets/images/making-our-own-types-and-typeclasses/caveman.png"
alt="caveman" />{.left width=220 height=215}</p>
<p>O primeiro e o último valor de construtores são os valores mínimos e
máximos possíveis de <code>Int</code>. Na verdade, não é definido assim,
as reticências estão aqui porque omitimos uma carga de números, então
isso é apenas para fins ilustrativos.</p>
<p>Agora, vamos pensar em como representaríamos uma forma em Haskell.
Uma maneira seria usar tuplas. Um círculo poderia ser indicado como
<code>(43.1, 55.0, 10.4)</code>, onde o primeiro e o segundo campos são
as coordenadas do centro do círculo e o terceiro campo é o raio. Parece
bom, mas isso também pode representar um vetor 3D ou qualquer outra
coisa. Uma solução melhor seria criar nosso próprio tipo para
representar uma forma. Digamos que uma forma pode ser um círculo ou um
retângulo. Aqui está:</p>
<p><code>{.haskell:hs} data Shape = Circle Float Float Float | Rectangle Float Float Float Float</code></p>
<p>Agora o que é isso? Pense assim. O construtor de valor
<code>Circle</code> possui três campos, que recebem floats. Portanto,
quando escrevemos um construtor de valor, podemos, opcionalmente,
adicionar alguns tipos depois dele e esses tipos definem os valores que
ele conterá. Aqui, os dois primeiros campos são as coordenadas de seu
centro, o terceiro seu raio. O construtor de valor
<code>Rectangle</code> possui quatro campos que aceitam floats. Os dois
primeiros são as coordenadas para o canto superior esquerdo e os dois
segundos são coordenadas para o canto inferior direito.</p>
<p>Agora, quando digo campos, na verdade quero dizer parâmetros.
Construtores de valor são na verdade funções que, em última análise,
retornam um valor de um tipo de dados. Vamos dar uma olhada nas
assinaturas de tipo para esses dois construtores de valor.</p>
<p><code>{.haskell:hs} ghci&gt; :t Circle Circle :: Float -&gt; Float -&gt; Float -&gt; Shape ghci&gt; :t Rectangle Rectangle :: Float -&gt; Float -&gt; Float -&gt; Float -&gt; Shape</code></p>
<p>Legal, então construtores de valor são funções como todo o resto.
Quem teria pensado? Vamos fazer uma função que pega uma forma e retorna
sua superfície.</p>
<p><code>{.haskell:hs} surface :: Shape -&gt; Float surface (Circle _ _ r) = pi * r ^ 2 surface (Rectangle x1 y1 x2 y2) = (abs $ x2 - x1) * (abs $ y2 - y1)</code></p>
<p>A primeira coisa notável aqui é a declaração de tipo. Diz que a
função assume uma forma e retorna um float. Não poderíamos escrever uma
declaração de tipo de <code>Circle -&gt; Float</code> porque
<code>Circle</code> não é um tipo, <code>Shape</code> é. Assim como não
podemos escrever uma função com uma declaração de tipo de
<code>True -&gt; Int</code>. A próxima coisa que notamos aqui é que
podemos fazer pattern matching com construtores. Fizemos correspondência
de padrões com construtores antes (o tempo todo, na verdade) quando
combinamos um padrão com valores como <code>[]</code> ou
<code>False</code> ou <code>5</code>, apenas esses valores não tinham
campos. Apenas escrevemos um construtor e depois vinculamos seus campos
a nomes. Como estamos interessados no raio, na verdade não nos
importamos com os dois primeiros campos, que nos dizem onde está o
círculo.</p>
<p><code>{.haskell:hs} ghci&gt; surface $ Circle 10 20 10 314.15927 ghci&gt; surface $ Rectangle 0 0 100 100 10000.0</code></p>
<p>Yay, funciona! Mas se tentarmos apenas imprimir
<code>Circle 10 20 5</code> no prompt, receberemos um erro. Isso ocorre
porque o Haskell não sabe como exibir nosso tipo de dados como uma
string (ainda). Lembre-se, quando tentamos imprimir um valor no prompt,
Haskell primeiro executa a função <code>show</code> para obter a
representação de string do nosso valor e depois imprime isso no
terminal. Para tornar nosso tipo <code>Shape</code> parte da typeclass
<code>Show</code>, nós o modificamos assim:</p>
<p><code>{.haskell:hs} data Shape = Circle Float Float Float | Rectangle Float Float Float Float deriving (Show)</code></p>
<p>Não vamos nos preocupar muito com a derivação por enquanto. Vamos
apenas dizer que, se adicionarmos <code>deriving (Show)</code> no final
de uma declaração <em>data</em>, o Haskell torna automagicamente esse
tipo parte da typeclass <code>Show</code>. Então agora, podemos fazer
isso:</p>
<p><code>{.haskell:hs} ghci&gt; Circle 10 20 5 Circle 10.0 20.0 5.0 ghci&gt; Rectangle 50 230 60 90 Rectangle 50.0 230.0 60.0 90.0</code></p>
<p>Os construtores de valor são funções, para que possamos mapeá-los e
aplicá-los parcialmente e tudo mais. Se queremos uma lista de círculos
concêntricos com raios diferentes, podemos fazer isso.</p>
<p><code>{.haskell:hs} ghci&gt; map (Circle 10 20) [4,5,6,6] [Circle 10.0 20.0 4.0,Circle 10.0 20.0 5.0,Circle 10.0 20.0 6.0,Circle 10.0 20.0 6.0]</code></p>
<p>Nosso tipo de dados é bom, embora possa ser melhor. Vamos criar um
tipo de dados intermediário que defina um ponto no espaço bidimensional.
Então podemos usar isso para tornar nossas formas mais
compreensíveis.</p>
<p><code>{.haskell:hs} data Point = Point Float Float deriving (Show) data Shape = Circle Point Float | Rectangle Point Point deriving (Show)</code></p>
<p>Observe que, ao definir um ponto, usamos o mesmo nome para o tipo de
dados e o construtor de valor. Isso não tem significado especial, embora
seja comum usar o mesmo nome que o tipo se houver apenas um construtor
de valor. Então agora o <code>Circle</code> tem dois campos, um é do
tipo <code>Point</code> e o outro do tipo <code>Float</code>. Isso
facilita a compreensão do que é o quê. O mesmo vale para o retângulo.
Temos que ajustar nossa função <code>surface</code> para refletir essas
mudanças.</p>
<p><code>{.haskell:hs} surface :: Shape -&gt; Float surface (Circle _ r) = pi * r ^ 2 surface (Rectangle (Point x1 y1) (Point x2 y2)) = (abs $ x2 - x1) * (abs $ y2 - y1)</code></p>
<p>A única coisa que tivemos que mudar foram os padrões. Desconsideramos
o ponto inteiro no padrão do círculo. No padrão do retângulo, acabamos
de usar uma correspondência de padrão aninhada para obter os campos dos
pontos. Se quiséssemos referenciar os pontos para algum motivo,
poderíamos ter usado as-patterns.</p>
<p><code>{.haskell:hs} ghci&gt; surface (Rectangle (Point 0 0) (Point 100 100)) 10000.0 ghci&gt; surface (Circle (Point 0 0) 24) 1809.5574</code></p>
<p>Que tal uma função que empurra uma forma? Pega uma forma, a
quantidade para movê-la no eixo x e a quantidade para movê-la no eixo y
e depois retorna uma nova forma que tem as mesmas dimensões, apenas está
localizado em outro lugar.</p>
<p><code>{.haskell:hs} nudge :: Shape -&gt; Float -&gt; Float -&gt; Shape nudge (Circle (Point x y) r) a b = Circle (Point (x+a) (y+b)) r nudge (Rectangle (Point x1 y1) (Point x2 y2)) a b = Rectangle (Point (x1+a) (y1+b)) (Point (x2+a) (y2+b))</code></p>
<p>Bastante simples. Adicionamos as quantidades de empurrão aos pontos
que denotam a posição da forma.</p>
<p><code>{.haskell:hs} ghci&gt; nudge (Circle (Point 34 34) 10) 5 10 Circle (Point 39.0 44.0) 10.0</code></p>
<p>Se não queremos lidar diretamente com pontos, podemos criar algumas
funções auxiliares que criam formas de algum tamanho nas coordenadas
zero e depois empurram elas.</p>
<p>```{.haskell:hs} baseCircle :: Float -&gt; Shape baseCircle r =
Circle (Point 0 0) r</p>
<p>baseRect :: Float -&gt; Float -&gt; Shape baseRect width height =
Rectangle (Point 0 0) (Point width height) ```</p>
<p><code>{.haskell:hs} ghci&gt; nudge (baseRect 40 100) 60 23 Rectangle (Point 60.0 23.0) (Point 100.0 123.0)</code></p>
<p>Você pode, é claro, exportar seus tipos de dados em seus módulos.
Para fazer isso, basta escrever seu tipo junto com as funções que você
está exportando e adicionar alguns parênteses e, neles, especificar os
construtores de valor que deseja exportar para ele, separados por
vírgulas. Se você deseja exportar todos os construtores de valor para um
determinado tipo, basta escrever <code>..</code>.</p>
<p>Se quiséssemos exportar as funções e tipos que definimos aqui em um
módulo, poderíamos começar assim:</p>
<p><code>{.haskell:hs} module Shapes ( Point(..) , Shape(..) , surface , nudge , baseCircle , baseRect ) where</code></p>
<p>Ao fazer <code>Shape(..)</code>, exportamos todos os construtores de
valor para <code>Shape</code>, o que significa que quem importa nosso
módulo pode fazer formas usando os construtores de valor
<code>Rectangle</code> e <code>Circle</code>. É o mesmo que escrever
<code>Shape (Rectangle, Circle)</code>.</p>
<p>Também poderíamos optar por não exportar nenhum construtor de valor
para <code>Shape</code>, apenas escrevendo <code>Shape</code> na
instrução de exportação. Dessa forma, alguém importando nosso módulo só
poderia fazer formas usando as funções auxiliares
<code>baseCircle</code> e <code>baseRect</code>. <code>Data.Map</code>
usa essa abordagem. Você não pode criar um mapa fazendo
<code>Map.Map [(1,2),(3,4)]</code> porque ele não exporta esse
construtor de valor. No entanto, você pode fazer um mapeamento usando
uma das funções auxiliares como <code>Map.fromList</code>.</p>
<p>Lembre-se, construtores de valor são apenas funções que tomam os
campos como parâmetros e retornam um valor de algum tipo (como
<code>Shape</code>) como resultado. Portanto, quando escolhemos não
exportá-los, apenas impedimos que a pessoa importe nosso módulo de usar
essas funções, mas se algumas outras funções exportadas retornarem um
tipo, podemos usá-las para criar valores de nossos tipos de dados
personalizados.</p>
<p>Não exportar os construtores de valor de um tipo de dados os torna
mais abstratos de tal maneira que ocultamos a implementação deles. Além
disso, quem usa nosso módulo não pode fazer pattern matching contra os
construtores de valor.</p>
<h2>Sintaxe de registro (Record syntax) {#record-syntax}</h2>
<p><img
src="assets/images/making-our-own-types-and-typeclasses/record.png"
alt="record" />{.right width=208 height=97}</p>
<p>OK, fomos encarregados de criar um tipo de dados que descreva uma
pessoa. As informações que queremos armazenar sobre essa pessoa são:
primeiro nome, sobrenome, idade, altura, número de telefone e sabor de
sorvete favorito. Não sei sobre você, mas isso é tudo que eu quero saber
sobre uma pessoa. Vamos tentar!</p>
<p><code>{.haskell:hs} data Person = Person String String Int Float String String deriving (Show)</code></p>
<p>O-kay. O primeiro campo é o primeiro nome, o segundo é o sobrenome, o
terceiro é a idade e assim por diante. Vamos criar uma pessoa.</p>
<p><code>{.haskell:hs} ghci&gt; let guy = Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate" ghci&gt; guy Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate"</code></p>
<p>Isso é meio legal, embora um pouco ilegível. E se quisermos criar uma
função para obter informações separadas de uma pessoa? Uma função que
recebe o primeiro nome de uma pessoa, uma função que recebe o sobrenome
de uma pessoa, etc. Bem, teríamos que defini-las mais ou menos
assim.</p>
<p>```{.haskell:hs} firstName :: Person -&gt; String firstName (Person
firstname _ _ _ _ _) = firstname</p>
<p>lastName :: Person -&gt; String lastName (Person _ lastname _ _ _ _)
= lastname</p>
<p>age :: Person -&gt; Int age (Person _ _ age _ _ _) = age</p>
<p>height :: Person -&gt; Float height (Person _ _ _ height _ _) =
height</p>
<p>phoneNumber :: Person -&gt; String phoneNumber (Person _ _ _ _ number
_) = number</p>
<p>flavor :: Person -&gt; String flavor (Person _ _ _ _ _ flavor) =
flavor ```</p>
<p>Ufa! Eu certamente não gostei de escrever isso! Apesar de ser muito
complicado e CHATO de escrever, esse método funciona.</p>
<p><code>{.haskell:hs} ghci&gt; let guy = Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate" ghci&gt; firstName guy "Buddy" ghci&gt; height guy 184.2 ghci&gt; flavor guy "Chocolate"</code></p>
<p>Deve haver uma maneira melhor, você diz! Bem não, não há,
desculpe.</p>
<p>Brincadeirinha, existe. Hahaha! Os criadores de Haskell eram muito
inteligentes e anteciparam esse cenário. Eles incluíram uma maneira
alternativa de escrever tipos de dados. Veja como poderíamos alcançar a
funcionalidade acima com a sintaxe de registro.</p>
<p><code>{.haskell:hs} data Person = Person { firstName :: String                      , lastName :: String                      , age :: Int                      , height :: Float                      , phoneNumber :: String                      , flavor :: String                      } deriving (Show)</code></p>
<p>Portanto, em vez de apenas nomear os tipos de campo um após o outro e
separá-los com espaços, usamos colchetes. Primeiro, escrevemos o nome do
campo, por exemplo, <code>firstName</code> e depois escrevemos dois
pontos duplos <code>::</code> (também chamados de Paamayim Nekudotayim,
haha) e depois especificamos o tipo. O tipo de dados resultante é
exatamente o mesmo. O principal benefício disso é que ele cria funções
que procuram campos no tipo de dados. Ao usar sintaxe de registro para
criar esse tipo de dados, o Haskell criou automaticamente estas funções:
<code>firstName</code>, <code>lastName</code>, <code>age</code>,
<code>height</code>, <code>phoneNumber</code> e <code>flavor</code>.</p>
<p><code>{.haskell:hs} ghci&gt; :t flavor flavor :: Person -&gt; String ghci&gt; :t firstName firstName :: Person -&gt; String</code></p>
<p>Há outro benefício em usar a sintaxe de registro. Quando derivamos
<code>Show</code> para o tipo, ele o exibe de maneira diferente se
usarmos a sintaxe de registro para definir e instanciar o tipo. Digamos
que temos um tipo que representa um carro. Queremos acompanhar a empresa
que o fez, o nome do modelo e seu ano de produção. Veja.</p>
<p><code>{.haskell:hs} data Car = Car String String Int deriving (Show)</code></p>
<p><code>{.haskell:hs} ghci&gt; Car "Ford" "Mustang" 1967 Car "Ford" "Mustang" 1967</code></p>
<p>Se o definirmos usando a sintaxe de registro, podemos fazer um carro
novo como este.</p>
<p><code>{.haskell:hs} data Car = Car {company :: String, model :: String, year :: Int} deriving (Show)</code></p>
<p><code>{.haskell:hs} ghci&gt; Car {company="Ford", model="Mustang", year=1967} Car {company = "Ford", model = "Mustang", year = 1967}</code></p>
<p>Ao fazer um carro novo, não precisamos necessariamente colocar os
campos na ordem adequada, desde que listemos todos eles. Mas se não
usarmos a sintaxe de registro, temos que especificá-los em ordem.</p>
<p>Use sintaxe de registro quando um construtor tiver vários campos e
não for óbvio qual campo é qual. Se fizermos um tipo de dados vetoriais
em 3D fazendo <code>data Vector = Vector Int Int Int</code>, é bastante
óbvio que os campos são os componentes de um vetor. No entanto, em
nossos tipos <code>Person</code> e <code>Car</code>, não era tão óbvio e
nos beneficiamos muito do uso da sintaxe de registro.</p>
<h2>Parâmetros de tipo (Type parameters) {#type-parameters}</h2>
<p>Um construtor de valor pode receber alguns parâmetros de valores e
produzir um novo valor. Por exemplo, o construtor <code>Car</code>
recebe três valores e produz um valor de carro. De maneira semelhante,
<strong>construtores de tipos</strong> podem receber tipos como
parâmetros para produzir novos tipos. Isso pode parecer um pouco meta
demais no começo, mas não é tão complicado. Se você estiver
familiarizado com templates em C++, verá alguns paralelos. Para obter
uma imagem clara de como os parâmetros de tipo funcionam em ação, vamos
dar uma olhada em como um tipo que já conhecemos é implementado.</p>
<p><code>{.haskell:hs} data Maybe a = Nothing | Just a</code></p>
<p><img
src="assets/images/making-our-own-types-and-typeclasses/yeti.png"
alt="yeti" />{.left width=209 height=260}</p>
<p>O <code>a</code> aqui é o parâmetro de tipo. E como há um parâmetro
de tipo envolvido, chamamos <code>Maybe</code> de construtor de tipos.
Dependendo do que queremos que esse tipo de dados mantenha quando não
for <code>Nothing</code>, esse construtor de tipos pode acabar
produzindo um tipo de <code>Maybe Int</code>, <code>Maybe Car</code>,
<code>Maybe String</code>, etc. Nenhum valor pode ter um tipo apenas
<code>Maybe</code>, porque esse não é um tipo por si só, é um construtor
de tipos. Para que isso seja um tipo real de que um valor pode fazer
parte, ele deve ter todos os seus parâmetros de tipo preenchidos.</p>
<p>Portanto, se passarmos <code>Char</code> como o parâmetro de tipo
para <code>Maybe</code>, obteremos um tipo de <code>Maybe Char</code>. O
valor <code>Just 'a'</code> tem um tipo de <code>Maybe Char</code>, por
exemplo.</p>
<p>Você pode não saber, mas usamos um tipo que possui um parâmetro de
tipo antes de usarmos <code>Maybe</code>. Esse tipo é o tipo de lista.
Embora haja algum açúcar sintático em jogo, o tipo de lista leva um
parâmetro para produzir um tipo concreto. Os valores podem ter um tipo
<code>[Int]</code>, um tipo <code>[Char]</code>, um tipo
<code>[[String]]</code>, mas você não pode ter um valor que apenas tenha
um tipo de <code>[]</code>.</p>
<p>Vamos brincar com o tipo <code>Maybe</code>.</p>
<p><code>{.haskell:hs} ghci&gt; Just "Haha" Just "Haha" ghci&gt; Just 84 Just 84 ghci&gt; :t Just "Haha" Just "Haha" :: Maybe [Char] ghci&gt; :t Just 84 Just 84 :: (Num t) =&gt; Maybe t ghci&gt; :t Nothing Nothing :: Maybe a ghci&gt; Just 10 :: Maybe Double Just 10.0</code></p>
<p>Parâmetros de tipo são úteis porque podemos criar tipos diferentes
com eles, dependendo do tipo de tipos que queremos contidos em nosso
tipo de dados. Quando fazemos <code>:t Just "Haha"</code>, o mecanismo
de inferência de tipo descobre que é do tipo <code>Maybe [Char]</code>,
porque se o <code>a</code> no <code>Just a</code> for uma string, o
<code>a</code> em <code>Maybe a</code> também deve ser uma string.</p>
<p>Observe que o tipo de <code>Nothing</code> é <code>Maybe a</code>.
Seu tipo é polimórfico. Se alguma função exigir um
<code>Maybe Int</code> como parâmetro, podemos dar um
<code>Nothing</code>, porque um <code>Nothing</code> não contém um valor
de qualquer maneira e, portanto, não importa. O tipo
<code>Maybe a</code> pode agir como <code>Maybe Int</code> se for
necessário, assim como <code>5</code> pode agir como <code>Int</code> ou
<code>Double</code>. Da mesma forma, o tipo de lista vazia é
<code>[a]</code>. Uma lista vazia pode agir como uma lista de qualquer
coisa. É por isso que podemos fazer <code>[1,2,3] ++ []</code> e
<code>["ha","ha","ha"] ++ []</code>.</p>
<p>O uso de parâmetros de tipo é muito benéfico, mas apenas quando
usá-los faz sentido. Geralmente os usamos quando nosso tipo de dados
funcionaria independentemente do tipo de valor que ele mantém dentro
dele, como com nosso tipo <code>Maybe a</code>. Se o nosso tipo age como
algum tipo de caixa, é bom usá-los. Poderíamos mudar nosso tipo de dados
<code>Car</code> disso:</p>
<p><code>{.haskell:hs} data Car = Car { company :: String                , model :: String                , year :: Int                } deriving (Show)</code></p>
<p>Para isso:</p>
<p><code>{.haskell:hs} data Car a b c = Car { company :: a                      , model :: b                      , year :: c                      } deriving (Show)</code></p>
<p>Mas nós realmente nos beneficiaríamos? A resposta é: provavelmente
não, porque acabaríamos definindo funções que funcionam apenas no tipo
<code>Car String String Int</code>. Por exemplo, dada nossa primeira
definição de <code>Car</code>, poderíamos fazer uma função que exibe as
propriedades do carro em um pequeno texto agradável.</p>
<p><code>{.haskell:hs} tellCar :: Car -&gt; String tellCar (Car {company = c, model = m, year = y}) = "This " ++ c ++ " " ++ m ++ " was made in " ++ show y</code></p>
<p><code>{.haskell:hs} ghci&gt; let stang = Car {company="Ford", model="Mustang", year=1967} ghci&gt; tellCar stang "This Ford Mustang was made in 1967"</code></p>
<p>Uma pequena função fofa! A declaração de tipo é fofa e funciona muito
bem. Agora, se <code>Car</code> fosse <code>Car a b c</code>?</p>
<p><code>{.haskell:hs} tellCar :: (Show a) =&gt; Car String String a -&gt; String tellCar (Car {company = c, model = m, year = y}) = "This " ++ c ++ " " ++ m ++ " was made in " ++ show y</code></p>
<p>Teríamos que forçar essa função a pegar um tipo <code>Car</code> de
<code>(Show a) =&gt; Car String String a</code>.</p>
<p>Você pode ver que a assinatura do tipo é mais complicada e o único
benefício que realmente obteríamos seria que podemos usar qualquer tipo
que seja uma instância da typeclass <code>Show</code> como o tipo para
<code>c</code>.</p>
<p><code>{.haskell:hs} ghci&gt; tellCar (Car "Ford" "Mustang" 1967) "This Ford Mustang was made in 1967" ghci&gt; tellCar (Car "Ford" "Mustang" "nineteen sixty seven") "This Ford Mustang was made in \"nineteen sixty seven\"" ghci&gt; :t Car "Ford" "Mustang" 1967 Car "Ford" "Mustang" 1967 :: (Num t) =&gt; Car [Char] [Char] t ghci&gt; :t Car "Ford" "Mustang" "nineteen sixty seven" Car "Ford" "Mustang" "nineteen sixty seven" :: Car [Char] [Char] [Char]</code></p>
<p><img
src="assets/images/making-our-own-types-and-typeclasses/meekrat.png"
alt="meekrat" />{.right width=150 height=267}</p>
<p>Na vida real, porém, acabaríamos usando
<code>Car String String Int</code> na maioria das vezes e, portanto,
pareceria que parametrizar o tipo <code>Car</code> não vale realmente a
pena. Geralmente usamos parâmetros de tipo quando o tipo contido nos
vários construtores de valor do tipo de dados não é realmente tão
importante para o tipo funcionar. Uma lista de coisas é uma lista de
coisas e não importa qual é o tipo dessas coisas, ela ainda pode
funcionar. Se queremos somar uma lista de números, podemos especificar
mais tarde na função de soma que queremos especificamente uma lista de
números. O mesmo vale para <code>Maybe</code>. <code>Maybe</code>
representa uma opção de não ter nada ou ter um de algo. Não importa qual
é o tipo de algo.</p>
<p>Outro exemplo de um tipo parametrizado que já encontramos é
<code>Map k v</code> de <code>Data.Map</code>. O <code>k</code> é o tipo
das chaves em um mapa e o <code>v</code> é o tipo dos valores. Este é um
bom exemplo de onde os parâmetros de tipo são muito úteis. Ter mapas
parametrizados nos permite ter mapeamentos de qualquer tipo para
qualquer outro tipo, desde que o tipo da chave faça parte da typeclass
<code>Ord</code>. Se estivéssemos definindo um tipo de mapeamento,
poderíamos adicionar uma restrição de typeclass na declaração
<em>data</em>:</p>
<p><code>{.haskell:hs} data (Ord k) =&gt; Map k v = ...</code></p>
<p>No entanto, é uma convenção muito forte em Haskell <strong>nunca
adicionar restrições de typeclass nas declarações de dados.</strong> Por
quê? Bem, porque não nos beneficiamos muito, mas acabamos escrevendo
mais restrições de classe, mesmo quando não precisamos delas. Se
colocarmos ou não colocarmos a restrição <code>Ord k</code> na
declaração <em>data</em> de <code>Map k v</code>, teremos que colocar a
restrição em funções que assumem que as chaves em um mapa podem ser
ordenadas. Mas se não colocarmos a restrição na declaração de dados, não
precisamos colocar <code>(Ord k) =&gt;</code> nas declarações de tipo de
funções que não se importam se as chaves podem ser ordenadas ou não. Um
exemplo de tal função é <code>toList</code>, que apenas pega um
mapeamento e o converte em uma lista associativa. Sua assinatura de tipo
é <code>toList :: Map k a -&gt; [(k, a)]</code>. Se <code>Map k v</code>
tivesse uma restrição de tipo em sua declaração <em>data</em>, o tipo
para <code>toList</code> teria que ser
<code>toList :: (Ord k) =&gt; Map k a -&gt; [(k, a)]</code>, embora a
função não faça nenhuma comparação de chaves por ordem.</p>
<p>Portanto, não coloque restrições de tipo nas declarações
<em>data</em>, mesmo que pareça fazer sentido, porque você terá que
colocá-las nas declarações de tipo de função de qualquer maneira.</p>
<p>Vamos implementar um tipo de vetor 3D e adicionar algumas operações
para ele. Usaremos um tipo parametrizado porque, embora geralmente
contenha tipos numéricos, ele ainda suportará vários deles.</p>
<p>```{.haskell:hs} data Vector a = Vector a a a deriving (Show)</p>
<p>vplus :: (Num t) =&gt; Vector t -&gt; Vector t -&gt; Vector t (Vector
i j k) <code>vplus</code> (Vector l m n) = Vector (i+l) (j+m) (k+n)</p>
<p>vectMult :: (Num t) =&gt; Vector t -&gt; t -&gt; Vector t (Vector i j
k) <code>vectMult</code> m = Vector (i<em>m) (j</em>m) (k*m)</p>
<p>scalarMult :: (Num t) =&gt; Vector t -&gt; Vector t -&gt; t (Vector i
j k) <code>scalarMult</code> (Vector l m n) = i<em>l + j</em>m + k*n
```</p>
<p><code>vplus</code> é para adicionar dois vetores juntos. Dois vetores
são adicionados apenas adicionando seus componentes correspondentes.
<code>scalarMult</code> é para o produto escalar de dois vetores e
<code>vectMult</code> é para multiplicar um vetor com um escalar. Essas
funções podem operar em tipos de <code>Vector Int</code>,
<code>Vector Integer</code>, <code>Vector Float</code>, o que for, desde
que o <code>a</code> de <code>Vector a</code> seja da typeclass
<code>Num</code>. Além disso, se você examinar a declaração de tipo para
essas funções, verá que elas podem operar apenas em vetores do mesmo
tipo e os números envolvidos também devem ser do tipo contido nos
vetores. Observe que não colocamos uma restrição de classe
<code>Num</code> na declaração <em>data</em>, porque teríamos que
repeti-la nas funções de qualquer maneira.</p>
<p>Mais uma vez, é muito importante distinguir entre o construtor de
tipos e o construtor de valor. Ao declarar um tipo de dados, a parte
antes do <code>=</code> é o construtor de tipos e os construtores após
ele (possivelmente separados por <code>|</code>s) são construtores de
valor. Dar a uma função um tipo de
<code>Vector t t t -&gt; Vector t t t -&gt; t</code> estaria errado,
porque temos que colocar tipos na declaração de tipo e o construtor de
<strong>tipo</strong> vetorial leva apenas um parâmetro, enquanto o
construtor de valor leva três. Vamos brincar com nossos vetores.</p>
<p><code>{.haskell:hs} ghci&gt; Vector 3 5 8 `vplus` Vector 9 2 8 Vector 12 7 16 ghci&gt; Vector 3 5 8 `vplus` Vector 9 2 8 `vplus` Vector 0 2 3 Vector 12 9 19 ghci&gt; Vector 3 9 7 `vectMult` 10 Vector 30 90 70 ghci&gt; Vector 4 9 5 `scalarMult` Vector 9.0 2.0 4.0 74.0 ghci&gt; Vector 2 9 3 `vectMult` (Vector 4 9 5 `scalarMult` Vector 9 2 4) Vector 148 666 222</code></p>
<h2>Instâncias derivadas (Derived instances) {#derived-instances}</h2>
<p><img src="assets/images/making-our-own-types-and-typeclasses/gob.png"
alt="gob" />{.right width=112 height=350}</p>
<p>Na seção <a
href="types-and-typeclasses.html#typeclasses-101">Typeclasses 101</a>,
explicamos o básico das typeclasses. Explicamos que uma typeclass é uma
espécie de interface que define algum comportamento. Um tipo pode ser
feito uma <strong>instância</strong> de uma typeclass, se suportar esse
comportamento. Exemplo: o tipo <code>Int</code> é uma instância da
typeclass <code>Eq</code> porque a typeclass <code>Eq</code> define o
comportamento para coisas que podem ser comparadas. E como inteiros
podem ser comparados, <code>Int</code> faz parte da typeclass
<code>Eq</code>. A utilidade real vem com as funções que atuam como a
interface para <code>Eq</code>, ou seja, <code>==</code> e
<code>/=</code>. Se um tipo faz parte da typeclass <code>Eq</code>,
podemos usar as funções <code>==</code> com valores desse tipo. É por
isso que expressões como <code>4 == 4</code> e
<code>"foo" /= "bar"</code> verificam os tipos.</p>
<p>Também mencionamos que elas costumam ser confundidas com classes em
linguagens como Java, Python, C++ e afins, o que confunde muitas
pessoas. Nessas linguagens, as classes são um plano a partir do qual
criamos objetos que contêm estado e podem executar algumas ações.
Typeclasses são mais como interfaces. Não criamos dados a partir de
typeclasses. Em vez disso, primeiro criamos nosso tipo de dados e depois
pensamos no que ele pode agir. Se ele pode agir como algo que pode ser
comparado, tornamos isto uma instância da typeclass <code>Eq</code>. Se
ele pode agir como algo que pode ser ordenado, tornamos isto uma
instância da typeclass <code>Ord</code>.</p>
<p>Na próxima seção, veremos como podemos fazer manualmente nossos tipos
de instâncias de typeclasses implementando as funções definidas pelas
typeclasses. Mas agora, vamos ver como o Haskell pode fazer
automaticamente nosso tipo uma instância de uma das seguintes
typeclasses: <code>Eq</code>, <code>Ord</code>, <code>Enum</code>,
<code>Bounded</code>, <code>Show</code>, <code>Read</code>. Haskell pode
derivar o comportamento de nossos tipos nesses contextos se usarmos a
palavra-chave <em>deriving</em> ao criar nosso tipo de dados.</p>
<p>Considere este tipo de dados:</p>
<p><code>{.haskell:hs} data Person = Person { firstName :: String                      , lastName :: String                      , age :: Int                      }</code></p>
<p>Descreve uma pessoa. Vamos supor que duas pessoas não tenham a mesma
combinação de nome, sobrenome e idade. Agora, se tivermos registros para
duas pessoas, faz sentido ver se elas representam a mesma pessoa? Claro
que sim. Podemos tentar compará-las e ver se são iguais ou não. É por
isso que faria sentido para esse tipo fazer parte da typeclass
<code>Eq</code>. Vamos derivar a instância.</p>
<p><code>{.haskell:hs} data Person = Person { firstName :: String                      , lastName :: String                      , age :: Int                      } deriving (Eq)</code></p>
<p>Quando derivamos a instância <code>Eq</code> para um tipo e depois
tentamos comparar dois valores desse tipo com <code>==</code> ou
<code>/=</code>, o Haskell verá se os construtores de valor correspondem
(há apenas um construtor de valor aqui) e então verificará se todos os
dados contidos no interior correspondem testando cada par de campos com
<code>==</code>. Há apenas uma ressalva, porém, os tipos de todos os
campos também devem fazer parte da typeclass <code>Eq</code>. Mas como
<code>String</code> e <code>Int</code> são, estamos bem. Vamos testar
nossa instância de <code>Eq</code>.</p>
<p><code>{.haskell:hs} ghci&gt; let mikeD = Person {firstName = "Michael", lastName = "Diamond", age = 43} ghci&gt; let adRock = Person {firstName = "Adam", lastName = "Horovitz", age = 41} ghci&gt; let mca = Person {firstName = "Adam", lastName = "Yauch", age = 44} ghci&gt; mca == adRock False ghci&gt; mikeD == adRock False ghci&gt; mikeD == mikeD True ghci&gt; mikeD == Person {firstName = "Michael", lastName = "Diamond", age = 43} True</code></p>
<p>Obviamente, como <code>Person</code> está agora em <code>Eq</code>,
podemos usá-lo como o <code>a</code> para todas as funções que possuem
uma restrição de classe de <code>Eq a</code> em sua assinatura de tipo,
como <code>elem</code>.</p>
<p><code>{.haskell:hs} ghci&gt; let beastieBoys = [mca, adRock, mikeD] ghci&gt; mikeD `elem` beastieBoys True</code></p>
<p>As typeclasses <code>Show</code> e <code>Read</code> são para coisas
que podem ser convertidas para ou de strings, respectivamente. Como com
<code>Eq</code>, se os construtores de um tipo tiverem campos, seu tipo
deve ser parte de <code>Show</code> ou <code>Read</code> se queremos
tornar nosso tipo uma instância deles. Vamos fazer do nosso tipo de
dados <code>Person</code> uma parte de <code>Show</code> e
<code>Read</code> também.</p>
<p><code>{.haskell:hs} data Person = Person { firstName :: String                      , lastName :: String                      , age :: Int                      } deriving (Eq, Show, Read)</code></p>
<p>Agora podemos imprimir uma pessoa no terminal.</p>
<p><code>{.haskell:hs} ghci&gt; let mikeD = Person {firstName = "Michael", lastName = "Diamond", age = 43} ghci&gt; mikeD Person {firstName = "Michael", lastName = "Diamond", age = 43} ghci&gt; "mikeD is: " ++ show mikeD "mikeD is: Person {firstName = \"Michael\", lastName = \"Diamond\", age = 43}"</code></p>
<p>Se tentássemos imprimir uma pessoa no terminal antes de tornar o tipo
de dados <code>Person</code> da typeclass <code>Show</code>, Haskell
teria reclamado conosco, alegando que não sabe como representar uma
pessoa como uma string. Mas agora que derivamos uma instância
<code>Show</code> para ele, ele sabe.</p>
<p><code>Read</code> é praticamente a typeclass inversa de
<code>Show</code>. <code>Show</code> é para converter valores de um tipo
em uma string, <code>Read</code> é para converter strings em valores de
nosso tipo. Lembre-se, porém, quando usamos a função <code>read</code>,
precisamos usar uma anotação de tipo explícita para dizer ao Haskell
qual tipo queremos obter como resultado. Se não tornarmos o tipo que
queremos como resultado explícito, Haskell não sabe qual tipo
queremos.</p>
<p><code>{.haskell:hs} ghci&gt; read "Person {firstName =\"Michael\", lastName =\"Diamond\", age = 43}" :: Person Person {firstName = "Michael", lastName = "Diamond", age = 43}</code></p>
<p>Se usarmos o resultado de nossa leitura <code>read</code> mais tarde,
de uma maneira que Haskell possa inferir que ele deve lê-lo como uma
pessoa, não precisamos usar a anotação do tipo.</p>
<p><code>{.haskell:hs} ghci&gt; read "Person {firstName =\"Michael\", lastName =\"Diamond\", age = 43}" == mikeD True</code></p>
<p>Também podemos ler tipos parametrizados, mas temos que preencher os
parâmetros do tipo. Portanto, não podemos fazer
<code>read "Just 't'" :: Maybe a</code>, mas podemos fazer
<code>read "Just 't'" :: Maybe Char</code>.</p>
<p>Podemos derivar instâncias para a classe de tipo <code>Ord</code>,
que é para tipos que têm valores que podem ser ordenados. Se compararmos
dois valores do mesmo tipo que foram feitos usando construtores
diferentes, o valor que foi feito com um construtor definido primeiro é
considerado menor. Por exemplo, considere o tipo <code>Bool</code>, que
pode ter um valor de <code>False</code> ou <code>True</code>. Com o
objetivo de ver como ele se comporta quando comparado, podemos pensar
nele como sendo implementado assim:</p>
<p><code>{.haskell:hs} data Bool = False | True deriving (Ord)</code></p>
<p>Como o construtor de valor <code>False</code> é especificado primeiro
e o construtor de valor <code>True</code> é especificado depois dele,
podemos considerar <code>True</code> como maior que
<code>False</code>.</p>
<p><code>{.haskell:hs} ghci&gt; True `compare` False GT ghci&gt; True &gt; False True ghci&gt; True &lt; False False</code></p>
<p>No tipo de dados <code>Maybe a</code>, o construtor de valor
<code>Nothing</code> é especificado antes do construtor de valor
<code>Just</code>, portanto, um valor de <code>Nothing</code> é sempre
menor que um valor de <code>Just something</code>, mesmo que esse algo
seja menos um bilhão de trilhões. Mas se compararmos dois valores
<code>Just</code>, então ele compara o que está dentro deles.</p>
<p><code>{.haskell:hs} ghci&gt; Nothing &lt; Just 100 True ghci&gt; Nothing &gt; Just (-49999) False ghci&gt; Just 3 `compare` Just 2 GT ghci&gt; Just 100 &gt; Just 50 True</code></p>
<p>Mas não podemos fazer algo como
<code>Just (*3) &gt; Just (*2)</code>, porque <code>(*3)</code> e
<code>(*2)</code> são funções, que não são instâncias de
<code>Ord</code>.</p>
<p>Podemos usar facilmente tipos de dados algébricos para fazer
enumerações e as typeclasses <code>Enum</code> e <code>Bounded</code>
nos ajudam com isso. Considere o seguinte tipo de dados:</p>
<p><code>{.haskell:hs} data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday</code></p>
<p>Como todos os construtores de valor são nullary (não aceitam
parâmetros, ou seja, campos), podemos torná-lo parte da typeclass
<code>Enum</code>. A typeclass <code>Enum</code> é para coisas que têm
predecessores e sucessores. Também podemos torná-lo parte da typeclass
<code>Bounded</code>, que é para coisas que têm o menor valor possível e
o valor mais alto possível. E enquanto estamos nisso, vamos torná-lo
também uma instância de todos as outras typeclasses deriváveis e ver o
que podemos fazer com isso.</p>
<p><code>{.haskell:hs} data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday            deriving (Eq, Ord, Show, Read, Bounded, Enum)</code></p>
<p>Como faz parte das typeclasses <code>Show</code> e <code>Read</code>,
podemos converter valores desse tipo para e de strings.</p>
<p><code>{.haskell:hs} ghci&gt; Wednesday Wednesday ghci&gt; show Wednesday "Wednesday" ghci&gt; read "Saturday" :: Day Saturday</code></p>
<p>Como faz parte das typeclasses <code>Eq</code> e <code>Ord</code>,
podemos comparar ou igualar dias.</p>
<p><code>{.haskell:hs} ghci&gt; Saturday == Sunday False ghci&gt; Saturday == Saturday True ghci&gt; Saturday &gt; Friday True ghci&gt; Monday `compare` Wednesday LT</code></p>
<p>Também faz parte de <code>Bounded</code>, para que possamos obter o
dia mais baixo e o mais alto.</p>
<p><code>{.haskell:hs} ghci&gt; minBound :: Day Monday ghci&gt; maxBound :: Day Sunday</code></p>
<p>Também é uma instância de <code>Enum</code>. Podemos obter
predecessores e sucessores de dias e podemos fazer faixas de lista a
partir deles!</p>
<p><code>{.haskell:hs} ghci&gt; succ Monday Tuesday ghci&gt; pred Saturday Friday ghci&gt; [Thursday .. Sunday] [Thursday,Friday,Saturday,Sunday] ghci&gt; [minBound .. maxBound] :: [Day] [Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday]</code></p>
<p>Isso é incrível.</p>
<h2>Sinônimos de tipo (Type synonyms) {#type-synonyms}</h2>
<p>Anteriormente, mencionamos que, ao escrever tipos, os tipos
<code>[Char]</code> e <code>String</code> são equivalentes e
intercambiáveis. Isso é implementado com <strong>sinônimos de
tipo</strong>. Sinônimos de tipo realmente não fazem nada por si, são
apenas para dar a alguns tipos nomes diferentes, para que façam mais
sentido para alguém lendo nosso código e documentação. Veja como a
biblioteca padrão define <code>String</code> como sinônimo de
<code>[Char]</code>.</p>
<p><code>{.haskell:hs} type String = [Char]</code></p>
<p><img
src="assets/images/making-our-own-types-and-typeclasses/chicken.png"
alt="chicken" />{.left width=169 height=225}</p>
<p>Introduzimos a palavra-chave <em>type</em>. A palavra-chave pode ser
enganosa para alguns, porque não estamos realmente criando nada novo
(fizemos isso com a palavra-chave <em>data</em>), mas estamos apenas
criando um sinônimo para um tipo já existente.</p>
<p>Se fizermos uma função que converte uma string para maiúsculas e a
chamarmos <code>toUpperString</code> ou algo assim, podemos dar a ela
uma declaração de tipo de
<code>toUpperString :: [Char] -&gt; [Char]</code> ou
<code>toUpperString :: String -&gt; String</code>. Ambos são
essencialmente os mesmos, apenas o último é mais agradável de ler.</p>
<p>Quando estávamos lidando com o módulo <code>Data.Map</code>, primeiro
representamos uma lista telefônica com uma lista de associação antes de
convertê-la em um mapa. Como já descobrimos, uma lista de associação é
uma lista de pares de valores-chave. Vamos ver uma lista telefônica que
tínhamos.</p>
<p><code>{.haskell:hs} phoneBook :: [(String,String)] phoneBook =     [("amelia","555-2938")     ,("freya","452-2928")     ,("isabella","493-2928")     ,("neil","205-2928")     ,("roald","939-8282")     ,("tenzing","853-2492")     ]</code></p>
<p>Vemos que o tipo de <code>phoneBook</code> é
<code>[(String,String)]</code>. Isso nos diz que é uma lista de
associação que mapeia de strings para strings, mas não muito mais. Vamos
criar um sinônimo de tipo para transmitir mais informações na declaração
de tipo.</p>
<p><code>{.haskell:hs} type PhoneBook = [(String,String)]</code></p>
<p>Agora, a declaração de tipo para nossa lista telefônica pode ser
<code>phoneBook :: PhoneBook</code>. Vamos criar um sinônimo de tipo
para <code>String</code> também.</p>
<p><code>{.haskell:hs} type PhoneNumber = String type Name = String type PhoneBook = [(Name,PhoneNumber)]</code></p>
<p>Dar sinônimos de tipo para <code>String</code> é algo que os
programadores de Haskell fazem quando querem transmitir mais informações
sobre o que as strings em suas funções devem ser usadas e o que elas
representam.</p>
<p>Então agora, quando implementamos uma função que pega um nome e um
número e vê se essa combinação de nome e número está em nossa lista
telefônica, podemos dar uma declaração de tipo muito bonita e
descritiva.</p>
<p><code>{.haskell:hs} inPhoneBook :: Name -&gt; PhoneNumber -&gt; PhoneBook -&gt; Bool inPhoneBook name pnumber pbook = (name,pnumber) `elem` pbook</code></p>
<p>Se decidíssemos não usar sinônimos de tipo, nossa função teria um
tipo de
<code>String -&gt; String -&gt; [(String,String)] -&gt; Bool</code>.
Nesse caso, a declaração de tipo que aproveitou os sinônimos do tipo é
mais fácil de entender. No entanto, você não deve exagerar com eles.
Introduzimos sinônimos de tipo para descrever o que algum tipo existente
representa em nossas funções (e, portanto, nossas declarações de tipo se
tornam uma documentação melhor) ou quando algo tem um tipo longo que é
repetido muito (como <code>[(String,String)]</code>), mas representa
algo mais específico no contexto de nossas funções.</p>
<p>Os sinônimos de tipo também podem ser parametrizados. Se queremos um
tipo que represente um tipo de lista de associação, mas ainda queremos
que seja geral para que possa usar qualquer tipo como chaves e valores,
podemos fazer isso:</p>
<p><code>{.haskell:hs} type AssocList k v = [(k,v)]</code></p>
<p>Agora, uma função que obtém o valor por uma chave em uma lista de
associação pode ter um tipo de
<code>(Eq k) =&gt; k -&gt; AssocList k v -&gt; Maybe v</code>.
<code>AssocList</code> é um construtor de tipos que recebe dois tipos e
produz um tipo concreto, como <code>AssocList Int String</code>, por
exemplo.</p>
<p>::: {.hintbox} <strong>Fonzie diz:</strong> Aaay! Quando falo em
<em>tipos concretos</em>, quero dizer tipos totalmente aplicados, como
<code>Map Int String</code> ou se estamos lidando com uma delas funções
polimórficas, <code>[a]</code> ou <code>(Ord a) =&gt; Maybe a</code> e
outras coisas. E tipo, às vezes eu e meus amigos dizemos que
<code>Maybe</code> é um tipo, mas não queremos dizer isso, porque todo
idiota sabe que <code>Maybe</code> é um construtor de tipos. Quando
aplico um tipo extra a <code>Maybe</code>, como
<code>Maybe String</code>, tenho um tipo concreto. Você sabe, valores só
podem ter tipos que são tipos concretos! Portanto, em conclusão, viva
rápido, ame intensamente e não deixe ninguém usar seu pente! :::</p>
<p>Assim como podemos aplicar parcialmente funções para obter novas
funções, podemos aplicar parcialmente parâmetros de tipo e obter novos
construtores de tipos a partir deles.</p>
<p>Assim como chamamos uma função com poucos parâmetros para obter uma
nova função, podemos especificar um construtor de tipos com poucos
parâmetros de tipo e obter um construtor de tipos parcialmente aplicado.
Se quiséssemos um tipo que representasse um mapa (de
<code>Data.Map</code>) de inteiros para algo, poderíamos fazer isso:</p>
<p><code>{.haskell:hs} type IntMap v = Map Int v</code></p>
<p>Ou poderíamos fazer assim:</p>
<p><code>{.haskell:hs} type IntMap = Map Int</code></p>
<p>De qualquer maneira, o construtor de tipos <code>IntMap</code> recebe
um parâmetro e esse é o tipo do que os inteiros apontarão.</p>
<p>::: {.hintbox} <strong>Ah sim</strong>. Se você tentar implementar
isso, provavelmente precisará fazer uma importação qualificada de
<code>Data.Map</code>. Quando você faz uma importação qualificada, os
construtores de tipos também devem ser precedidos por um nome de módulo.
Então você escreveria <code>type IntMap = Map.Map Int</code>. :::</p>
<p>Certifique-se de realmente entender a distinção entre construtores de
tipos e construtores de valor. Só porque criamos um sinônimo de tipo
chamado <code>IntMap</code> ou <code>AssocList</code> não significa que
podemos fazer coisas como <code>AssocList [(1,2),(4,5),(7,9)]</code>.
Tudo o que significa é que podemos nos referir ao seu tipo usando nomes
diferentes. Podemos fazer
<code>[(1,2),(3,5),(8,9)] :: AssocList Int Int</code>, que fará com que
os números assumam um tipo de <code>Int</code>, mas ainda podemos usar
essa lista como faríamos com qualquer lista normal que tenha pares de
inteiros dentro. Sinônimos de tipo (e tipos geralmente) só podem ser
usados na parte de tipo do Haskell. Estamos na parte de tipos do Haskell
sempre que estamos definindo novos tipos (portanto, em declarações
<em>data</em> e <em>type</em>) ou quando estamos localizados após um
<code>::</code>. O <code>::</code> está em declarações de tipo ou em
anotações de tipo.</p>
<p>Outro tipo de dados muito legal que leva dois tipos como parâmetros é
o tipo <code>Either a b</code>. É mais ou menos assim que ele é
definido:</p>
<p><code>{.haskell:hs} data Either a b = Left a | Right b deriving (Eq, Ord, Read, Show)</code></p>
<p>Tem dois construtores de valor. Se o <code>Left</code> for usado, seu
conteúdo será do tipo <code>a</code> e se o <code>Right</code> for
usado, seu conteúdo será do tipo <code>b</code>. Portanto, podemos usar
esse tipo para encapsular um valor de um tipo ou outro e, quando obtemos
um valor do tipo <code>Either a b</code>, geralmente fazemos pattern
matching em <code>Left</code> e <code>Right</code> e fazemos coisas
diferentes com base em qual deles era.</p>
<p><code>{.haskell:hs} ghci&gt; Right 20 Right 20 ghci&gt; Left "w00t" Left "w00t" ghci&gt; :t Right 'a' Right 'a' :: Either a Char ghci&gt; :t Left True Left True :: Either Bool b</code></p>
<p>Até agora, vimos que <code>Maybe a</code> era usado principalmente
para representar os resultados de cálculos que poderiam ter falhado ou
não. Mas às vezes, <code>Maybe a</code> não é bom o suficiente porque
<code>Nothing</code> não transmite muita informação além de que algo
falhou. Isso é legal para funções que podem falhar de apenas uma maneira
ou se simplesmente não estamos interessados em como e por que falharam.
Uma pesquisa em <code>Data.Map</code> falha apenas se a chave que
estávamos procurando não estava no mapa, então sabemos exatamente o que
aconteceu. No entanto, quando estamos interessados em como alguma função
falhou ou por que, geralmente usamos o tipo de resultado de
<code>Either a b</code>, onde <code>a</code> é algum tipo de tipo que
pode nos dizer algo sobre a possível falha e <code>b</code> é o tipo de
um cálculo bem-sucedido. Portanto, os erros usam o construtor de valor
<code>Left</code>, enquanto os resultados usam <code>Right</code>.</p>
<p>Um exemplo: uma escola secundária tem armários para que os alunos
tenham algum lugar para colocar seus pôsteres do Guns'n'Roses. Cada
armário tem uma combinação de código. Quando um aluno deseja um novo
armário, ele diz ao supervisor do armário qual número de armário deseja
e ele lhes dá o código. No entanto, se alguém já estiver usando esse
armário, ele não poderá dizer o código do armário e eles terão que
escolher um diferente. Usaremos um mapa de <code>Data.Map</code> para
representar os armários. Ele mapeará dos números de armários para um par
de se o armário está em uso ou não e o código do armário.</p>
<p>```{.haskell:hs} import qualified Data.Map as Map</p>
<p>data LockerState = Taken | Free deriving (Show, Eq)</p>
<p>type Code = String</p>
<p>type LockerMap = Map.Map Int (LockerState, Code) ```</p>
<p>Coisas simples. Introduzimos um novo tipo de dados para representar
se um armário é tomado ou gratuito e fazemos um sinônimo de tipo para o
código do armário. Também criamos um sinônimo de tipo para o tipo que
mapeia de números inteiros para pares de estado e código de armário. E
agora, vamos criar uma função que procure o código em um mapa de
armário. Vamos usar um tipo <code>Either String Code</code> para
representar nosso resultado, porque nossa pesquisa pode falhar de duas
maneiras --- o armário pode ser tomado, caso em que não podemos contar o
código ou o número do armário pode não existir.</p>
<p>Se a pesquisa falhar, vamos usar uma <code>String</code> para contar
o que aconteceu.</p>
<p><code>{.haskell:hs} lockerLookup :: Int -&gt; LockerMap -&gt; Either String Code lockerLookup lockerNumber map =     case Map.lookup lockerNumber map of         Nothing -&gt; Left $ "Locker number " ++ show lockerNumber ++ " doesn't exist!"         Just (state, code) -&gt; if state /= Taken                                 then Right code                                 else Left $ "Locker " ++ show lockerNumber ++ " is already taken!"</code></p>
<p>Fazemos uma pesquisa normal no mapa. Se recebermos um
<code>Nothing</code>, retornaremos um valor do tipo
<code>Left String</code>, dizendo que o armário não existe. Se o
encontrarmos, fazemos uma verificação adicional para ver se o armário é
levado. Se for, retorne um <code>Left</code> dizendo que já foi tomado.
Ao contrário, retornamos um valor do tipo <code>Right Code</code>, no
qual damos ao aluno o código correto para o armário. Na verdade, é um
<code>Right String</code>, mas introduzimos esse sinônimo de tipo para
introduzir alguma documentação adicional na declaração do tipo. Aqui
está um mapa de exemplo:</p>
<p><code>{.haskell:hs} lockers :: LockerMap lockers = Map.fromList     [(100,(Taken,"ZD39I"))     ,(101,(Free,"JAH3I"))     ,(103,(Free,"IQSA9"))     ,(105,(Free,"QOTSA"))     ,(109,(Taken,"893JJ"))     ,(110,(Taken,"99292"))     ]</code></p>
<p>Agora vamos tentar procurar alguns códigos de armário.</p>
<p><code>{.haskell:hs} ghci&gt; lockerLookup 101 lockers Right "JAH3I" ghci&gt; lockerLookup 100 lockers Left "Locker 100 is already taken!" ghci&gt; lockerLookup 102 lockers Left "Locker number 102 doesn't exist!" ghci&gt; lockerLookup 110 lockers Left "Locker 110 is already taken!" ghci&gt; lockerLookup 105 lockers Right "QOTSA"</code></p>
<p>Poderíamos ter usado um <code>Maybe a</code> para representar o
resultado, mas não saberíamos por que não conseguimos o código. Mas
agora temos informações sobre a falha no nosso tipo de resultado.</p>
<h2>Estruturas de dados recursivas (Recursive data structures)
{#recursive-data-structures}</h2>
<p><img
src="assets/images/making-our-own-types-and-typeclasses/thefonz.png"
alt="the fonz" />{.right width=168 height=301}</p>
<p>Como vimos, um construtor em um tipo de dado algébrico pode ter
vários campos (ou nenhum) e cada campo deve ser de algum tipo concreto.
Com isso em mente, podemos criar tipos cujos construtores têm campos do
mesmo tipo! Usando isso, podemos criar tipos de dados recursivos, onde
um valor de algum tipo contém valores desse tipo, que por sua vez contêm
mais valores do mesmo tipo e assim por diante.</p>
<p>Pense nesta lista: <code>[5]</code>. Isso é apenas açúcar sintático
para <code>5:[]</code>. No lado esquerdo do <code>:</code>, há um valor
e no lado direito, há uma lista. E, neste caso, é uma lista vazia.
Agora, e a lista <code>[4,5]</code>? Bem, isso desaçucara para
<code>4:(5:[])</code>. Olhando para o primeiro <code>:</code>, vemos que
ele também tem um elemento no lado esquerdo e uma lista
(<code>5:[]</code>) no lado direito. O mesmo vale para uma lista como
<code>3:(4:(5:6:[]))</code>, que pode ser escrita assim ou como
<code>3:4:5:6:[]</code> (porque <code>:</code> é associativo à direita)
ou <code>[3,4,5,6]</code>.</p>
<p>Poderíamos dizer que uma lista pode ser uma lista vazia ou pode ser
um elemento unido a um <code>:</code> com outra lista (que pode ser a
lista vazia ou não).</p>
<p>Vamos usar tipos de dados algébricos para implementar nossa própria
lista então!</p>
<p><code>{.haskell:hs} data List a = Empty | Cons a (List a) deriving (Show, Read, Eq, Ord)</code></p>
<p>Isso soa exatamente como a nossa definição de listas de um dos
parágrafos anteriores. É uma lista vazia ou uma combinação de uma cabeça
com algum valor e uma lista. Se você está confuso sobre isso, pode achar
mais fácil entender na sintaxe de registro.</p>
<p><code>{.haskell:hs} data List a = Empty | Cons { listHead :: a, listTail :: List a} deriving (Show, Read, Eq, Ord)</code></p>
<p>Você também pode estar confuso sobre o construtor <code>Cons</code>
aqui. <em>cons</em> é outra palavra para <code>:</code>. Você vê, em
listas, <code>:</code> é na verdade um construtor que assume um valor e
outra lista e retorna uma lista. Já podemos usar nosso novo tipo de
lista! Em outras palavras, possui dois campos. Um campo é do tipo de
<code>a</code> e o outro é do tipo <code>[a]</code>.</p>
<p><code>{.haskell:hs} ghci&gt; Empty Empty ghci&gt; 5 `Cons` Empty Cons 5 Empty ghci&gt; 4 `Cons` (5 `Cons` Empty) Cons 4 (Cons 5 Empty) ghci&gt; 3 `Cons` (4 `Cons` (5 `Cons` Empty)) Cons 3 (Cons 4 (Cons 5 Empty))</code></p>
<p>Chamamos nosso construtor <code>Cons</code> de maneira infixa para
que você possa ver como é exatamente como <code>:</code>.
<code>Empty</code> é como <code>[]</code> e
<code>4 `Cons` (5 `Cons` Empty)</code> é como <code>4:(5:[])</code>.</p>
<p>Podemos definir funções para serem infixas automaticamente, fazendo
com que consistam apenas em caracteres especiais. Também podemos fazer o
mesmo com construtores, pois são apenas funções que retornam um tipo de
dados. Então confira isso.</p>
<p><code>{.haskell:hs} infixr 5 :-: data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord)</code></p>
<p>Primeiro de tudo, notamos uma nova construção sintática, as
declarações de fixidade. Quando definimos funções como operadores,
podemos usar isso para dar a elas uma fixidade (mas não precisamos). Uma
fixidade afirma o quão fortemente o operador se liga e se é associativo
à esquerda ou à direita. Por exemplo, a fixidade de <code>*</code> é
<code>infixl 7 *</code> e a fixidade de <code>+</code> é
<code>infixl 6</code>. Isso significa que ambos são associativos à
esquerda (<code>4 * 3 * 2</code> é <code>(4 * 3) * 2</code>), mas
<code>*</code> liga mais forte que <code>+</code>, porque tem uma
fixidade maior, então <code>5 * 4 + 3</code> é
<code>(5 * 4) + 3</code>.</p>
<p>Caso contrário, acabamos de escrever <code>a :-: (List a)</code> em
vez de <code>Cons a (List a)</code>. Agora, podemos escrever listas em
nosso tipo de lista assim:</p>
<p><code>{.haskell:hs} ghci&gt; 3 :-: 4 :-: 5 :-: Empty (:-:) 3 ((:-:) 4 ((:-:) 5 Empty)) ghci&gt; let a = 3 :-: 4 :-: 5 :-: Empty ghci&gt; 100 :-: a (:-:) 100 ((:-:) 3 ((:-:) 4 ((:-:) 5 Empty)))</code></p>
<p>Ao derivar <code>Show</code> para o nosso tipo, o Haskell ainda o
exibirá como se o construtor fosse uma função de prefixo, daí os
parênteses ao redor do operador (lembre-se, <code>4 + 3</code> é
<code>(+) 4 3</code>).</p>
<p>Vamos fazer uma função que adicione duas de nossas listas juntas. É
assim que <code>++</code> é definido para listas normais:</p>
<p><code>{.haskell:hs} infixr 5  ++ (++) :: [a] -&gt; [a] -&gt; [a] []     ++ ys = ys (x:xs) ++ ys = x : (xs ++ ys)</code></p>
<p>Então, vamos roubar isso para nossa própria lista. Nomearemos a
função <code>.++</code>.</p>
<p><code>{.haskell:hs} infixr 5  .++ (.++) :: List a -&gt; List a -&gt; List a Empty .++ ys = ys (x :-: xs) .++ ys = x :-: (xs .++ ys)</code></p>
<p>E vamos ver se funciona ...</p>
<p><code>{.haskell:hs} ghci&gt; let a = 3 :-: 4 :-: 5 :-: Empty ghci&gt; let b = 6 :-: 7 :-: Empty ghci&gt; a .++ b (:-:) 3 ((:-:) 4 ((:-:) 5 ((:-:) 6 ((:-:) 7 Empty))))</code></p>
<p>Legal.</p>
<p>Se quiséssemos, poderíamos implementar todas as funções que operam em
listas em nosso próprio tipo de lista.</p>
<p>Observe como fizemos pattern matching em <code>(x :-: xs)</code>.
Isso funciona porque a correspondência de padrões é realmente sobre
construtores correspondentes. Podemos combinar em <code>:-:</code>
porque é um construtor para o nosso próprio tipo de lista e também
podemos corresponder a <code>:</code> porque é um construtor para o tipo
de lista interna. O mesmo vale para <code>[]</code>. Como a
correspondência de padrões funciona (apenas) nos construtores, podemos
corresponder a coisas assim, construtores prefixados normais ou coisas
como <code>8</code> ou <code>'a'</code>, que são basicamente
construtores para os tipos numéricos e de caracteres,
respectivamente.</p>
<p><img
src="assets/images/making-our-own-types-and-typeclasses/binarytree.png"
alt="binary search tree" />{.left width=323 height=225}</p>
<p>Agora, vamos implementar uma <strong>árvore de busca
binária</strong>. Se você não está familiarizado com as árvores de busca
binária de idiomas como C, aqui está o que elas são: um elemento aponta
para dois elementos, um à esquerda e outro à direita. O elemento à
esquerda é menor, o elemento à direita é maior. Cada um desses elementos
também pode apontar para dois elementos (ou um ou nenhum). Com efeito,
cada elemento tem até duas subárvores. E uma coisa legal sobre as
árvores de busca binária é que sabemos que todos os elementos na
subárvore esquerda de, digamos, 5 serão menores que 5. Elementos em sua
subárvore certa serão maiores. Portanto, se precisarmos descobrir se 8
está em nossa árvore, começaríamos com 5 e, porque 8 é maior que 5,
iríamos para a direita. Estamos agora no 7 e porque 8 é maior que 7,
vamos para a direita novamente. E encontramos nosso elemento em três
saltos! Agora, se fosse uma lista normal (ou uma árvore, mas realmente
desequilibrada), levaria sete lúpulos em vez de três para ver se 8 está
lá.</p>
<p>Conjuntos e mapas de <code>Data.Set</code> e <code>Data.Map</code>
são implementados usando árvores, apenas em vez de árvores de busca
binária normais, eles usam árvores de busca binária equilibradas, que
são sempre equilibradas. Mas agora, estaremos apenas implementando
árvores de busca binária normais.</p>
<p>Aqui está o que vamos dizer: uma árvore é uma árvore vazia ou é um
elemento que contém algum valor e duas árvores. Parece um ajuste
perfeito para um tipo de dados algébrico!</p>
<p><code>{.haskell:hs} data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)</code></p>
<p>Ok, bom, isso é bom. Em vez de construir manualmente uma árvore,
faremos uma função que pega uma árvore e um elemento e insere um
elemento. Fazemos isso comparando o valor que queremos inserir no nó
raiz e, se for menor, vamos para a esquerda, se for maior, vamos para a
direita. Fazemos o mesmo para cada nó subsequente até chegarmos a uma
árvore vazia. Depois de chegarmos a uma árvore vazia, apenas inserimos
um nó com esse valor em vez da árvore vazia.</p>
<p>Em linguagens como C, faríamos isso modificando os ponteiros e
valores dentro da árvore. No Haskell, não podemos realmente modificar
nossa árvore, por isso temos que criar uma nova subárvore a cada vez que
decidimos ir para a esquerda ou direita e, no final, a função de
inserção retorna uma árvore completamente nova, porque o Haskell
realmente não tem um conceito de ponteiro, apenas valores. Portanto, o
tipo para nossa função de inserção será algo como
<code>a -&gt; Tree a -&gt; Tree a</code>. Pega um elemento e uma árvore
e retorna uma nova árvore que tem esse elemento dentro. Isso pode
parecer ineficiente, mas a preguiça cuida desse problema.</p>
<p>Então, aqui estão duas funções. Uma é uma função de utilidade para
criar uma árvore singleton (uma árvore com apenas um nó) e uma função
para inserir um elemento em uma árvore.</p>
<p>```{.haskell:hs} singleton :: a -&gt; Tree a singleton x = Node x
EmptyTree EmptyTree</p>
<p>treeInsert :: (Ord a) =&gt; a -&gt; Tree a -&gt; Tree a treeInsert x
EmptyTree = singleton x treeInsert x (Node a left right) | x == a = Node
x left right | x &lt; a = Node a (treeInsert x left) right | x &gt; a =
Node a left (treeInsert x right) ```</p>
<p>A função <code>singleton</code> é apenas um atalho para criar um nó
que tenha algo e depois duas subárvores vazias. Na função de inserção,
primeiro temos a condição de borda como um padrão. Se chegamos a uma
subárvore vazia, isso significa que estamos onde queremos e, em vez da
árvore vazia, colocamos uma árvore singleton com nosso elemento. Se não
estamos inserindo em uma árvore vazia, temos que verificar algumas
coisas. Primeiro, se o elemento que estamos inserindo for igual ao
elemento raiz, basta retornar uma árvore que seja a mesma. Se for menor,
retorne uma árvore que tenha o mesmo valor da raiz, a mesma subárvore
direita, mas em vez de sua subárvore esquerda, coloque uma árvore que
tenha nosso valor inserido nela.</p>
<p>O mesmo (mas o contrário) acontece se nosso valor for maior que o
elemento raiz.</p>
<p>Em seguida, faremos uma função que verifique se algum elemento está
na árvore. Primeiro, vamos definir a condição de borda. Se estamos
procurando um elemento em uma árvore vazia, certamente não está lá. OK.
Observe como isso é o mesmo que a condição de borda ao procurar
elementos nas listas. Se estamos procurando um elemento em uma lista
vazia, não está lá. De qualquer forma, se não estamos procurando um
elemento em uma árvore vazia, verificamos algumas coisas. Se o elemento
no nó raiz é o que estamos procurando, ótimo! Se não for, então o que?
Bem, podemos tirar proveito de saber que todos os elementos esquerdos
são menores que o nó raiz. Portanto, se o elemento que estamos
procurando é menor que o nó raiz, verifique se está na subárvore
esquerda. Se for maior, verifique se está na subárvore direita.</p>
<p><code>{.haskell:hs} treeElem :: (Ord a) =&gt; a -&gt; Tree a -&gt; Bool treeElem x EmptyTree = False treeElem x (Node a left right)     | x == a = True     | x &lt; a  = treeElem x left     | x &gt; a  = treeElem x right</code></p>
<p>Tudo o que tínhamos que fazer era escrever o parágrafo anterior em
código. Vamos nos divertir com nossas árvores! Em vez de construir
manualmente uma (embora pudéssemos), usaremos uma dobra (fold) para
construir uma árvore a partir de uma lista. Lembre-se, praticamente tudo
o que atravessa uma lista um por um e depois retorna algum tipo de valor
pode ser implementado com uma dobra! Vamos começar com a árvore vazia e
depois abordar uma lista da direita e apenas inserir elemento após
elemento em nossa árvore acumuladora.</p>
<p><code>{.haskell:hs} ghci&gt; let nums = [8,6,4,1,7,3,5] ghci&gt; let numsTree = foldr treeInsert EmptyTree nums ghci&gt; numsTree Node 5 (Node 3 (Node 1 EmptyTree EmptyTree) (Node 4 EmptyTree EmptyTree)) (Node 7 (Node 6 EmptyTree EmptyTree) (Node 8 EmptyTree EmptyTree))</code></p>
<p>Nesse <code>foldr</code>, <code>treeInsert</code> era a função de
dobra (leva uma árvore e um elemento de lista e produz uma nova árvore)
e <code>EmptyTree</code> era o acumulador inicial. <code>nums</code>, é
claro, era a lista sobre a qual estávamos dobrando.</p>
<p>Quando imprimimos nossa árvore no console, não é muito legível, mas
se tentarmos, podemos distinguir sua estrutura. Vemos que o nó raiz é 5
e, em seguida, possui duas subárvores, uma das quais tem o nó raiz de 3
e a outra a 7, etc.</p>
<p><code>{.haskell:hs} ghci&gt; 8 `treeElem` numsTree True ghci&gt; 100 `treeElem` numsTree False ghci&gt; 1 `treeElem` numsTree True ghci&gt; 10 `treeElem` numsTree False</code></p>
<p>A verificação de associação também funciona muito bem. Legal.</p>
<p>Como você pode ver, as estruturas de dados algébricos são um conceito
muito legal e poderoso em Haskell. Podemos usá-las para fazer qualquer
coisa, desde valores booleanos e enumerações durante a semana até
árvores de busca binária e muito mais!</p>
<h2>Typeclasses 102 {#typeclasses-102}</h2>
<p><img
src="assets/images/making-our-own-types-and-typeclasses/trafficlight.png"
alt="tweet" />{.right width=175 height=480}</p>
<p>Até agora, aprendemos sobre algumas das typeclasses padrão de Haskell
e vimos quais tipos estão nelas. Também aprendemos como tornar
automaticamente nossos próprios tipos instâncias das typeclasses padrão,
pedindo ao Haskell para derivar as instâncias para nós. Nesta seção,
aprenderemos como fazer nossas próprias typeclasses e como fazer com que
as instâncias de tipos delas manualmente.</p>
<p>Uma rápida recapitulação sobre typeclasses: typeclasses são como
interfaces. Uma typeclass define algum comportamento (como comparar a
igualdade, comparar pedidos, enumeração) e, em seguida, tipos que podem
se comportar dessa maneira são feitos instâncias dessa typeclass. O
comportamento das typeclasses é alcançado definindo funções ou apenas
declarações de tipo que implementamos. Portanto, quando dizemos que um
tipo é uma instância de uma typeclass, queremos dizer que podemos usar
as funções que a typeclass define com esse tipo.</p>
<p>Typeclasses não têm quase nada a ver com classes em linguagens como
Java ou Python. Isso confunde muitas pessoas, então eu quero que você
esqueça tudo o que sabe sobre as classes em linguagens imperativas
agora.</p>
<p>Por exemplo, a typeclass <code>Eq</code> é para coisas que podem ser
equiparadas. Define as funções <code>==</code> e <code>/=</code>. Se
tivermos um tipo (digamos, <code>Car</code>) e comparar dois carros com
a função da igualdade <code>==</code> faz sentido, faz sentido que
<code>Car</code> seja uma instância de <code>Eq</code>.</p>
<p>É assim que a classe <code>Eq</code> é definida no prelude
padrão:</p>
<p><code>{.haskell:hs} class Eq a where     (==) :: a -&gt; a -&gt; Bool     (/=) :: a -&gt; a -&gt; Bool     x == y = not (x /= y)     x /= y = not (x == y)</code></p>
<p>Woah, woah, woah! Alguma sintaxe e palavras-chave estranhas novas lá!
Não se preocupe, tudo isso ficará claro em um segundo. Primeiro, quando
escrevemos <code>class Eq a where</code>, isso significa que estamos
definindo uma nova typeclass e que se chama <code>Eq</code>. O
<code>a</code> é a variável de tipo e significa que <code>a</code>
desempenhará o papel do tipo que em breve estaremos criando uma
instância de <code>Eq</code>. Não precisa ser chamado de <code>a</code>,
nem precisa ser uma letra, apenas precisa ser uma palavra minúscula. Em
seguida, definimos várias funções. Não é obrigatório implementar os
próprios corpos de função, apenas precisamos especificar as declarações
de tipo para as funções.</p>
<p>::: {.hintbox} Algumas pessoas podem entender isso melhor se
escrevêssemos <code>class Eq equatable where</code> e depois
especifiquemos as declarações de tipo como
<code>(==) :: equatable -&gt; equatable -&gt; Bool</code>. :::</p>
<p>De qualquer forma, <em>implementamos</em> os corpos de função para as
funções que definem <code>Eq</code>, apenas as definimos em termos de
recursão mútua. Dissemos que duas instâncias de <code>Eq</code> são
iguais se não forem diferentes e são diferentes se não forem iguais. Nós
não precisávamos fazer isso, na verdade, mas fizemos e veremos como isso
nos ajuda em breve.</p>
<p>::: {.hintbox} Se dissermos <code>class Eq a where</code> e, em
seguida, definirmos uma declaração de tipo dentro dessa classe como
<code>(==) :: a -&gt; a -&gt; Bool</code>, então, quando examinarmos o
tipo dessa função mais tarde, ele terá o tipo de
<code>(Eq a) =&gt; a -&gt; a -&gt; Bool</code>. :::</p>
<p>Então, uma vez que temos uma classe, o que podemos fazer com ela?
Bem, não muito, realmente. Mas assim que começamos a fazer instâncias de
tipos dessa classe, começamos a obter alguma funcionalidade agradável.
Então confira esse tipo:</p>
<p><code>{.haskell:hs} data TrafficLight = Red | Yellow | Green</code></p>
<p>Ele define os estados de um semáforo. Observe como não derivamos
nenhuma instância de classe para ela. Isso porque vamos escrever algumas
instâncias manualmente, mesmo que pudéssemos derivá-las para tipos como
<code>Eq</code> e <code>Show</code>. Veja como tornamos isso uma
instância de <code>Eq</code>.</p>
<p><code>{.haskell:hs} instance Eq TrafficLight where     Red == Red = True     Green == Green = True     Yellow == Yellow = True     _ == _ = False</code></p>
<p>Fizemos isso usando a palavra-chave <em>instance</em>. Portanto,
<em>class</em> é para definir novas typeclasses e <em>instance</em> é
para tornar nossos tipos instâncias de typeclasses. Quando estávamos
definindo <code>Eq</code>, escrevemos <code>class Eq a where</code> e
dissemos que <code>a</code> desempenha o papel de qualquer tipo que será
feito uma instância posteriormente. Podemos ver claramente aqui, porque
quando estamos fazendo uma instância, escrevemos
<code>instance Eq TrafficLight where</code>. Substituímos o
<code>a</code> pelo tipo real.</p>
<p>Como <code>==</code> foi definido em termos de <code>/=</code> e
vice-versa na declaração de <em>class</em>, apenas tivemos que
substituir um deles na declaração da instância. Isso é chamado de
definição completa mínima para a typeclass --- o mínimo de funções que
temos que implementar para que nosso tipo possa se comportar como a
classe anuncia. Para cumprir a definição completa mínima para
<code>Eq</code>, temos que substituir um de <code>==</code> ou
<code>/=</code>. Se <code>Eq</code> fosse definido simplesmente
assim:</p>
<p><code>{.haskell:hs} class Eq a where     (==) :: a -&gt; a -&gt; Bool     (/=) :: a -&gt; a -&gt; Bool</code></p>
<p>teríamos que implementar ambas as funções ao tornar um tipo uma
instância dela, porque Haskell não saberia como essas duas funções estão
relacionadas. A definição completa mínima seria então: <code>==</code> e
<code>/=</code>.</p>
<p>Você pode ver que implementamos <code>==</code> simplesmente fazendo
correspondência de padrões. Como há muito mais casos em que duas luzes
não são iguais, especificamos as que são iguais e depois fizemos um
padrão geral, dizendo que, se não for nenhuma das combinações
anteriores, duas luzes não serão iguais.</p>
<p>Vamos tornar isso uma instância de <code>Show</code> à mão também.
Para satisfazer a definição completa mínima de <code>Show</code>, só
precisamos implementar sua função <code>show</code>, que assume um valor
e o transforma em uma string.</p>
<p><code>{.haskell:hs} instance Show TrafficLight where     show Red = "Red light"     show Yellow = "Yellow light"     show Green = "Green light"</code></p>
<p>Mais uma vez, usamos a correspondência de padrões para alcançar
nossos objetivos. Vamos ver como funciona em ação:</p>
<p><code>{.haskell:hs} ghci&gt; Red == Red True ghci&gt; Red == Yellow False ghci&gt; Red `elem` [Red, Yellow, Green] True ghci&gt; [Red, Yellow, Green] [Red light,Yellow light,Green light]</code></p>
<p>Legal. Poderíamos ter acabado de derivar <code>Eq</code> e isso teria
o mesmo efeito (mas não o fizemos para fins educacionais). No entanto,
derivar <code>Show</code> teria traduzido diretamente os construtores de
valor em strings. Mas se queremos que as luzes pareçam
<code>"Red light"</code>, precisamos fazer a declaração da instância
manualmente.</p>
<p>Você também pode criar typeclasses que são subclasses de outras
typeclasses. A declaração de <em>class</em> para <code>Num</code> é um
pouco longa, mas aqui está a primeira parte:</p>
<p><code>{.haskell:hs} class (Eq a) =&gt; Num a where    ...</code></p>
<p>Como mencionamos anteriormente, existem muitos lugares onde podemos
agrupar restrições de classe. Portanto, isso é exatamente como escrever
<code>class Num a where</code>, apenas afirmamos que nosso tipo
<code>a</code> deve ser uma instância de <code>Eq</code>. Estamos
essencialmente dizendo que temos que fazer de um tipo uma instância de
<code>Eq</code> antes de podermos torná-lo uma instância de
<code>Num</code>. Antes que algum tipo possa ser considerado um número,
faz sentido que possamos determinar se os valores desse tipo podem ser
equiparados ou não. Isso é tudo o que existe para subclassificação, é
apenas uma restrição de classe em uma declaração <em>class</em>! Ao
definir corpos de função na declaração <em>class</em> ou ao defini-los
nas declarações <em>instance</em>, podemos supor que <code>a</code> faz
parte de <code>Eq</code> e, portanto, podemos usar <code>==</code> nos
valores desse tipo.</p>
<p>Mas como os tipos <code>Maybe</code> ou lista são feitos como
instâncias de typeclasses? O que torna o <code>Maybe</code> diferente
de, digamos, <code>TrafficLight</code> é que <code>Maybe</code> em si
não é um tipo concreto, é um construtor de tipos que leva um parâmetro
de tipo (como <code>Char</code> ou algo assim) para produzir um tipo
concreto (como <code>Maybe Char</code>). Vamos dar uma olhada na
typeclass <code>Eq</code> novamente:</p>
<p><code>{.haskell:hs} class Eq a where     (==) :: a -&gt; a -&gt; Bool     (/=) :: a -&gt; a -&gt; Bool     x == y = not (x /= y)     x /= y = not (x == y)</code></p>
<p>Das declarações de tipo, vemos que o <code>a</code> é usado como um
tipo concreto porque todos os tipos em funções precisam ser concretos
(lembre-se, você não pode ter uma função do tipo
<code>a -&gt; Maybe</code>, mas você pode ter uma função de
<code>a -&gt; Maybe a</code> ou
<code>Maybe Int -&gt; Maybe String</code>). É por isso que não podemos
fazer algo como</p>
<p><code>{.haskell:hs} instance Eq Maybe where     ...</code></p>
<p>Porque, como vimos, o <code>a</code> tem que ser um tipo concreto,
mas <code>Maybe</code> não é um tipo concreto. É um construtor de tipos
que recebe um parâmetro e depois produz um tipo concreto. Também seria
tedioso escrever <code>instance Eq (Maybe Int) where</code>,
<code>instance Eq (Maybe Char) where</code>, etc. para todos os tipos de
todos. Então, poderíamos escrever assim:</p>
<p><code>{.haskell:hs} instance Eq (Maybe m) where     Just x == Just y = x == y     Nothing == Nothing = True     _ == _ = False</code></p>
<p>Isso é como dizer que queremos tornar todos os tipos do formulário
<code>Maybe something</code> uma instância de <code>Eq</code>. Na
verdade, poderíamos ter escrito <code>(Maybe something)</code>, mas
geralmente optamos por letras únicas para serem fiéis ao estilo Haskell.
O <code>(Maybe m)</code> aqui desempenha o papel de <code>a</code> de
<code>class Eq a where</code>. Embora <code>Maybe</code> não seja um
tipo concreto, <code>Maybe m</code> é.</p>
<p>Ao especificar um parâmetro de tipo (<code>m</code>, que está em
minúsculas), dissemos que queremos que todos os tipos que estejam na
forma de <code>Maybe m</code>, onde <code>m</code> seja qualquer tipo,
seja uma instância de <code>Eq</code>.</p>
<p>Há um problema com isso. Você pode identificá-lo? Usamos
<code>==</code> no conteúdo de <code>Maybe</code>, mas não temos
garantia de que o que o <code>Maybe</code> contém pode ser usado com
<code>Eq</code>! É por isso que temos que modificar nossa declaração
<em>instance</em> assim:</p>
<p><code>{.haskell:hs} instance (Eq m) =&gt; Eq (Maybe m) where     Just x == Just y = x == y     Nothing == Nothing = True     _ == _ = False</code></p>
<p>Tivemos que adicionar uma restrição de classe! Com esta declaração
<em>instance</em>, dizemos o seguinte: queremos que todos os tipos da
forma <code>Maybe m</code> façam parte da typeclass <code>Eq</code>, mas
apenas esses tipos onde o <code>m</code> (o que está contido dentro do
<code>Maybe</code>) também faz parte de <code>Eq</code>. É assim que
Haskell derivaria a instância também.</p>
<p>Na maioria das vezes, as restrições de classe nas declarações
<em>class</em> são usadas para tornar uma typeclass uma subclasse de
outra typeclass e restrições de classe nas declarações <em>instance</em>
são usadas para expressar requisitos sobre o conteúdo de algum tipo. Por
exemplo, aqui exigimos que o conteúdo de <code>Maybe</code> também faça
parte da typeclass <code>Eq</code>.</p>
<p>Ao fazer instâncias, se você vir que um tipo é usado como um tipo
concreto nas declarações de tipo (como o <code>a</code> em
<code>a -&gt; a -&gt; Bool</code>), você deve fornecer parâmetros de
tipo e adicionar parênteses para que você acabe com um tipo
concreto.</p>
<p>::: {.hintbox} Leve em consideração que o tipo que você está tentando
criar uma instância substituirá o parâmetro na declaração
<em>class</em>. O <code>a</code> de <code>class Eq a where</code> será
substituído por um tipo real quando você fizer uma instância; portanto,
tente colocar mentalmente seu tipo nas declarações de tipo de função
também. <code>(==) :: Maybe -&gt; Maybe -&gt; Bool</code> não faz muito
sentido, mas
<code>(==) :: (Eq m) =&gt; Maybe m -&gt; Maybe m -&gt; Bool</code> faz.
Mas isso é apenas algo para se pensar, porque <code>==</code> sempre
terá um tipo de <code>(==) :: (Eq a) =&gt; a -&gt; a -&gt; Bool</code>,
não importa quais instâncias façamos. :::</p>
<p>Ooh, mais uma coisa, confira isso! Se você quiser ver quais são as
instâncias de uma typeclass, basta fazer
<code>:info YourTypeClass</code> no GHCI. Portanto, digitar
<code>:info Num</code> mostrará quais funções a typeclass define e
fornecerá uma lista dos tipos na typeclass. <code>:info</code> funciona
para tipos e construtores de tipos também. Se você fizer
<code>:info Maybe</code>, ele mostrará todas as typeclasses das quais
<code>Maybe</code> é uma instância. Também <code>:info</code> pode
mostrar a declaração de tipo de uma função. Eu acho isso muito
legal.</p>
<h2>Uma typeclass sim-não (A yes-no typeclass)
{#a-yes-no-typeclass}</h2>
<p><img
src="assets/images/making-our-own-types-and-typeclasses/yesno.png"
alt="yesno" />{.left width=201 height=111}</p>
<p>Em JavaScript e algumas outras linguagens de tipo fraco, você pode
colocar quase tudo dentro de uma expressão <code>if</code>. Por exemplo,
você pode fazer todas as seguintes opções:
<code>if (0) alert("YEAH!") else alert("NO!")</code>,
<code>if ("") alert ("YEAH!") else alert("NO!")</code>,
<code>if (false) alert("YEAH") else alert("NO!)</code>, etc. e todos
estes vão lançar um alerta de <code>NO!</code>. Se você fizer
<code>if ("WHAT") alert ("YEAH") else alert("NO!")</code>, ele alertará
um <code>"YEAH!"</code> porque o JavaScript considera que strings não
vazias são uma espécie de valor verdadeiro.</p>
<p>Embora o uso estritamente de <code>Bool</code> para a semântica
booleana funcione melhor em Haskell, vamos tentar implementar esse
comportamento JavaScript-ish de qualquer maneira. Por diversão! Vamos
começar com uma declaração de <em>class</em>.</p>
<p><code>{.haskell:hs} class YesNo a where     yesno :: a -&gt; Bool</code></p>
<p>Muito simples. A typeclass <code>YesNo</code> define uma função. Essa
função assume um valor de um tipo que pode ser considerado para manter
algum conceito de veracidade e nos diz com certeza se é verdade ou não.
Observe que, da maneira como usamos o <code>a</code> na função,
<code>a</code> deve ser um tipo concreto.</p>
<p>Em seguida, vamos definir algumas instâncias. Para números,
assumiremos que (como em JavaScript) qualquer número que não seja 0 é
verdadeiro e 0 é falso.</p>
<p><code>{.haskell:hs} instance YesNo Int where     yesno 0 = False     yesno _ = True</code></p>
<p>Listas vazias (e, por extensões, strings) são um valor não-ish,
enquanto listas não vazias são um valor yes-ish.</p>
<p><code>{.haskell:hs} instance YesNo [a] where     yesno [] = False     yesno _ = True</code></p>
<p>Observe como apenas colocamos um parâmetro de tipo <code>a</code> lá
para tornar a lista um tipo concreto, mesmo que não façamos suposições
sobre o tipo contido na lista. O que mais, hmm ... Eu sei,
<code>Bool</code> em si também mantém a verdade e a falsidade e é
bastante óbvio qual é qual.</p>
<p><code>{.haskell:hs} instance YesNo Bool where     yesno = id</code></p>
<p>Hã? O que é <code>id</code>? É apenas uma função da biblioteca padrão
que aceita um parâmetro e retorna a mesma coisa, que é o que estaríamos
escrevendo aqui de qualquer maneira.</p>
<p>Vamos fazer de <code>Maybe a</code> uma instância também.</p>
<p><code>{.haskell:hs} instance YesNo (Maybe a) where     yesno (Just _) = True     yesno Nothing = False</code></p>
<p>Não precisávamos de uma restrição de classe porque não fizemos
suposições sobre o conteúdo do <code>Maybe</code>. Acabamos de dizer que
é verdadeiro se for um valor <code>Just</code> e falso se for um
<code>Nothing</code>. Ainda tínhamos que escrever <code>(Maybe a)</code>
em vez de apenas <code>Maybe</code>, porque se você pensar sobre isso,
uma função <code>Maybe -&gt; Bool</code> não pode existir (porque
<code>Maybe</code> não é um tipo concreto), enquanto uma
<code>Maybe a -&gt; Bool</code> é bom e elegante. Ainda assim, isso é
muito legal, porque agora, qualquer tipo de forma
<code>Maybe something</code> faz parte de <code>YesNo</code> e não
importa o que seja <code>something</code>.</p>
<p>Anteriormente, definimos um tipo <code>Tree a</code>, que
representava uma árvore de busca binária. Podemos dizer que uma árvore
vazia é falsa e qualquer coisa que não seja uma árvore vazia é
verdadeira.</p>
<p><code>{.haskell:hs} instance YesNo (Tree a) where     yesno EmptyTree = False     yesno _ = True</code></p>
<p>Um semáforo pode ser um valor sim ou não? Certo. Se estiver vermelho,
pare. Se estiver verde, vá. Se for amarelo? Eh, eu costumo correr nos
amarelos porque vivo pela adrenalina.</p>
<p><code>{.haskell:hs} instance YesNo TrafficLight where     yesno Red = False     yesno _ = True</code></p>
<p>Legal, agora que temos alguns exemplos, vamos brincar!</p>
<p><code>{.haskell:hs} ghci&gt; yesno $ length [] False ghci&gt; yesno "haha" True ghci&gt; yesno "" False ghci&gt; yesno $ Just 0 True ghci&gt; yesno True True ghci&gt; yesno EmptyTree False ghci&gt; yesno [] False ghci&gt; yesno [0,0,0] True ghci&gt; :t yesno yesno :: (YesNo a) =&gt; a -&gt; Bool</code></p>
<p>Certo, funciona! Vamos criar uma função que imite a instrução
<code>if</code>, mas funciona com valores <code>YesNo</code>.</p>
<p><code>{.haskell:hs} yesnoIf :: (YesNo y) =&gt; y -&gt; a -&gt; a -&gt; a yesnoIf yesnoVal yesResult noResult = if yesno yesnoVal then yesResult else noResult</code></p>
<p>Bastante simples. Pega um valor sim-não-ish e duas coisas. Se o valor
sim-não-ish for mais um sim, ele retornará a primeira das duas coisas,
caso contrário, retornará a segunda delas.</p>
<p><code>{.haskell:hs} ghci&gt; yesnoIf [] "YEAH!" "NO!" "NO!" ghci&gt; yesnoIf [2,3,4] "YEAH!" "NO!" "YEAH!" ghci&gt; yesnoIf True "YEAH!" "NO!" "YEAH!" ghci&gt; yesnoIf (Just 500) "YEAH!" "NO!" "YEAH!" ghci&gt; yesnoIf Nothing "YEAH!" "NO!" "NO!"</code></p>
<h2>A typeclass Functor (The Functor typeclass)
{#the-functor-typeclass}</h2>
<p>Até agora, encontramos muitas das typeclasses na biblioteca padrão.
Brincamos com <code>Ord</code>, que é para coisas que podem ser
encomendadas. Conversamos com <code>Eq</code>, que é para coisas que
podem ser equiparadas. Vimos <code>Show</code>, que apresenta uma
interface para tipos cujos valores podem ser exibidos como strings.
Nosso bom amigo <code>Read</code> está lá sempre que precisamos
converter uma string em um valor de algum tipo. E agora, vamos dar uma
olhada na typeclass <code>Functor</code>{.label .class}, que é
basicamente para coisas que podem ser mapeadas. Você provavelmente está
pensando em listas agora, já que o mapeamento sobre listas é um idioma
dominante em Haskell. E você está certo, o tipo de lista faz parte da
typeclass <code>Functor</code>.</p>
<p>Qual a melhor maneira de conhecer a typeclass <code>Functor</code> do
que ver como é implementada? Vamos dar uma espiada.</p>
<p><code>{.haskell:hs} class Functor f where     fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code></p>
<p><img
src="assets/images/making-our-own-types-and-typeclasses/functor.png"
alt="I AM FUNCTOOOOR!!!" />{.right width=220 height=441}</p>
<p>Bem. Vemos que ele define uma função, <code>fmap</code>, e não
fornece nenhuma implementação padrão para ela. O tipo de
<code>fmap</code> é interessante. Nas definições de typeclasses até
agora, a variável de tipo que desempenhou o papel do tipo na typeclass
era um tipo concreto, como o <code>a</code> em
<code>(==) :: (Eq a) =&gt; a -&gt; a -&gt; Bool</code>. Mas agora, o
<code>f</code> não é um tipo concreto (um tipo que um valor pode conter,
como <code>Int</code>, <code>Bool</code> ou <code>Maybe String</code>),
mas um construtor de tipos que leva um parâmetro de tipo. Um exemplo
rápido de atualização: <code>Maybe Int</code> é um tipo concreto, mas
<code>Maybe</code> é um construtor de tipos que usa um tipo como
parâmetro. De qualquer forma, vemos que <code>fmap</code> assume uma
função de um tipo para outro e um functor aplicado com um tipo e retorna
um functor aplicado com outro tipo.</p>
<p>Se isso parecer um pouco confuso, não se preocupe. Tudo será revelado
em breve quando verificarmos alguns exemplos. Hmm, essa declaração de
tipo para <code>fmap</code> me lembra algo. Se você não sabe qual é a
assinatura de tipo de <code>map</code>, é:
<code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code>.</p>
<p>Ah, interessante! É preciso uma função de um tipo para outro e uma
lista de um tipo e retorna uma lista de outro tipo. Meus amigos, acho
que temos um functor! De fato, <code>map</code> é apenas um
<code>fmap</code> que funciona apenas em listas. Veja como a lista é uma
instância da typeclass <code>Functor</code>.</p>
<p><code>{.haskell:hs} instance Functor [] where     fmap = map</code></p>
<p>É isso! Observe como não escrevemos
<code>instance Functor [a] where</code>, porque a partir de
<code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>, vemos que o
<code>f</code> deve ser um construtor de tipos que leva um tipo.
<code>[a]</code> já é um tipo concreto (de uma lista com qualquer tipo
dentro dela), enquanto <code>[]</code> é um construtor de tipos que leva
um tipo e pode produzir tipos como <code>[Int]</code>,
<code>[String]</code> ou até <code>[[String]]</code>.</p>
<p>Como para as listas, <code>fmap</code> é apenas <code>map</code>,
obtemos os mesmos resultados ao usá-los nas listas.</p>
<p><code>{.haskell:hs} map :: (a -&gt; b) -&gt; [a] -&gt; [b] ghci&gt; fmap (*2) [1..3] [2,4,6] ghci&gt; map (*2) [1..3] [2,4,6]</code></p>
<p>O que acontece quando fazemos <code>map</code> ou <code>fmap</code>
sobre uma lista vazia? Bem, é claro, recebemos uma lista vazia. Apenas
transforma uma lista vazia do tipo <code>[a]</code> em uma lista vazia
do tipo <code>[b]</code>.</p>
<p>Tipos que podem agir como uma caixa podem ser functors. Você pode
pensar em uma lista como uma caixa que tem uma quantidade infinita de
pequenos compartimentos e todos eles podem estar vazios, um pode estar
cheio e os outros vazios ou vários deles podem estar cheios. Então, o
que mais tem as propriedades de ser como uma caixa? Por um lado, o tipo
<code>Maybe a</code>. De certa forma, é como uma caixa que pode conter
nada, em cujo caso tem o valor de <code>Nothing</code>, ou pode conter
um item, como <code>"HAHA"</code>, caso em que ele tem um valor de
<code>Just "HAHA"</code>. Veja como <code>Maybe</code> é um functor.</p>
<p><code>{.haskell:hs} instance Functor Maybe where     fmap f (Just x) = Just (f x)     fmap f Nothing = Nothing</code></p>
<p>Mais uma vez, observe como escrevemos
<code>instance Functor Maybe where</code> em vez de
<code>instance Functor (Maybe m) where</code>, como fizemos quando
estávamos lidando com <code>Maybe</code> e <code>YesNo</code>.
<code>Functor</code> quer um construtor de tipos que leve um tipo e não
um tipo concreto. Se você substituir mentalmente os <code>f</code>s por
<code>Maybe</code>s, <code>fmap</code> age como um
<code>(a -&gt; b) -&gt; Maybe a -&gt; Maybe b</code> para esse tipo
específico, o que parece OK. Mas se você substituir <code>f</code> por
<code>(Maybe m)</code>, pareceria agir como um
<code>(a -&gt; b) -&gt; Maybe m a -&gt; Maybe m b</code>, o que não faz
nenhum sentido, porque <code>Maybe</code> leva apenas um parâmetro de
tipo.</p>
<p>De qualquer forma, a implementação do <code>fmap</code> é bastante
simples.</p>
<p>Se for um valor vazio de <code>Nothing</code>, basta retornar um
<code>Nothing</code>. Se mapearmos sobre uma caixa vazia, receberemos
uma caixa vazia. Faz sentido. Assim como se mapearmos sobre uma lista
vazia, recebemos uma lista vazia. Se não é um valor vazio, mas um único
valor acumulado em um <code>Just</code>, aplicamos a função no conteúdo
do <code>Just</code>.</p>
<p><code>{.haskell:hs} ghci&gt; fmap (++ " HEY GUYS IM INSIDE THE JUST") (Just "Something serious.") Just "Something serious. HEY GUYS IM INSIDE THE JUST" ghci&gt; fmap (++ " HEY GUYS IM INSIDE THE JUST") Nothing Nothing ghci&gt; fmap (*2) (Just 200) Just 400 ghci&gt; fmap (*2) Nothing Nothing</code></p>
<p>Outra coisa que pode ser mapeada e feita uma instância de
<code>Functor</code> é o nosso tipo <code>Tree a</code>. Pode ser
pensado como uma caixa (contém vários ou nenhum valor) e o construtor de
tipos <code>Tree</code> recebe exatamente um parâmetro de tipo. Se você
observar <code>fmap</code> como se fosse uma função criada apenas para
<code>Tree</code>, sua assinatura de tipo seria
<code>(a -&gt; b) -&gt; Tree a -&gt; Tree b</code>. Vamos usar a
recursão neste. O mapeamento sobre uma árvore vazia produzirá uma árvore
vazia. O mapeamento sobre uma árvore não vazia será uma árvore que
consiste em nossa função aplicada ao valor da raiz e suas subárvores
esquerda e direita serão as subárvores anteriores, apenas nossa função
será mapeada sobre elas.</p>
<p><code>{.haskell:hs} instance Functor Tree where     fmap f EmptyTree = EmptyTree     fmap f (Node x leftsub rightsub) = Node (f x) (fmap f leftsub) (fmap f rightsub)</code></p>
<p><code>{.haskell:hs} ghci&gt; fmap (*2) EmptyTree EmptyTree ghci&gt; fmap (*4) (foldr treeInsert EmptyTree [5,7,3,2,1,7]) Node 28 (Node 4 EmptyTree (Node 8 EmptyTree (Node 12 EmptyTree (Node 20 EmptyTree EmptyTree)))) EmptyTree</code></p>
<p>Legal! Agora, e o <code>Either a b</code>? Isso pode ser feito um
functor? A typeclass <code>Functor</code> deseja um construtor de tipos
que leve apenas um parâmetro de tipo, mas <code>Either</code> leva dois.
Hmmm! Eu sei, aplicaremos parcialmente o <code>Either</code>,
alimentando apenas um parâmetro, para que ele tenha um parâmetro livre.
Veja como <code>Either a</code> é um functor nas bibliotecas padrão:</p>
<p><code>{.haskell:hs} instance Functor (Either a) where     fmap f (Right x) = Right (f x)     fmap f (Left x) = Left x</code></p>
<p>Bem, o que fizemos aqui? Você pode ver como fizemos
<code>Either a</code> uma instância em vez de apenas
<code>Either</code>. Isso ocorre porque <code>Either a</code> é um
construtor de tipos que leva um parâmetro, enquanto <code>Either</code>
leva dois. Se <code>fmap</code> fosse especificamente para
<code>Either a</code>, a assinatura do tipo seria
<code>(b -&gt; c) -&gt; Either a b -&gt; Either a c</code> porque é o
mesmo que
<code>(b -&gt; c) -&gt; (Either a) b -&gt; (Either a) c</code>. Na
implementação, mapeamos no caso de um construtor de valor
<code>Right</code>, mas não no caso de um <code>Left</code>. Por que é
que? Bem, se olharmos para trás como o tipo <code>Either a b</code> é
definido, é como:</p>
<p><code>{.haskell:hs} data Either a b = Left a | Right b</code></p>
<p>Bem, se quiséssemos mapear uma função sobre os dois, <code>a</code> e
<code>b</code> teriam que ser do mesmo tipo. Quero dizer, se tentássemos
mapear uma função que pega uma string e retorna uma string e o
<code>b</code> fosse uma string, mas o <code>a</code> fosse um número,
isso realmente não funcionaria. Além disso, ao ver o que o tipo
<code>fmap</code> seria se operasse apenas nos valores
<code>Either</code>, vemos que o primeiro parâmetro deve permanecer o
mesmo, enquanto o segundo pode mudar e o primeiro parâmetro é atualizado
pelo construtor de valor <code>Left</code>.</p>
<p>Isso também acompanha bem nossa analogia de caixa se pensarmos na
parte <code>Left</code> como uma espécie de caixa vazia com uma mensagem
de erro escrita ao lado, dizendo-nos por que está vazia.</p>
<p>Os mapas de <code>Data.Map</code> também podem ser feitos um functor
porque possuem valores (ou não!). No caso de <code>Map k v</code>,
<code>fmap</code> mapeará uma função <code>v -&gt; v'</code> sobre um
mapa do tipo <code>Map k v</code> e retornará um mapa do tipo
<code>Map k v'</code>.</p>
<p>::: {.hintbox} Observe que o <code>'</code> não tem um significado
especial em tipos, assim como não tem significado especial ao nomear
valores. É usado para denotar coisas semelhantes, apenas ligeiramente
alteradas. :::</p>
<p>Tente descobrir como <code>Map k</code> é feito uma instância de
<code>Functor</code> por si mesmo!</p>
<p>Com a typeclass <code>Functor</code>, vimos como as typeclasses podem
representar conceitos de ordem superior muito legais. Também tivemos um
pouco mais de prática aplicando parcialmente tipos e fazendo instâncias.
Em um dos próximos capítulos, também daremos uma olhada em algumas leis
que se aplicam aos functors.</p>
<p>::: {.hintbox} <strong>Apenas mais uma coisa!</strong> Functors devem
obedecer a algumas leis para que possam ter algumas propriedades das
quais possamos depender e não pensar muito. Se usarmos
<code>fmap (+1)</code> sobre a lista <code>[1,2,3,4]</code>, esperamos
que o resultado seja <code>[2,3,4,5]</code> e não o inverso,
<code>[5,4,3,2]</code>. Se usarmos <code>fmap (\a -&gt; a)</code> (a
função identidade, que apenas retorna seu parâmetro) em alguma lista,
esperamos recuperar a mesma lista como resultado. Por exemplo, se dermos
a instância incorreta do functor aos nosso tipo <code>Tree</code>,
usando <code>fmap</code> sobre uma árvore onde a subárvore esquerda de
um nó possui apenas elementos menores que o nó e a subárvore direita
possui apenas nós que são maiores que o nó pode produzir uma árvore onde
esse não é o caso. Vamos repassar as leis de functor com mais detalhes
em um dos próximos capítulos. :::</p>
<h2>Kinds e um pouco de type-foo (Kinds and some type-foo)
{#kinds-and-some-type-foo}</h2>
<p><img
src="assets/images/making-our-own-types-and-typeclasses/typefoo.png"
alt="TYPE FOO MASTER" />{.right width=287 height=400}</p>
<p>Construtores de tipos usam outros tipos como parâmetros para,
eventualmente, produzir tipos concretos. Isso me lembra as funções, que
tomam valores como parâmetros para produzir valores. Vimos que os
construtores de tipos podem ser parcialmente aplicados
(<code>Either String</code> é um tipo que leva um tipo e produz um tipo
concreto, como <code>Either String Int</code>), assim como as funções
podem ser. Isso tudo é muito interessante, de fato. Nesta seção,
examinaremos a definição formal de como os tipos são aplicados aos
construtores de tipos, assim como analisamos a definição formal de como
os valores são aplicados às funções usando declarações de tipo.
<strong>Você realmente não precisa ler esta seção para continuar em sua
busca mágica de Haskell</strong> e se você não entende, não se preocupe
com isso. No entanto, entender isso lhe dará uma compreensão muito
completa do sistema de tipos.</p>
<p>Portanto, valores como <code>3</code>, <code>"YEAH"</code> ou
<code>takeWhile</code> (funções também são valores, porque podemos
passá-las e tal) cada um tem seu próprio tipo. Os tipos são pequenos
rótulos que os valores carregam para que possamos raciocinar sobre os
valores. Mas os tipos têm seus próprios pequenos rótulos, chamados
<strong>kinds</strong>. Um kind é mais ou menos o tipo de um tipo. Isso
pode parecer um pouco estranho e confuso, mas na verdade é um conceito
muito legal.</p>
<p>O que são kinds e para que servem? Bem, vamos examinar o tipo de um
tipo usando o comando <code>:k</code> no GHCI.</p>
<p><code>{.haskell:hs} ghci&gt; :k Int Int :: *</code></p>
<p>Uma estrela? Que pitoresco. O que isso significa? Um <code>*</code>
significa que o tipo é um tipo concreto. Um tipo concreto é um tipo que
não aceita parâmetros de tipo e os valores só podem ter tipos que são
tipos concretos. Se eu tivesse que ler <code>*</code> em voz alta (não
tive que fazer isso até agora), eu diria <em>star</em> ou apenas
<em>type</em>.</p>
<p>Ok, agora vamos ver qual é o kind de <code>Maybe</code>.</p>
<p><code>{.haskell:hs} ghci&gt; :k Maybe Maybe :: * -&gt; *</code></p>
<p>O construtor de tipos <code>Maybe</code> usa um tipo concreto (como
<code>Int</code>) e depois retorna um tipo concreto como
<code>Maybe Int</code>. E é isso que esse kind nos diz. Assim como
<code>Int -&gt; Int</code> significa que uma função pega um
<code>Int</code> e retorna um <code>Int</code>, <code>* -&gt; *</code>
significa que o construtor de tipos pega um tipo concreto e retorna um
tipo concreto. Vamos aplicar o parâmetro de tipo para <code>Maybe</code>
e ver qual é o kind desse tipo.</p>
<p><code>{.haskell:hs} ghci&gt; :k Maybe Int Maybe Int :: *</code></p>
<p>Assim como eu esperava! Aplicamos o parâmetro de tipo em
<code>Maybe</code> e recebemos um tipo concreto (é isso que
<code>* -&gt; *</code> significa). Um paralelo (embora não equivalente,
tipos e tipos são duas coisas diferentes) para isso é se fizermos
<code>:t isUpper</code> e <code>:t isUpper 'A'</code>.
<code>isUpper</code> tem um tipo de <code>Char -&gt; Bool</code> e
<code>isUpper 'A'</code> tem um tipo de <code>Bool</code>, porque seu
valor é basicamente <code>True</code>. Ambos os tipos, no entanto, têm
um kind de <code>*</code>.</p>
<p>Usamos <code>:k</code> em um tipo para obter seu kind, assim como
podemos usar <code>:t</code> em um valor para obter seu tipo. Como
dissemos, os tipos são os rótulos de valores e kinds são os rótulos de
tipos e existem paralelos entre os dois.</p>
<p>Vamos ver outro kind.</p>
<p><code>{.haskell:hs} ghci&gt; :k Either Either :: * -&gt; * -&gt; *</code></p>
<p>Aha, isso nos diz que <code>Either</code> requer dois tipos concretos
como parâmetros de tipo para produzir um tipo concreto. Também se parece
com uma declaração de tipo de uma função que assume dois valores e
retorna algo. Os construtores de tipos são curried (assim como as
funções), para que possamos aplicá-los parcialmente.</p>
<p><code>{.haskell:hs} ghci&gt; :k Either String Either String :: * -&gt; * ghci&gt; :k Either String Int Either String Int :: *</code></p>
<p>Quando queríamos fazer de <code>Either</code> uma parte da typeclass
<code>Functor</code>, tivemos que aplicá-lo parcialmente, porque
<code>Functor</code> quer tipos que aceitem apenas um parâmetro enquanto
<code>Either</code> aceita dois. Em outras palavras,
<code>Functor</code> quer tipos de kind <code>* -&gt; *</code> e,
portanto, tivemos que aplicar parcialmente o <code>Either</code> para
obter um tipo de kind <code>* -&gt; *</code> em vez de seu kind original
<code>* -&gt; * -&gt; *</code>. Se olharmos para a definição de
<code>Functor</code> novamente</p>
<p><code>{.haskell:hs} class Functor f where     fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code></p>
<p>vemos que a variável de tipo <code>f</code> é usada como um tipo que
usa um tipo concreto para produzir um tipo concreto. Sabemos que ele
deve produzir um tipo concreto porque é usado como o tipo de valor em
uma função. E a partir disso, podemos deduzir que os tipos que querem
ser amigos de <code>Functor</code> devem ser do tipo
<code>* -&gt; *</code>.</p>
<p>Agora, vamos fazer um pouco de type-foo. Dê uma olhada nesta
typeclass que vou inventar agora:</p>
<p><code>{.haskell:hs} class Tofu t where     tofu :: j a -&gt; t a j</code></p>
<p>Cara, isso parece estranho. Como faríamos um tipo que poderia ser uma
instância dessa estranha typeclass? Bem, vamos ver o que teria que ser
seu kind. Como <code>j a</code> é usado como o tipo de valor que a
função <code>tofu</code> assume como parâmetro, <code>j a</code> deve
ter um kind de <code>*</code>. Assumimos <code>*</code> para
<code>a</code> e, portanto, podemos inferir que <code>j</code> deve ter
um kind de <code>* -&gt; *</code>. Vemos que <code>t</code> também deve
produzir um valor concreto e que são necessários dois tipos. E sabendo
que <code>a</code> tem um kind de <code>*</code> e <code>j</code> tem um
kind de <code>* -&gt; *</code>, inferimos que <code>t</code> deve ter um
kind de <code>* -&gt; (* -&gt; *) -&gt; *</code>. Portanto, é necessário
um tipo concreto (<code>a</code>), um construtor de tipos que recebe um
tipo concreto (<code>j</code>) e produz um tipo concreto. Uau.</p>
<p>OK, então vamos criar um tipo com um kind de
<code>* -&gt; (* -&gt; *) -&gt; *</code>. Aqui está uma maneira de fazer
isso.</p>
<p><code>{.haskell:hs} data Frank a b  = Frank {frankField :: b a} deriving (Show)</code></p>
<p>Como sabemos que esse tipo tem um kind de
<code>* -&gt; (* -&gt; *) -&gt; *</code>? Bem, os campos nos ADTs são
feitos para manter valores, por isso devem ser do kind <code>*</code>,
obviamente. Assumimos <code>*</code> para <code>a</code>, o que
significa que <code>b</code> usa um parâmetro de tipo e, portanto, seu
kind é <code>* -&gt; *</code>. Agora conhecemos os kinds de
<code>a</code> e <code>b</code> e, porque são parâmetros para
<code>Frank</code>, vemos que <code>Frank</code> tem um kind de
<code>* -&gt; (* -&gt; *) -&gt; *</code>. O primeiro <code>*</code>
representa <code>a</code> e o <code>(* -&gt; *)</code> representa
<code>b</code>. Vamos criar alguns valores <code>Frank</code> e
verificar seus tipos.</p>
<p><code>{.haskell:hs} ghci&gt; :t Frank {frankField = Just "HAHA"} Frank {frankField = Just "HAHA"} :: Frank [Char] Maybe ghci&gt; :t Frank {frankField = Node 'a' EmptyTree EmptyTree} Frank {frankField = Node 'a' EmptyTree EmptyTree} :: Frank Char Tree ghci&gt; :t Frank {frankField = "YES"} Frank {frankField = "YES"} :: Frank Char []</code></p>
<p>Hmm. Como <code>frankField</code> tem um tipo de formulário
<code>a b</code>, seus valores devem ter tipos de uma forma semelhante
também. Portanto, eles podem ser <code>Just "HAHA"</code>, que tem um
tipo de <code>Maybe [Char]</code> ou pode ter um valor de
<code>['Y','E','S']</code>, que tem um tipo de <code>[Char]</code> (se
usássemos nosso próprio tipo de lista para isso, ele teria um tipo de
<code>List Char</code>). E vemos que os tipos dos valores
<code>Frank</code> correspondem ao kind para <code>Frank</code>.
<code>[Char]</code> tem um kind de <code>*</code> e <code>Maybe</code>
tem um kind de <code>* -&gt; *</code>. Porque, para ter um valor, ele
deve ser um tipo concreto e, portanto, deve ser totalmente aplicado,
todo valor de <code>Frank blah blaah</code> tem um kind de
<code>*</code>.</p>
<p>Tornar <code>Frank</code> uma instância de <code>Tofu</code> é
bastante simples. Vemos que <code>tofu</code> recebe um <code>j a</code>
(portanto, um tipo de exemplo desse formulário seria
<code>Maybe Int</code>) e retorna um <code>t a j</code>. Portanto, se
substituirmos <code>Frank</code> por <code>j</code>, o tipo de resultado
seria <code>Frank Int Maybe</code>.</p>
<p><code>{.haskell:hs} instance Tofu Frank where     tofu x = Frank x</code></p>
<p><code>{.haskell:hs} ghci&gt; tofu (Just 'a') :: Frank Char Maybe Frank {frankField = Just 'a'} ghci&gt; tofu ["HELLO"] :: Frank [Char] [] Frank {frankField = ["HELLO"]}</code></p>
<p>Não é muito útil, mas flexionamos nossos músculos de tipo. Vamos
fazer mais type-foo. Temos este tipo de dados:</p>
<p><code>{.haskell:hs} data Barry t k p = Barry { yabba :: p, dabba :: t k }</code></p>
<p>E agora queremos torná-lo uma instância de <code>Functor</code>.
<code>Functor</code> quer tipos de kind <code>* -&gt; *</code> mas
<code>Barry</code> não parece ter esse kind. Qual é o kind de
<code>Barry</code>? Bem, vemos que são necessários três parâmetros de
tipo, então será
<code>something -&gt; something -&gt; something -&gt; *</code>. É seguro
dizer que <code>p</code> é um tipo concreto e, portanto, tem um kind de
<code>*</code>. Para <code>k</code>, assumimos <code>*</code> e, por
extensão, <code>t</code> tem um kind de <code>* -&gt; *</code>. Agora
vamos substituir esses kinds pelos <em>somethings</em> que usamos como
espaços reservados e vemos que ele tem um kind de
<code>(* -&gt; *) -&gt; * -&gt; * -&gt; *</code>. Vamos verificar isso
com o GHCI.</p>
<p><code>{.haskell:hs} ghci&gt; :k Barry Barry :: (* -&gt; *) -&gt; * -&gt; * -&gt; *</code></p>
<p>Ah, nós estávamos certos. Que satisfatório. Agora, para tornar esse
tipo uma parte de <code>Functor</code>, temos que aplicar parcialmente
os dois primeiros parâmetros de tipo para ficarmos com
<code>* -&gt; *</code>. Isso significa que o início da declaração da
instância será: <code>instance Functor (Barry a b) where</code>. Se
olharmos para <code>fmap</code> como se fosse feito especificamente para
<code>Barry</code>, ele teria um tipo de
<code>fmap :: (a -&gt; b) -&gt; Barry c d a -&gt; Barry c d b</code>,
porque apenas substituímos o <code>f</code> do <code>Functor</code> por
<code>Barry c d</code>. O terceiro parâmetro de tipo de
<code>Barry</code> terá que mudar e vemos que está convenientemente em
seu próprio campo.</p>
<p><code>{.haskell:hs} instance Functor (Barry a b) where     fmap f (Barry {yabba = x, dabba = y}) = Barry {yabba = f x, dabba = y}</code></p>
<p>Aí vamos nós! Acabamos de mapear o <code>f</code> sobre o primeiro
campo.</p>
<p>Nesta seção, examinamos bem como os parâmetros de tipo funcionam e os
formalizamos com kinds, assim como formalizamos os parâmetros de função
com declarações de tipo. Vimos que existem paralelos interessantes entre
funções e construtores de tipos. Eles são, no entanto, duas coisas
completamente diferentes. Ao trabalhar em Haskell real, geralmente você
não precisará mexer com kinds e fazer inferência de kind manualmente
como fizemos agora. Geralmente, você apenas precisa aplicar parcialmente
seu próprio tipo a <code>* -&gt; *</code> ou <code>*</code> ao torná-lo
uma instância de uma das typeclasses padrão, mas é bom saber como e por
que isso realmente funciona. Também é interessante ver que os tipos têm
pequenos tipos próprios. Mais uma vez, você realmente não precisa
entender tudo o que fizemos aqui para ler, mas se você entender como os
kinds funcionam, provavelmente terá uma compreensão muito sólida do
sistema de tipos de Haskell.</p>
            </article>
<div class="footdiv">
    <ul>
<li class="prev"><a href="modules.html">Anterior</a></li>
        <li class="toc"><a href="index.html">Sumário</a></li>
<li class="next"><a href="input-and-output.html">Próximo</a></li>
    </ul>
</div>

        </div>
    </div>
    <script type="text/javascript" src="sh/Scripts/shCore.js"></script>
    <script type="text/javascript" src="sh/Scripts/shBrushHaskell.js"></script>
    <script type="text/javascript" src="sh/Scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="assets/js/toggleShow.js"></script>
    <script type="text/javascript">
        dp.SyntaxHighlighter.HighlightAll('code');
    </script>
</body>
</html>
