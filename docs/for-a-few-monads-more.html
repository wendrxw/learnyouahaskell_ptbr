<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aprenda Haskell para o Bem de Todos!</title>
    <link rel="stylesheet" href="assets/css/reset.css" type="text/css" />
    <link rel="stylesheet" href="assets/css/style.css" type="text/css" />
    <link rel="stylesheet" href="sh/Styles/SyntaxHighlighter.css" type="text/css" />
    <link rel="shortcut icon" href="assets/images/favicon.png" type="image/png" />
</head>
<body>
    <div class="bgwrapper">
        <div id="content">
<div class="footdiv">
    <ul>
<li class="prev"><a href="a-fistful-of-monads.html">Anterior</a></li>
        <li class="toc"><a href="index.html">Sumário</a></li>
<li class="next"><a href="zippers.html">Próximo</a></li>
    </ul>
</div>

            <article>
<h1>Por Mais Algumas Monads</h1>
<p><img src="assets/images/for-a-few-monads-more/clint.png"
alt="existem dois tipos de pessoas no mundo, meu amigo. aquelas que aprendem haskell e aquelas que têm o trabalho de programar em java" />{.right
width=189 height=400}</p>
<p>Vimos como as Monads podem ser usadas para pegar valores com
contextos e aplicá-los a funções, e como o uso de <code>&gt;&gt;=</code>
ou da <code>do notation</code> nos permite focar nos próprios valores
enquanto o contexto é tratado para nós.</p>
<p>Conhecemos a Maybe Monad e vimos como ela adiciona um contexto de
possível falha aos valores. Aprendemos sobre a List Monad e vimos como
ela nos permite introduzir facilmente o não-determinismo em nossos
programas. Também aprendemos como trabalhar na IO Monad, antes mesmo de
sabermos o que era uma Monad!</p>
<p>Neste capítulo, aprenderemos sobre algumas outras Monads. Veremos
como elas podem tornar nossos programas mais claros, permitindo-nos
tratar todos os tipos de valores como monadic values. Explorar mais
algumas Monads também solidificará nossa intuição sobre elas.</p>
<p>As Monads que exploraremos fazem parte do pacote <code>mtl</code>. Um
pacote Haskell é uma coleção de módulos. O pacote <code>mtl</code> vem
com a Haskell Platform, então você provavelmente já o tem. Para
verificar se você o tem, digite <code>ghc-pkg list</code> na linha de
comando. Isso mostrará quais pacotes Haskell você tem instalados e um
deles deve ser <code>mtl</code>, seguido por um número de versão.</p>
<h2>Writer? Quase nem a conheço! {#writer}</h2>
<p>Carregamos nossa arma com a Maybe Monad, a List Monad e a IO Monad.
Agora vamos colocar a Writer Monad na câmara e ver o que acontece quando
disparamos!</p>
<p>Enquanto <code>Maybe</code> é para valores com um contexto adicionado
de falha e a lista é para valores não-determinísticos, a Writer Monad é
para valores que possuem outro valor anexado que atua como uma espécie
de valor de log (registro). O <code>Writer</code> nos permite fazer
computações enquanto garante que todos os valores de log sejam
combinados em um único valor de log que é então anexado ao
resultado.</p>
<p>Por exemplo, podemos querer equipar nossos valores com strings que
expliquem o que está acontecendo, provavelmente para fins de depuração.
Considere uma função que recebe um número de bandidos em uma gangue e
nos diz se essa é uma gangue grande ou não. Essa é uma função muito
simples:</p>
<p><code>{.haskell:hs} isBigGang :: Int -&gt; Bool isBigGang x = x &gt; 9</code></p>
<p>Agora, e se em vez de apenas nos dar um valor <code>True</code> ou
<code>False</code>, quisermos que ela também retorne uma string de log
dizendo o que fez? Bem, nós apenas criamos essa string e a retornamos
junto com o nosso <code>Bool</code>:</p>
<p><code>{.haskell:hs} isBigGang :: Int -&gt; (Bool, String) isBigGang x = (x &gt; 9, "Comparei o tamanho da gangue com 9.")</code></p>
<p>Então agora, em vez de apenas retornar um <code>Bool</code>,
retornamos uma tupla onde o primeiro componente da tupla é o valor real
e o segundo componente é a string que acompanha esse valor. Há algum
contexto adicionado ao nosso valor agora. Vamos testar isso:</p>
<p><code>{.haskell:hs} ghci&gt; isBigGang 3 (False,"Comparei o tamanho da gangue com 9.") ghci&gt; isBigGang 30 (True,"Comparei o tamanho da gangue com 9.")</code></p>
<p><img src="assets/images/for-a-few-monads-more/tuco.png"
alt="quando tiver que fazer cocô, faça, não fale" />{.left width=196
height=280}</p>
<p>Até aqui tudo bem. <code>isBigGang</code> recebe um valor normal e
retorna um valor com um contexto. Como acabamos de ver, alimentá-la com
um valor normal não é um problema. Agora, e se já tivermos um valor que
tenha uma string de log anexada a ele, como
<code>(3, "Gangue pequena.")</code>, e quisermos alimentá-lo para
<code>isBigGang</code>? Parece que, mais uma vez, nos deparamos com esta
questão: se temos uma função que recebe um valor normal e retorna um
valor com um contexto, como pegamos um valor com um contexto e o
alimentamos para a função?</p>
<p>Quando estávamos explorando a Maybe Monad, criamos uma função
<code>applyMaybe</code>, que recebia um valor <code>Maybe a</code> e uma
função do tipo <code>a -&gt; Maybe b</code> e alimentava esse valor
<code>Maybe a</code> na função, embora a função receba um <code>a</code>
normal em vez de um <code>Maybe a</code>. Ela fazia isso cuidando do
contexto que vem com os valores <code>Maybe a</code>, que é o fato de
serem valores com falha possível. Mas dentro da função
<code>a -&gt; Maybe b</code>, fomos capazes de tratar esse valor como
apenas um valor normal, porque <code>applyMaybe</code> (que mais tarde
se tornou <code>&gt;&gt;=</code>) cuidou de verificar se era um valor
<code>Nothing</code> or <code>Just</code>.</p>
<p>Na mesma linha, vamos criar uma função que receba um valor com um log
anexado, ou seja, um valor <code>(a, String)</code> e uma função do tipo
<code>a -&gt; (b, String)</code> e alimente esse valor na função.
Chamaremos de <code>applyLog</code>. Mas como um valor
<code>(a, String)</code> não carrega consigo um contexto de falha
possível, mas sim um contexto de um valor de log adicional,
<code>applyLog</code> vai garantir que o log do valor original não seja
perdido, mas sim unido ao log do valor que resulta da função. Aqui está
a implementação de <code>applyLog</code>:</p>
<p><code>{.haskell:hs} applyLog :: (a,String) -&gt; (a -&gt; (b,String)) -&gt; (b,String) applyLog (x,log) f = let (y,newLog) = f x in (y,log ++ newLog)</code></p>
<p>Quando temos um valor com um contexto e queremos alimentá-lo para uma
função, geralmente tentamos separar o valor real do contexto e então
tentamos aplicar a função ao valor para depois ver se o contexto é
cuidado. Na mônada <code>Maybe</code>, verificamos se o valor era um
<code>Just x</code> e, se fosse, pegávamos esse <code>x</code> e
aplicávamos a função a ele. Neste caso, é muito fácil encontrar o valor
real, porque estamos lidando com um par onde um componente é o valor e o
outro um log. Então, primeiro pegamos apenas o valor, que é
<code>x</code>, e aplicamos a função <code>f</code> a ele. Obtemos um
par de <code>(y, newLog)</code>, onde <code>y</code> é o novo resultado
e <code>newLog</code> o novo log. Mas se retornássemos isso como
resultado, o valor do log antigo não seria incluído no resultado, então
retornamos um par de <code>(y, log ++ newLog)</code>. Usamos
<code>++</code> para anexar o novo log ao antigo.</p>
<p>Aqui está o <code>applyLog</code> em ação:</p>
<p><code>{.haskell:hs} ghci&gt; (3, "Gangue pequena.") `applyLog` isBigGang (False,"Gangue pequena.Comparei o tamanho da gangue com 9.") ghci&gt; (30, "Um pelotão assustador.") `applyLog` isBigGang (True,"Um pelotão assustador.Comparei o tamanho da gangue com 9.")</code></p>
<p>Os resultados são semelhantes aos de antes, só que agora o número de
pessoas na gangue tinha seu log acompanhante e ele foi incluído no log
de resultado. Aqui estão mais alguns exemplos de uso do
<code>applyLog</code>:</p>
<p><code>{.haskell:hs} ghci&gt; ("Tobin","Recebeu nome de fora da lei.") `applyLog` (\x -&gt; (length x, "Aplicou length.")) (5,"Recebeu nome de fora da lei.Aplicou length.") ghci&gt; ("Bathcat","Recebeu nome de fora da lei.") `applyLog` (\x -&gt; (length x, "Aplicou length")) (7,"Recebeu nome de fora da lei.Aplicou length")</code></p>
<p>Veja como dentro do lambda, <code>x</code> é apenas uma string normal
e não uma tupla, e como o <code>applyLog</code> cuida de anexar os
logs.</p>
<h3>Monoids ao resgate</h3>
<p>::: {.hintbox} Certifique-se de saber o que são <a
href="functors-applicative-functors-and-monoids.html#monoids">Monoids</a>
a esta altura! Saudações. :::</p>
<p>Até agora, <code>applyLog</code> recebe valores do tipo
<code>(a, String)</code>, mas existe alguma razão para o log ter que ser
uma <code>String</code>? Ele usa <code>++</code> para anexar os logs,
então isso não funcionaria para qualquer tipo de lista, e não apenas uma
lista de caracteres? Com certeza funcionaria. Podemos mudar o seu tipo
para isto:</p>
<p><code>{.haskell:hs} applyLog :: (a,[c]) -&gt; (a -&gt; (b,[c])) -&gt; (b,[c])</code></p>
<p>Agora, o log é uma lista. O tipo de valores contidos na lista tem que
ser o mesmo para a lista original, bem como para a lista que a função
retorna, caso contrário não seríamos capazes de usar <code>++</code>
para juntá-los.</p>
<p>Isso funcionaria para bytestrings? Não há razão para não funcionar.
No entanto, o tipo que temos agora funciona apenas para listas. Parece
que teríamos que fazer um <code>applyLog</code> separado para
bytestrings. Mas espere! Tanto listas quanto bytestrings são Monoids.
Como tal, ambos são instâncias da typeclass <code>Monoid</code>, o que
significa que implementam a função <code>mappend</code>. E tanto para
listas quanto para bytestrings, <code>mappend</code> serve para
concatenar. Veja:</p>
<p><code>{.haskell:hs} ghci&gt; [1,2,3] `mappend` [4,5,6] [1,2,3,4,5,6] ghci&gt; B.pack [99,104,105] `mappend` B.pack [104,117,97,104,117,97] Chunk "chi" (Chunk "huahua" Empty)</code></p>
<p>Legal! Agora nosso <code>applyLog</code> pode funcionar para qualquer
monóide. Temos que mudar o tipo para refletir isso, assim como a
implementação, porque temos que mudar <code>++</code> para
<code>mappend</code>:</p>
<p><code>{.haskell:hs} applyLog :: (Monoid m) =&gt; (a,m) -&gt; (a -&gt; (b,m)) -&gt; (b,m) applyLog (x,log) f = let (y,newLog) = f x in (y,log `mappend` newLog)</code></p>
<p>Como o valor acompanhante pode agora ser qualquer valor Monoid, não
precisamos mais pensar na tupla como um valor e um log, mas agora
podemos pensar nela como um valor com um valor Monoid acompanhante. Por
exemplo, podemos ter uma tupla que tenha um nome de item e um preço de
item como o valor Monoid. Apenas usamos o <code>newtype</code>
<code>Sum</code> para garantir que os preços sejam somados à medida que
operamos com os itens. Aqui está uma função que adiciona bebida a alguma
comida de cowboy:</p>
<p>```{.haskell:hs} import Data.Monoid</p>
<p>type Comida = String type Preco = Sum Int</p>
<p>addDrink :: Comida -&gt; (Comida,Preco) addDrink "feijao" = ("leite",
Sum 25) addDrink "carne-seca" = ("uisque", Sum 99) addDrink _ =
("cerveja", Sum 30) ```</p>
<p>Usamos strings para representar as comidas e um <code>Int</code> em
um wrapper <code>newtype</code> <code>Sum</code> para acompanhar quantos
centavos algo custa. Apenas um lembrete, fazer <code>mappend</code> com
<code>Sum</code> resulta na soma dos valores envolvidos:</p>
<p><code>{.haskell:hs} ghci&gt; Sum 3 `mappend` Sum 9 Sum {getSum = 12}</code></p>
<p>A função <code>addDrink</code> é bem simples. Se estivermos comendo
feijão, ela retorna <code>"leite"</code> junto com <code>Sum 25</code>,
ou seja, 25 centavos envolvidos em <code>Sum</code>. Se estivermos
comendo carne seca, bebemos uísque e se estivermos comendo qualquer
outra coisa, bebemos cerveja. Simplesmente aplicar esta função a uma
comida não seria terrivelmente interessante agora, mas usar
<code>applyLog</code> para alimentar uma comida que vem com um preço
próprio nesta função é interessante:</p>
<p><code>{.haskell:hs} ghci&gt; ("feijao", Sum 10) `applyLog` addDrink ("leite",Sum {getSum = 35}) ghci&gt; ("carne-seca", Sum 25) `applyLog` addDrink ("uisque",Sum {getSum = 124}) ghci&gt; ("carne-de-cachorro", Sum 5) `applyLog` addDrink ("cerveja",Sum {getSum = 35})</code></p>
<p>O leite custa 25 centavos, mas se o tomarmos com feijão que custa 10
centavos, acabaremos pagando 35 centavos. Agora está claro como o valor
anexado nem sempre tem que ser um log, pode ser qualquer valor Monoid e
como dois desses valores são combinados em um depende do Monoid. Quando
estávamos fazendo logs, eles eram concatenados, mas agora, os números
estão sendo somados.</p>
<p>Como o valor que <code>addDrink</code> retorna é uma tupla do tipo
<code>(Comida,Preco)</code>, podemos alimentar esse resultado para
<code>addDrink</code> novamente, para que ele nos diga o que devemos
beber junto com nossa bebida e quanto isso nos custará. Vamos
tentar:</p>
<p><code>{.haskell:hs} ghci&gt; ("carne-de-cachorro", Sum 5) `applyLog` addDrink `applyLog` addDrink ("cerveja",Sum {getSum = 65})</code></p>
<p>Adicionar uma bebida a alguma carne de cachorro resulta em uma
cerveja e 30 centavos adicionais, então
<code>("cerveja", Sum 35)</code>. E se usarmos <code>applyLog</code>
para alimentar isso para <code>addDrink</code>, pegamos outra cerveja e
o resultado é <code>("cerveja", Sum 65)</code>.</p>
<h3>O tipo Writer</h3>
<p>Agora que vimos que um valor com um Monoid anexado age como um
monadic value, vamos examinar a Monad instance para tipos de tais
valores. O módulo <code>Control.Monad.Writer</code> exporta o tipo
<code>Writer w a</code> junto com sua Monad instance e algumas funções
úteis para lidar com valores deste tipo.</p>
<p>Primeiro, vamos examinar o próprio tipo. Para anexar um monóide a um
valor, basta colocá-los juntos em uma tupla. O tipo
<code>Writer w a</code> é apenas um wrapper <code>newtype</code> para
isso. Sua definição é muito simples:</p>
<p><code>{.haskell:hs} newtype Writer w a = Writer { runWriter :: (a, w) }</code></p>
<p>Ele é envolvido em um <code>newtype</code> para que possa ser feito
uma instância de <code>Monad</code> e para que seu tipo seja separado de
uma tupla normal. O parâmetro de tipo <code>a</code> representa o tipo
do valor e o parâmetro de tipo <code>w</code> o tipo do valor Monoid
anexado.</p>
<p>Sua Monad instance é definida desta forma:</p>
<p><code>{.haskell:hs} instance (Monoid w) =&gt; Monad (Writer w) where     return x = Writer (x, mempty)     (Writer (x,v)) &gt;&gt;= f = let (Writer (y, v')) = f x in Writer (y, v `mappend` v')</code></p>
<p><img src="assets/images/for-a-few-monads-more/angeleyes.png"
alt="quando tiver que fazer cocô, faça, não fale" />{.right width=383
height=248}</p>
<p>Primeiro de tudo, vamos examinar o <code>&gt;&gt;=</code>. Sua
implementação é essencialmente a mesma que a do <code>applyLog</code>,
só que agora que nossa tupla está envolvida no <code>newtype</code>
<code>Writer</code>, temos que desempacotá-la ao fazer o pattern
matching. Pegamos o valor <code>x</code> e aplicamos a função
<code>f</code> a ele. Isso nos dá um valor <code>Writer w a</code> e
usamos uma expressão <code>let</code> para fazer o pattern matching
sobre ele. Apresentamos <code>y</code> como o novo resultado e usamos
<code>mappend</code> para combinar o valor Monoid antigo com o novo.
Empacotamos isso com o valor resultante em uma tupla e então envolvemos
com o construtor <code>Writer</code> para que nosso resultado seja um
valor <code>Writer</code> em vez de apenas uma tupla desempacotada.</p>
<p>Então, e quanto ao <code>return</code>? Ele tem que receber um valor
e colocá-lo em um contexto mínimo padrão que ainda apresente esse valor
como resultado. Então, qual seria esse contexto para os valores
<code>Writer</code>? Se quisermos que o valor Monoid acompanhante afete
outros valores Monoids o mínimo possível, faz sentido usar
<code>mempty</code>. <code>mempty</code> é usado para apresentar valores
de identidade Monoid, como <code>""</code>, <code>Sum 0</code> e
bytestrings vazias. Sempre que usamos <code>mappend</code> entre
<code>mempty</code> e algum outro valor Monoid, o resultado é esse outro
valor Monoid. Portanto, se usarmos <code>return</code> para criar um
valor <code>Writer</code> e usarmos <code>&gt;&gt;=</code> para
alimentar esse valor em uma função, o valor Monoid resultante será
apenas o que a função retornar. Vamos usar <code>return</code> no número
<code>3</code> algumas vezes, só que o associaremos a um Monoid
diferente a cada vez:</p>
<p><code>{.haskell:hs} ghci&gt; runWriter (return 3 :: Writer String Int) (3,"") ghci&gt; runWriter (return 3 :: Writer (Sum Int) Int) (3,Sum {getSum = 0}) ghci&gt; runWriter (return 3 :: Writer (Product Int) Int) (3,Product {getProduct = 1})</code></p>
<p>Como o <code>Writer</code> não possui uma instância
<code>Show</code>, tivemos que usar <code>runWriter</code> para
converter nossos valores <code>Writer</code> em tuplas normais que podem
ser exibidas. Para <code>String</code>, o valor Monoid é a string vazia.
Com <code>Sum</code>, é <code>0</code>, porque se somarmos 0 a algo,
esse algo permanece o mesmo. Para <code>Product</code>, a identidade é
<code>1</code>.</p>
<p>A Writer instance não apresenta uma implementação para
<code>fail</code>, por isso, se um pattern match falhar na
<code>do notation</code>, o <code>error</code> é chamado.</p>
<h3>Usando a do notation com o Writer</h3>
<p>Agora que temos uma Monad instance, estamos livres para usar a
<code>do notation</code> para valores <code>Writer</code>. É útil para
quando temos vários valores <code>Writer</code> e queremos fazer coisas
com eles. Assim como com outras Monads, podemos tratá-los como valores
normais e o contexto será cuidado para nós. Neste caso, todos os valores
Monoids que vêm anexados são combinados com <code>mappend</code> e,
portanto, são refletidos no resultado final. Aqui está um exemplo
simples de uso da <code>do notation</code> com <code>Writer</code> para
multiplicar dois números:</p>
<p>```{.haskell:hs} import Control.Monad.Writer</p>
<p>logNumber :: Int -&gt; Writer [String] Int logNumber x = Writer (x,
["Peguei o numero: " ++ show x])</p>
<p>multWithLog :: Writer [String] Int multWithLog = do a &lt;- logNumber
3 b &lt;- logNumber 5 return (a*b) ```</p>
<p><code>logNumber</code> recebe um número e cria um valor
<code>Writer</code> a partir dele. Para o Monoid, usamos uma lista de
strings e equipamos o número com uma lista unitária que apenas diz que
temos esse número. <code>multWithLog</code> é um valor
<code>Writer</code> que multiplica <code>3</code> e <code>5</code> e
garante que seus logs anexados sejam incluídos no log final. Usamos
<code>return</code> para apresentar <code>a*b</code> como resultado.
Como o <code>return</code> apenas recebe algo e o coloca em um contexto
mínimo, podemos ter certeza de que ele não adicionará nada ao log. Aqui
está o que vemos se executarmos isso:</p>
<p><code>{.haskell:hs} ghci&gt; runWriter multWithLog (15,["Peguei o numero: 3","Peguei o numero: 5"])</code></p>
<p>Às vezes, queremos apenas que algum valor Monoid seja incluído em
algum ponto específico. Para isso, a função <code>tell</code> é útil.
Ela faz parte da typeclass <code>MonadWriter</code> e, no caso do
<code>Writer</code>, ela recebe um valor Monoid, como
<code>["Isso esta acontecendo"]</code>, e cria um valor
<code>Writer</code> que apresenta o valor fictício <code>()</code> como
seu resultado, mas tem o valor Monoid desejado anexado. Quando temos um
valor monádico que tem <code>()</code> como resultado, não o vinculamos
a uma variável. Aqui está o <code>multWithLog</code> mas com algum
relatório extra incluído:</p>
<p><code>{.haskell:hs} multWithLog :: Writer [String] Int multWithLog = do     a &lt;- logNumber 3     b &lt;- logNumber 5     tell ["Vou multiplicar esses dois"]     return (a*b)</code></p>
<p>É importante que <code>return (a*b)</code> seja a última linha,
porque o resultado da última linha de uma expressão <code>do</code> é o
resultado de toda a expressão <code>do</code>. Se tivéssemos colocado o
<code>tell</code> como a última linha, <code>()</code> teria sido o
resultado desta expressão <code>do</code>. Perderíamos o resultado da
multiplicação. No entanto, o log seria o mesmo. Aqui está isso em
ação:</p>
<p>```{.haskell:hs} ghci&gt; runWriter multWithLog (15,["Peguei o
numero: 3","Peguei o numero: 5","Vou multiplicar esses dois"])</p>
<h3>Adicionando registros aos programas</h3>
<p>O algoritmo de Euclides é um algoritmo que recebe dois números e
calcula o seu máximo divisor comum. Ou seja, o maior número que ainda
divide ambos de forma inteira. O Haskell já possui a função
<code>gcd</code>, que faz exatamente isso, mas vamos implementar a nossa
própria e então equipá-la com capacidades de log. Aqui está o algoritmo
normal:</p>
<p><code>{.haskell:hs} gcd' :: Int -&gt; Int -&gt; Int gcd' a b     | b == 0    = a     | otherwise = gcd' b (a `mod` b)</code></p>
<p>O algoritmo é muito simples. Primeiro, ele verifica se o segundo
número é 0. Se for, o resultado é o primeiro número. Se não for, o
resultado é o máximo divisor comum do segundo número e do resto da
divisão do primeiro número pelo segundo. Por exemplo, se quisermos saber
qual é o máximo divisor comum de 8 e 3, basta seguir o algoritmo
descrito. Como 3 não é 0, temos que encontrar o máximo divisor comum de
3 e 2 (se dividirmos 8 por 3, o resto é 2). Em seguida, encontramos o
máximo divisor comum de 3 e 2. 2 ainda não é 0, então agora temos 2 e 1.
O segundo número não é 0, então executamos o algoritmo novamente para 1
e 0, já que a divisão de 2 por 1 nos dá um resto de 0. E finalmente,
como o segundo número é agora 0, o resultado final é 1. Vamos ver se o
nosso código concorda:</p>
<p><code>{.haskell:hs} ghci&gt; gcd' 8 3 1</code></p>
<p>Ele concorda. Muito bom! Agora, queremos equipar nosso resultado com
um contexto, e o contexto será um valor Monoid que atua como um log.
Como antes, usaremos uma lista de strings como nosso Monoid. Portanto, o
tipo da nossa nova função <code>gcd'</code> deve ser:</p>
<p><code>{.haskell:hs} gcd' :: Int -&gt; Int -&gt; Writer [String] Int</code></p>
<p>Tudo o que resta agora é equipar nossa função com valores de log.
Aqui está o código:</p>
<p>```{.haskell:hs} import Control.Monad.Writer</p>
<p>gcd' :: Int -&gt; Int -&gt; Writer [String] Int gcd' a b | b == 0 =
do tell ["Terminei com " ++ show a] return a | otherwise = do tell [show
a ++ " mod " ++ show b ++ " = " ++ show (a <code>mod</code> b)] gcd' b
(a <code>mod</code> b) ```</p>
<p>Esta função recebe dois valores <code>Int</code> normais e retorna um
<code>Writer [String] Int</code>, ou seja, um <code>Int</code> que tem
um contexto de log. No caso em que <code>b</code> é <code>0</code>, em
vez de apenas dar <code>a</code> como resultado, usamos uma
<code>do notation</code> para compor um valor <code>Writer</code> como
resultado. Primeiro usamos o <code>tell</code> para relatar que
terminamos e depois usamos o <code>return</code> para apresentar
<code>a</code> como o resultado da <code>do notation</code>. Em vez
dessa <code>do notation</code>, poderíamos também ter escrito isto:</p>
<p><code>{.haskell:hs} Writer (a, ["Terminei com " ++ show a])</code></p>
<p>No entanto, acho que a <code>do notation</code> é mais fácil de ler.
Em seguida, temos o caso em que <code>b</code> não é <code>0</code>.
Neste caso, registramos que estamos usando o <code>mod</code> para
descobrir o resto da divisão de <code>a</code> e <code>b</code>. Então,
a segunda linha da <code>do notation</code> simplesmente chama
recursivamente o <code>gcd'</code>. Lembre-se, o <code>gcd'</code> agora
retorna finalmente um valor <code>Writer</code>, então é perfeitamente
válido que <code>gcd' b (a `mod` b)</code> seja uma linha em uma
<code>do notation</code>.</p>
<p>Embora possa ser útil rastrear a execução deste novo
<code>gcd'</code> manualmente para ver como os logs são anexados, acho
que é mais esclarecedor apenas olhar para o panorama geral e ver estes
como valores com um contexto e, a partir daí, ganhar uma visão de qual
será o resultado final.</p>
<p>Vamos testar o nosso novo <code>gcd'</code>. O seu resultado é um
valor <code>Writer [String] Int</code> e, se o desempacotarmos do seu
<code>newtype</code>, obteremos uma tupla. A primeira parte da tupla é o
resultado. Vamos ver se está tudo bem:</p>
<p><code>{.haskell:hs} ghci&gt; fst $ runWriter (gcd' 8 3) 1</code></p>
<p>Bom! E quanto ao log? Como o log é uma lista de strings, vamos usar
<code>mapM_ putStrLn</code> para imprimir essas strings na tela:</p>
<p><code>{.haskell:hs} ghci&gt; mapM_ putStrLn $ snd $ runWriter (gcd' 8 3) 8 mod 3 = 2 3 mod 2 = 1 2 mod 1 = 0 Terminei com 1</code></p>
<p>Acho incrível como conseguimos mudar nosso algoritmo comum para um
que relata o que faz à medida que avança, apenas mudando valores normais
para monadic values e deixando que a implementação do
<code>&gt;&gt;=</code> para o <code>Writer</code> cuide dos logs para
nós. Podemos adicionar um mecanismo de registro a quase qualquer função.
Basta substituir os valores normais por valores <code>Writer</code> onde
quisermos e mudar a aplicação normal de funções para
<code>&gt;&gt;=</code> (ou <code>do notation</code> se isso aumentar a
legibilidade).</p>
<h3>Construção de lista ineficiente</h3>
<p>Ao usar a Writer Monad, você deve ter cuidado com qual Monoid usar,
porque usar listas pode às vezes tornar-se muito lento. Isso ocorre
porque as listas usam o <code>++</code> para o <code>mappend</code>, e
usar o <code>++</code> para adicionar algo ao final de uma lista é lento
se essa lista for muito longa.</p>
<p>Em nossa função <code>gcd'</code>, o registro é rápido porque a
anexação da lista acaba parecendo com isto:</p>
<p><code>{.haskell:hs} a ++ (b ++ (c ++ (d ++ (e ++ f))))</code></p>
<p>As listas são uma estrutura de dados que é construída da esquerda
para a direita, e isso é eficiente porque primeiro construímos
totalmente a parte esquerda de uma lista e só então adicionamos uma
lista mais longa à direita. Mas se não formos cuidadosos, usar a Writer
Monad pode produzir uma anexação de lista que se parece com isto:</p>
<p><code>{.haskell:hs} ((((a ++ b) ++ c) ++ d) ++ e) ++ f</code></p>
<p>Isso se associa à esquerda em vez de à direita. Isso é ineficiente
porque cada vez que queremos adicionar a parte direita à esquerda, temos
que reconstruir a parte esquerda desde o início!</p>
<p>A função a seguir funciona como o <code>gcd'</code>, apenas registra
as coisas de forma inversa. Primeiro ela produz o log para o resto do
procedimento e depois adiciona o passo atual ao final do log.</p>
<p>```{.haskell:hs} import Control.Monad.Writer</p>
<p>gcdReverse :: Int -&gt; Int -&gt; Writer [String] Int gcdReverse a b
| b == 0 = do tell ["Terminei com " ++ show a] return a | otherwise = do
result &lt;- gcdReverse b (a <code>mod</code> b) tell [show a ++ " mod "
++ show b ++ " = " ++ show (a <code>mod</code> b)] return result ```</p>
<p>Ela faz a recursão primeiro e vinculá seu valor de resultado a
<code>result</code>. Em seguida, adiciona o passo atual ao log, mas o
passo atual vai para o final do log que foi produzido pela recursão.
Finalmente, apresenta o resultado da recursão como o resultado final.
Aqui está ela em ação:</p>
<p><code>{.haskell:hs} ghci&gt; mapM_ putStrLn $ snd $ runWriter (gcdReverse 8 3) Terminei com 1 2 mod 1 = 0 3 mod 2 = 1 8 mod 3 = 2</code></p>
<p>É ineficiente porque acaba associando o uso de <code>++</code> à
esquerda em vez de à direita.</p>
<h3>Listas de diferença</h3>
<p><img src="assets/images/for-a-few-monads-more/cactus.png"
alt="cactos" />{.left width=147 height=300}</p>
<p>Como as listas podem ser ineficientes às vezes quando anexadas
repetidamente dessa maneira, é melhor usar uma estrutura de dados que
suporte sempre uma anexação eficiente. Uma dessas estruturas de dados é
a lista de diferença. Uma lista de diferença é semelhante a uma lista,
só que em vez de ser uma lista normal, é uma função que recebe uma lista
e anexa outra lista a ela. O equivalente em lista de diferença de uma
lista como <code>[1,2,3]</code> seria a função
<code>\xs -&gt; [1,2,3] ++ xs</code>. Uma lista vazia normal é
<code>[]</code>, enquanto uma lista de diferença vazia é a função
<code>\xs -&gt; [] ++ xs</code>.</p>
<p>O legal das listas de diferença é que elas suportam uma anexação
eficiente. Quando anexadas duas listas normais com <code>++</code>,
temos que percorrer todo o caminho até o final da lista à esquerda de
<code>++</code> e então colar a outra ali. Mas e se adotarmos a
abordagem de lista de diferença e representarmos nossas listas como
funções? Bem, então, anexar duas listas de diferença pode ser feito
desta forma:</p>
<p><code>{.haskell:hs} f `append` g = \xs -&gt; f (g xs)</code></p>
<p>Lembre-se, <code>f</code> e <code>g</code> são funções que recebem
listas e anexam algo a elas. Então, por exemplo, se <code>f</code> for a
função <code>("cao"++)</code> (outra forma de escrever
<code>\xs -&gt; "cao" ++ xs</code>) e <code>g</code> for a função
<code>("carne"++)</code>, então <code>f `append` g</code> cria uma nova
função que é equivalente à seguinte:</p>
<p><code>{.haskell:hs} \xs -&gt; "cao" ++ ("carne" ++ xs)</code></p>
<p>Anexamos duas listas de diferença apenas criando uma nova função que
primeiro aplica uma lista de diferença a alguma lista e depois a
outra.</p>
<p>Vamos criar um wrapper <code>newtype</code> para listas de diferença
para que possamos facilmente dar a elas Monoid instances:</p>
<p><code>{.haskell:hs} newtype DiffList a = DiffList { getDiffList :: [a] -&gt; [a] }</code></p>
<p>O tipo que envolvemos é <code>[a] -&gt; [a]</code> porque uma lista
de diferença é apenas uma função que recebe uma lista e retorna outra.
Converter listas normais em listas de diferença e vice-versa é
fácil:</p>
<p>```{.haskell:hs} toDiffList :: [a] -&gt; DiffList a toDiffList xs =
DiffList (xs++)</p>
<p>fromDiffList :: DiffList a -&gt; [a] fromDiffList (DiffList f) = f []
```</p>
<p>Para transformar uma lista normal em uma lista de diferença, basta
fazermos o que fizemos antes e transformá-la em uma função que a anexa a
outra lista. Como uma lista de diferença é uma função que anexa algo a
outra lista, se quisermos apenas esse "algo", aplicamos a função a uma
lista vazia!</p>
<p>Aqui está a Monoid instance:</p>
<p><code>{.haskell:hs} instance Monoid (DiffList a) where     mempty = DiffList (\xs -&gt; [] ++ xs)     (DiffList f) `mappend` (DiffList g) = DiffList (\xs -&gt; f (g xs))</code></p>
<p>Observe como para listas, o <code>mempty</code> é apenas a função
<code>id</code> e o <code>mappend</code> é na verdade apenas a
composição de funções. Vamos ver se isto funciona:</p>
<p><code>{.haskell:hs} ghci&gt; fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3]) [1,2,3,4,1,2,3]</code></p>
<p>Ponta de linha! Agora podemos aumentar a eficiência da nossa função
<code>gcdReverse</code> fazendo-a usar listas de diferença em vez de
listas normais:</p>
<p>```{.haskell:hs} import Control.Monad.Writer</p>
<p>gcd' :: Int -&gt; Int -&gt; Writer (DiffList String) Int gcd' a b | b
== 0 = do tell (toDiffList ["Terminei com " ++ show a]) return a |
otherwise = do result &lt;- gcd' b (a <code>mod</code> b) tell
(toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a
<code>mod</code> b)]) return result ```</p>
<p>Tivemos apenas que mudar o tipo do monóide de <code>[String]</code>
para <code>DiffList String</code> e depois, ao usar o <code>tell</code>,
converter nossas listas normais em listas de diferença com o
<code>toDiffList</code>. Vamos ver se o log é montado corretamente:</p>
<p><code>{.haskell:hs} ghci&gt; mapM_ putStrLn . fromDiffList . snd . runWriter $ gcdReverse 110 34 Terminei com 2 8 mod 2 = 0 34 mod 8 = 2 110 mod 34 = 8</code></p>
<p>Fazemos <code>gcdReverse 110 34</code>, depois usamos o
<code>runWriter</code> para desempacotá-lo do seu <code>newtype</code>,
depois aplicamos o <code>snd</code> a isso para obter apenas o log,
depois aplicamos o <code>fromDiffList</code> para convertê-lo em uma
lista normal e, finalmente, imprimimos suas entradas na tela.</p>
<h3>Comparando o desempenho</h3>
<p>Para ter uma ideia de quanto as listas de diferença podem melhorar o
desempenho, considere esta função que apenas faz uma contagem regressiva
de algum número até zero, mas produz seu log de forma reversa, como
<code>gcdReverse</code>, de modo que os números no log serão contados de
forma progressiva:</p>
<p><code>{.haskell:hs} finalCountDown :: Int -&gt; Writer (DiffList String) () finalCountDown 0 = do     tell (toDiffList ["0"]) finalCountDown x = do     finalCountDown (x-1)     tell (toDiffList [show x])</code></p>
<p>Se dermos <code>0</code>, ela apenas registra. Para qualquer outro
número, ela primeiro faz a contagem regressiva do seu antecessor até
<code>0</code> e depois anexa esse número ao log. Portanto, se
aplicarmos <code>finalCountDown</code> a <code>100</code>, a string
<code>"100"</code> virá por último no log.</p>
<p>De qualquer modo, se você carregar esta função no GHCi e aplicá-la a
um número grande, como <code>500000</code>, verá que ela começa a contar
rapidamente de <code>0</code> em diante:</p>
<p><code>{.haskell:hs} ghci&gt; mapM_ putStrLn . fromDiffList . snd . runWriter $ finalCountDown 500000 0 1 2 ...</code></p>
<p>No entanto, se mudarmos para usar listas normais em vez de listas de
diferença, desta forma:</p>
<p><code>{.haskell:hs} finalCountDown :: Int -&gt; Writer [String] () finalCountDown 0 = do     tell ["0"] finalCountDown x = do     finalCountDown (x-1)     tell [show x]</code></p>
<p>E então pedirmos para o GHCi começar a contar:</p>
<p><code>{.haskell:hs} ghci&gt; mapM_ putStrLn . snd . runWriter $ finalCountDown 500000</code></p>
<p>Veremos que a contagem é muito lenta.</p>
<p>Claro, esta não é a maneira correta e científica de testar a rapidez
dos nossos programas, mas fomos capazes de ver que, neste caso, usar
listas de diferença começa a produzir resultados imediatamente, enquanto
as listas normais levam uma eternidade.</p>
<p>Ah, a propósito, a música Final Countdown do Europe agora está
grudada na sua cabeça. Divirta-se!</p>
<h2>Reader? Ugh, essa piada de novo não. {#reader}</h2>
<p><img src="assets/images/for-a-few-monads-more/revolver.png"
alt="bang voce esta morto" />{.left width=280 height=106}</p>
<p>No <a href="functors-applicative-functors-and-monoids.html">capítulo
sobre aplicativos</a>, vimos que o tipo de função,
<code>(-&gt;) r</code> é uma instância de <code>Functor</code>. Mapear
uma função <code>f</code> sobre uma função <code>g</code> criará uma
função que recebe a mesma coisa que <code>g</code>, aplica
<code>g</code> a ela e então aplica <code>f</code> a esse resultado.
Basicamente, estamos criando uma nova função que é como <code>g</code>,
só que antes de retornar seu resultado, <code>f</code> também é aplicado
a esse resultado. Por exemplo:</p>
<p><code>{.haskell:hs} ghci&gt; let f = (*5) ghci&gt; let g = (+3) ghci&gt; (fmap f g) 8 55</code></p>
<p>Também vimos que as funções são Applicative Functors. Elas nos
permitem operar nos resultados eventuais das funções como se já
tivéssemos seus resultados. Aqui está um exemplo:</p>
<p><code>{.haskell:hs} ghci&gt; let f = (+) &lt;$&gt; (*2) &lt;*&gt; (+10) ghci&gt; f 3 19</code></p>
<p>A expressão <code>(+) &lt;$&gt; (*2) &lt;*&gt; (+10)</code> cria uma
função que recebe um número, dá esse número para <code>(*2)</code> e
<code>(+10)</code> e depois soma os resultados. Por exemplo, se
aplicarmos esta função a <code>3</code>, ela aplica tanto
<code>(*2)</code> quanto <code>(+10)</code> a <code>3</code>, dando
<code>6</code> e <code>13</code>. Então, ela chama <code>(+)</code> com
<code>6</code> e <code>13</code> e o resultado é <code>19</code>.</p>
<p>O tipo de função <code>(-&gt;) r</code> não é apenas um Functor e um
Applicative Functor, mas também é uma Monad. Assim como outros monadic
values que conhecemos até agora, uma função também pode ser considerada
um valor com um contexto. O contexto para funções é que esse valor ainda
não está presente e que temos que aplicar essa função a algo para obter
seu valor de resultado.</p>
<p>Como já estamos familiarizados com o funcionamento das funções como
Functors e Applicative Functors, vamos mergulhar de cabeça e ver como é
a sua Monad instance. Ela está localizada em
<code>Control.Monad.Instances</code> e funciona mais ou menos assim:</p>
<p><code>{.haskell:hs} instance Monad ((-&gt;) r) where     return x = \_ -&gt; x     h &gt;&gt;= f = \w -&gt; f (h w) w</code></p>
<p>Já vimos como o <code>pure</code> é implementado para funções, e o
<code>return</code> é basicamente a mesma coisa que o <code>pure</code>.
Ele recebe um valor e o coloca em um contexto mínimo que sempre tem esse
valor como resultado. E a única maneira de criar uma função que sempre
tenha um determinado valor como resultado é fazê-la ignorar
completamente o seu parâmetro.</p>
<p>A implementação para o <code>&gt;&gt;=</code> parece um pouco
enigmática, mas não é tudo isso. Quando usamos o <code>&gt;&gt;=</code>
para alimentar um monadic value para uma função, o resultado é sempre um
monadic value. Portanto, neste caso, quando alimentamos uma função para
outra função, o resultado também é uma função. É por isso que o
resultado começa como um lambda. Todas as implementações do
<code>&gt;&gt;=</code> até agora sempre isolaram de alguma forma o
resultado do monadic value e depois aplicaram a função <code>f</code> a
esse resultado. A mesma coisa acontece aqui. Para obter o resultado de
uma função, temos que aplicá-la a algo, e é por isso que fazemos
<code>(h w)</code> aqui para obter o resultado da função e depois
aplicamos <code>f</code> a isso. O <code>f</code> retorna um monadic
value, que é uma função no nosso caso, por isso também o aplicamos a
<code>w</code>.</p>
<p>Se você não entender como o <code>&gt;&gt;=</code> funciona neste
momento, não se preocupe, porque com exemplos veremos que esta é uma
Monad muito simples. Aqui está uma <code>do notation</code> que utiliza
esta Monad:</p>
<p>```{.haskell:hs} import Control.Monad.Instances</p>
<p>addStuff :: Int -&gt; Int addStuff = do a &lt;- (*2) b &lt;- (+10)
return (a+b) ```</p>
<p>Isso é a mesma coisa que a Applicative expression que escrevemos
anteriormente, só que agora ela depende das funções serem Monads. Uma
<code>do notation</code> sempre resulta em um monadic value e esta não é
diferente. O resultado deste monadic value é uma função. O que acontece
aqui é que ela recebe um número e então o <code>(*2)</code> é aplicado a
esse número e o resultado se torna <code>a</code>. O <code>(+10)</code>
é aplicado ao mesmo número que o <code>(*2)</code> foi aplicado e o
resultado se torna <code>b</code>. O <code>return</code>, como em outras
Monads, não tem nenhum outro efeito a não ser criar um monadic value que
apresente algum resultado. Isso apresenta <code>a+b</code> como o
resultado desta função. Se testarmos, obteremos o mesmo resultado de
antes:</p>
<p><code>{.haskell:hs} ghci&gt; addStuff 3 19</code></p>
<p>Tanto o <code>(*2)</code> quanto o <code>(+10)</code> são aplicados
ao número <code>3</code> neste caso. <code>return (a+b)</code> também,
mas ele o ignora e sempre apresenta <code>a+b</code> como o resultado.
Por esta razão, a função Monad também é chamada de Reader Monad. Todas
as funções lêem de uma fonte comum. Para ilustrar isto ainda melhor,
podemos reescrever o <code>addStuff</code> desta forma:</p>
<p><code>{.haskell:hs} addStuff :: Int -&gt; Int addStuff x = let     a = (*2) x     b = (+10) x     in a+b</code></p>
<p>Vemos que a Reader Monad nos permite tratar funções como valores com
um contexto. Podemos agir como se já soubéssemos o que as funções
retornarão. Ela faz isso colando as funções em uma única função e dando
o parâmetro dessa função a todas as funções a partir das quais ela foi
colada. Portanto, se tivermos muitas funções que estão todas sentindo
falta de apenas um parâmetro e que eventualmente seriam aplicadas à
mesma coisa, podemos usar a Reader Monad para extrair os seus resultados
futuros e a implementação do <code>&gt;&gt;=</code> garantirá que tudo
corra bem.</p>
<h2>Computações com estado de bom gosto {#state}</h2>
<p><img src="assets/images/for-a-few-monads-more/texas.png"
alt="não brinque com o texas" />{.left width=244 height=230}</p>
<p>Haskell é uma linguagem pura e, por causa disso, nossos programas são
feitos de funções que não podem alterar nenhum estado global ou
variáveis; elas podem apenas fazer algumas computações e retornar seus
resultados. Essa restrição na verdade torna mais fácil pensar sobre
nossos programas, pois nos livra de nos preocuparmos com o valor de cada
variável em algum momento no tempo. No entanto, alguns problemas são
inerentemente estatais, no sentido de que dependem de algum estado que
muda ao longo do tempo. Embora tais problemas não sejam um problema para
o Haskell, eles podem ser um pouco tediosos de modelar às vezes. É por
isso que o Haskell apresenta uma coisa chamada State Monad, que torna a
lida com problemas estatais uma brisa, mantendo tudo agradável e
puro.</p>
<p><a href="input-and-output.html#randomness">Quando estávamos lidando
com números aleatórios</a>, lidamos com funções que recebiam um gerador
aleatório como parâmetro e retornavam um número aleatório e um novo
gerador aleatório. Se quisermos gerar vários números aleatórios, sempre
tínhamos que usar o gerador aleatório que uma função anterior retornou
junto com seu resultado. Ao fazer uma função que recebe um
<code>StdGen</code> e joga uma moeda três vezes com base nesse gerador,
tínhamos que fazer isto:</p>
<p><code>{.haskell:hs} threeCoins :: StdGen -&gt; (Bool, Bool, Bool) threeCoins gen =     let (firstCoin, newGen) = random gen         (secondCoin, newGen') = random newGen         (thirdCoin, newGen'') = random newGen'     in  (firstCoin, secondCoin, thirdCoin)</code></p>
<p>Ela recebia um gerador <code>gen</code> e então
<code>random gen</code> retornava um valor <code>Bool</code> junto com
um novo gerador. Para jogar a segunda moeda, usamos o novo gerador, e
assim por diante. Na maioria das outras linguagens, não teríamos que
retornar um novo gerador junto com um número aleatório. Poderíamos
apenas modificar o já existente! Mas como o Haskell é puro, não podemos
fazer isso, então tivemos que pegar algum estado, criar um resultado a
partir dele e um novo estado, e então usar esse novo estado para gerar
novos resultados.</p>
<p>Você pensaria que, para evitar lidar manualmente com computações
estatais dessa maneira, teríamos que abrir mão da pureza do Haskell.
Bem, não precisamos, pois existe uma pequena mônada especial chamada
mônada state que cuida de todo esse negócio de estado para nós e sem
abrir mão de nada da pureza que torna a programação em Haskell tão
legal.</p>
<p>Então, para nos ajudar a entender melhor esse conceito de computações
estatais, vamos em frente e dar a elas um tipo. Diremos que uma
computação estatal é uma função que recebe algum estado e retorna um
valor junto com algum novo estado. Essa função teria o seguinte
tipo:</p>
<p><code>{.haskell:hs} s -&gt; (a,s)</code></p>
<p><code>s</code> é o tipo do estado e <code>a</code> o resultado das
computações estatais.</p>
<p>::: {.hintbox} A atribuição na maioria das outras linguagens poderia
ser pensada como uma computação estatal. Por exemplo, quando fazemos
<code>x = 5</code> em uma linguagem imperativa, ela geralmente atribui o
valor <code>5</code> à variável <code>x</code> e também terá o valor
<code>5</code> como uma expressão. Se você olhar para isso
funcionalmente, poderia vê-lo como uma função que recebe um estado (ou
seja, todas as variáveis que foram atribuídas anteriormente) e retorna
um resultado (neste caso <code>5</code>) e um novo estado, que seria
todos os mapeamentos de variáveis anteriores mais a variável
recém-atribuída. :::</p>
<p>Esta computação estatal, uma função que recebe um estado e retorna um
resultado e um novo estado, pode ser pensada como um valor com um
contexto também. O valor real é o resultado, enquanto o contexto é que
temos que fornecer algum estado inicial para realmente obter esse
resultado e que, além de obter um resultado, também obtemos um novo
estado.</p>
<h3>Pilhas e pedras</h3>
<p>Digamos que queiramos modelar a operação de uma pilha (stack). Você
tem uma pilha de coisas uma em cima da outra e pode colocar coisas em
cima dessa pilha ou pode tirar coisas do topo da pilha. Quando você está
colocando um item no topo da pilha, dizemos que você o está empilhando
(<em>pushing</em>) e quando você está tirando coisas do topo, dizemos
que o está desempilhando (<em>popping</em>). Se você quiser algo que
está no fundo da pilha, você tem que desempilhar tudo o que está acima
dele.</p>
<p>Usaremos uma lista para representar nossa pilha e a cabeça da lista
será o topo da pilha. Para nos ajudar em nossa tarefa, faremos duas
funções: <code>pop</code> e <code>push</code>. <code>pop</code> receberá
uma pilha, desempilhará um item e retornará esse item como resultado e
também retornará uma nova pilha, sem esse item. <code>push</code>
receberá um item e uma pilha e então empilhará esse item na pilha. Ela
retornará <code>()</code> como seu resultado, junto com uma nova pilha.
Aqui vai:</p>
<p>```{.haskell:hs} type Stack = [Int]</p>
<p>pop :: Stack -&gt; (Int,Stack) pop (x:xs) = (x,xs)</p>
<p>push :: Int -&gt; Stack -&gt; ((),Stack) push a xs = ((),a:xs)
```</p>
<p>Usamos <code>()</code> como o resultado ao empurrar para a pilha
porque empurrar um item na pilha não tem nenhum valor de resultado
importante, seu trabalho principal é mudar a pilha. Observe como, apenas
ao aplicarmos o primeiro parâmetro de <code>push</code>, obtemos uma
computação estatal. <code>pop</code> já é uma computação estatal por
causa do seu tipo.</p>
<p>Vamos escrever um pequeno pedaço de código para simular uma pilha
usando estas funções. Pegaremos uma pilha, empilharemos <code>3</code>
nela e depois desempilharemos dois itens, apenas por diversão. Aqui está
ele:</p>
<p><code>{.haskell:hs} stackManip :: Stack -&gt; (Int, Stack) stackManip stack = let     ((),newStack1) = push 3 stack     (a ,newStack2) = pop newStack1     in pop newStack2</code></p>
<p>Pegamos uma <code>stack</code> e então fazemos
<code>push 3 stack</code>, o que resulta em uma tupla. A primeira parte
da tupla é um <code>()</code> e a segunda é uma nova pilha e a chamamos
de <code>newStack1</code>. Então, desempilhamos um número de
<code>newStack1</code>, o que resulta em um número <code>a</code> (que é
o <code>3</code> que empilhamos) e uma nova pilha que chamamos de
<code>newStack2</code>. Então, desempilhamos um número da
<code>newStack2</code> e obtemos um número que é <code>b</code> e uma
<code>newStack3</code>. Retornamos uma tupla com esse número e essa
pilha. Vamos testar:</p>
<p><code>{.haskell:hs} ghci&gt; stackManip [5,8,2,1] (5,[8,2,1])</code></p>
<p>Legal, o resultado é <code>5</code> e a nova pilha é
<code>[8,2,1]</code>. Observe como <code>stackManip</code> é por si só
uma computação estatal. Pegamos um punhado de computações estatais e as
colamos juntas, por assim dizer. Hmm, parece familiar.</p>
<p>O código acima para o <code>stackManip</code> é meio tedioso, pois
estamos dando manualmente o estado para cada computação estatal e
armazenandoo para depois passá-lo para a próxima. Não seria mais legal
se, em vez de dar a pilha manualmente para cada função, pudéssemos
escrever algo como isto:</p>
<p><code>{.haskell:hs} stackManip = do     push 3     a &lt;- pop     pop</code></p>
<p>Bem, usar a State Monad nos permitirá fazer exatamente isso. Com ela,
poderemos pegar computações estatais como estas e usá-las sem ter que
gerenciar o estado manualmente.</p>
<h3>A State Monad</h3>
<p>O módulo <code>Control.Monad.State</code> fornece um
<code>newtype</code> que envolve computações estatais. Aqui está sua
definição:</p>
<p><code>{.haskell:hs} newtype State s a = State { runState :: s -&gt; (a,s) }</code></p>
<p>Um <code>State s a</code> é uma computação estatal que manipula um
estado do tipo <code>s</code> e tem um resultado do tipo
<code>a</code>.</p>
<p>Agora que vimos do que se trata as computações estatais e como elas
podem até ser pensadas como valores com contextos, vamos conferir a sua
Monad instance:</p>
<p><code>{.haskell:hs} instance Monad (State s) where     return x = State $ \s -&gt; (x,s)     (State h) &gt;&gt;= f = State $ \s -&gt; let (a, newState) = h s                                         (State g) = f a                                     in  g newState</code></p>
<p>Vamos dar uma olhada no <code>return</code> primeiro. Nosso objetivo
com o <code>return</code> é pegar um valor e criar uma computação
estatal que sempre tenha esse valor como resultado. É por isso que
apenas criamos um lambda <code>\s -&gt; (x,s)</code>. Sempre
apresentamos <code>x</code> como o resultado da computação estatal e o
estado permanece inalterado, porque o <code>return</code> tem que
colocar um valor em um contexto mínimo. Então, o <code>return</code>
criará uma computação estatal que apresenta um determinado valor como
resultado e mantém o estado inalterado.</p>
<p><img src="assets/images/for-a-few-monads-more/badge.png"
alt="eu sou um guarda" />{.right width=182 height=160}</p>
<p>E o <code>&gt;&gt;=</code>? Bem, o resultado de alimentar uma
computação estatal a uma função com <code>&gt;&gt;=</code> tem que ser
uma computação estatal, certo? Então começamos com o wrapper
<code>newtype</code> <code>State</code> e depois escrevemos um lambda.
Este lambda será nossa nova computação estatal. Mas o que acontece nele?
Bem, de alguma forma temos que extrair o valor do resultado da primeira
computação estatal. Como estamos em uma computação estatal agora,
podemos dar à computação estatal <code>h</code> o nosso estado atual
<code>s</code>, o que resulta em um par de resultado e um novo estado:
<code>(a, newState)</code>. Toda vez que implementamos o
<code>&gt;&gt;=</code> até agora, uma vez que tínhamos extraído o
resultado do valor monádico, aplicávamos a função <code>f</code> a ele
para obter o novo valor monádico. No <code>Writer</code>, depois de
fazer isso e obter o novo valor monádico, ainda tínhamos que garantir
que o contexto fosse cuidado fazendo o <code>mappend</code> do valor
monóide antigo com o novo. Aqui, fazemos <code>f a</code> e obtemos uma
nova computação estatal <code>g</code>. Agora que temos uma nova
computação estatal e um novo estado (que atende pelo nome de
<code>newState</code>), apenas aplicamos essa computação estatal
<code>g</code> ao <code>newState</code>. O resultado é uma tupla de
resultado final e estado final!</p>
<p>Portanto, com o <code>&gt;&gt;=</code>, colamos duas computações
estatais juntas, porém a segunda está escondida dentro de uma função que
recebe o resultado da anterior. Como <code>pop</code> e
<code>push</code> já são computações estatais, é fácil envolvê-las em um
wrapper <code>State</code>. Observe:</p>
<p>```{.haskell:hs} import Control.Monad.State</p>
<p>pop :: State Stack Int pop = State $ (x:xs) -&gt; (x,xs)</p>
<p>push :: Int -&gt; State Stack () push a = State $ \xs -&gt; ((),a:xs)
```</p>
<p><code>pop</code> já é uma computação estatal e <code>push</code>
recebe um <code>Int</code> e retorna uma computação estatal. Agora
podemos reescrever nosso exemplo anterior de empilhar <code>3</code> na
pilha e depois desempilhar dois números desta forma:</p>
<p>```{.haskell:hs} import Control.Monad.State</p>
<p>stackManip :: State Stack Int stackManip = do push 3 a &lt;- pop pop
```</p>
<p>Viu como colamos um push e dois pops em uma única computação estatal?
Quando a desempacotamos de seu wrapper <code>newtype</code>, obtemos uma
função para a qual podemos fornecer algum estado inicial:</p>
<p><code>{.haskell:hs} ghci&gt; runState stackManip [5,8,2,1] (5,[8,2,1])</code></p>
<p>Não tivemos que vincular o segundo <code>pop</code> a <code>a</code>
porque não usamos esse <code>a</code> para nada. Então poderíamos ter
escrito desta forma:</p>
<p><code>{.haskell:hs} stackManip :: State Stack Int stackManip = do     push 3     pop     pop</code></p>
<p>Bem legal. Mas e se quisermos fazer isto: desempilhar um número da
pilha e, se esse número for <code>5</code>, apenas colocá-lo de volta na
pilha e parar, mas se não for <code>5</code>, empilhar <code>3</code> e
<code>8</code> de volta? Bem, aqui está o código:</p>
<p><code>{.haskell:hs} stackStuff :: State Stack () stackStuff = do     a &lt;- pop     if a == 5         then push 5         else do             push 3             push 8</code></p>
<p>Isto é bem direto. Vamos executá-lo com uma pilha inicial.</p>
<p><code>{.haskell:hs} ghci&gt; runState stackStuff [9,0,2,1,0] ((),[8,3,0,2,1,0])</code></p>
<p>Lembre-se, as <code>do notation</code> resultam em monadic values e,
com a State Monad, uma única <code>do notation</code> também é uma
função estatal. Como <code>stackManip</code> e <code>stackStuff</code>
são computações estatais comuns, podemos colá-las para produzir novas
computações estatais.</p>
<p><code>{.haskell:hs} moreStack :: State Stack () moreStack = do     a &lt;- stackManip     if a == 100         then stackStuff         else return ()</code></p>
<p>Se o resultado de <code>stackManip</code> na pilha atual for
<code>100</code>, executamos <code>stackStuff</code>, caso contrário não
fazemos nada. <code>return ()</code> apenas mantém o estado como está e
não faz nada.</p>
<p>O módulo <code>Control.Monad.State</code> fornece uma typeclass
chamada <code>MonadState</code> que apresenta duas funções bem úteis,
chamadas <code>get</code> e <code>put</code>. Para o <code>State</code>,
a função <code>get</code> é implementada desta forma:</p>
<p><code>{.haskell:hs} get = State $ \s -&gt; (s,s)</code></p>
<p>Então ela apenas pega o estado atual e o apresenta como o resultado.
A função <code>put</code> recebe algum estado e cria uma função estatal
que substitui o estado atual por ele:</p>
<p><code>{.haskell:hs} put newState = State $ \s -&gt; ((),newState)</code></p>
<p>Com estas funções, podemos ver qual é a pilha atual ou podemos
substituí-la por uma pilha completamente diferente. Assim:</p>
<p><code>{.haskell:hs} stackyStack :: State Stack () stackyStack = do     stackNow &lt;- get     if stackNow == [1,2,3]         then put [8,3,1]         else put [9,2,1]</code></p>
<p>Vale a pena examinar qual seria o tipo de <code>&gt;&gt;=</code> se
ele funcionasse apenas para valores <code>State</code>:</p>
<p><code>{.haskell:hs} (&gt;&gt;=) :: State s a -&gt; (a -&gt; State s b) -&gt; State s b</code></p>
<p>Viu como o tipo do estado <code>s</code> permanece o mesmo, mas o
tipo do resultado pode mudar de <code>a</code> para <code>b</code>? Isso
significa que podemos colar várias computações estatais cujos resultados
são de tipos diferentes, mas o tipo do estado tem que permanecer o
mesmo. E por que isso? Bem, por exemplo, para o <code>Maybe</code>, o
<code>&gt;&gt;=</code> tem este tipo:</p>
<p><code>{.haskell:hs} (&gt;&gt;=) :: Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b</code></p>
<p>Faz sentido que a própria mônada, <code>Maybe</code>, não mude. Não
faria sentido usar <code>&gt;&gt;=</code> entre duas mônadas diferentes.
Bem, para a mônada state, a mônada é na verdade <code>State s</code>,
então se esse <code>s</code> fosse diferente, estaríamos usando
<code>&gt;&gt;=</code> entre duas mônadas diferentes.</p>
<h3>Aleatoriedade e a mônada state</h3>
<p>No início desta seção, vimos como gerar números pode às vezes ser
incômodo porque cada função aleatória recebe um gerador e retorna um
número aleatório junto com um novo gerador, que deve ser usado no lugar
do antigo se quisermos gerar outro número aleatório. A mônada state
torna a lida com isso muito mais fácil.</p>
<p>A função <code>random</code> de <code>System.Random</code> tem o
seguinte tipo:</p>
<p><code>{.haskell:hs} random :: (RandomGen g, Random a) =&gt; g -&gt; (a, g)</code></p>
<p>Ou seja, ela recebe um gerador aleatório e produz um número aleatório
junto com um novo gerador. Podemos ver que se trata de uma computação
estatal, então podemos envolvê-la no construtor <code>newtype</code>
<code>State</code> e então usá-la como um valor monádico para que a
passagem do estado seja tratada para nós:</p>
<p>```{.haskell:hs} import System.Random import Control.Monad.State</p>
<p>randomSt :: (RandomGen g, Random a) =&gt; State g a randomSt = State
random ```</p>
<p>Então, agora, se quisermos jogar três moedas (<code>True</code> é
coroa, <code>False</code> é cara) basta fazer o seguinte:</p>
<p>```{.haskell:hs} import System.Random import Control.Monad.State</p>
<p>threeCoins :: State StdGen (Bool,Bool,Bool) threeCoins = do a &lt;-
randomSt b &lt;- randomSt c &lt;- randomSt return (a,b,c) ```</p>
<p><code>threeCoins</code> é agora uma computação estatal e, após
receber um gerador aleatório inicial, ela o passa para o primeiro
<code>randomSt</code>, que produz um número e um novo gerador, o qual é
passado para o próximo e assim por diante. Usamos
<code>return (a,b,c)</code> para apresentar <code>(a,b,c)</code> como o
resultado sem alterar o gerador mais recente. Vamos testar:</p>
<p><code>{.haskell:hs} ghci&gt; runState threeCoins (mkStdGen 33) ((True,False,True),680029187 2103410263)</code></p>
<p>Legas. Fazer essas coisas que exigem que algum estado seja mantido
entre as etapas tornou-se muito menos trabalhoso!</p>
<h2>Erro, erro meu... {#error}</h2>
<p>Já sabemos que o <code>Maybe</code> é usado para adicionar um
contexto de possível falha aos valores. Um valor pode ser um
<code>Just algo</code> ou um <code>Nothing</code>. No entanto, por mais
útil que isso seja, quando temos um <code>Nothing</code>, tudo o que
sabemos é que houve algum tipo de falha, mas não há como enfiar mais
informações ali dizendo que tipo de falha foi ou por que falhou.</p>
<p>O tipo <code>Either e a</code>, por outro lado, nos permite
incorporar um contexto de possível falha aos nossos valores e também
anexar valores à falha, para que eles possam descrever o que deu errado
ou fornecer outras informações úteis sobre a falha. Um valor
<code>Either e a</code> pode ser um valor <code>Right</code>,
significando a resposta correta e o sucesso, ou pode ser um valor
<code>Left</code>, significando falha. Por exemplo:</p>
<p><code>{.haskell:hs} ghci&gt; :t Right 4 Right 4 :: (Num t) =&gt; Either a t ghci&gt; :t Left "erro de falta de queijo" Left "erro de falta de queijo" :: Either [Char] b</code></p>
<p>Isso é praticamente um <code>Maybe</code> aprimorado, então faz
sentido que seja uma Monad, porque também pode ser visto como um valor
com um contexto adicional de falha possível, só que agora também há um
valor anexado quando há um erro.</p>
<p>Sua Monad instance é semelhante à do <code>Maybe</code> e pode ser
encontrada em <code>Control.Monad.Error</code>:</p>
<p><code>{.haskell:hs} instance (Error e) =&gt; Monad (Either e) where     return x = Right x     Right x &gt;&gt;= f = f x     Left err &gt;&gt;= f = Left err     fail msg = Left (strMsg msg)</code></p>
<p>O <code>return</code>, como sempre, recebe um valor e o coloca em um
contexto mínimo padrão. Ele envolve o nosso valor no construtor
<code>Right</code> porque estamos usando o <code>Right</code> para
representar uma computação bem-sucedida onde um resultado está presente.
Isso é muito parecido com o <code>return</code> para o
<code>Maybe</code>.</p>
<p>O <code>&gt;&gt;=</code> examina dois casos possíveis: um
<code>Left</code> e um <code>Right</code>. No caso de um
<code>Right</code>, a função <code>f</code> é aplicada ao valor dentro
dele, de forma semelhante a como, no caso de um <code>Just</code>, a
função é aplicada ao seu conteúdo. No caso de um erro, o valor
<code>Left</code> é mantido, junto com o seu conteúdo, que descreve a
falha.</p>
<p>A instância <code>Monad</code> para <code>Either e</code> faz uma
exigência adicional: o tipo do valor contido em um <code>Left</code>,
aquele que é indexado pelo parâmetro de tipo <code>e</code>, tem que ser
uma instância da typeclass <code>Error</code>. A typeclass
<code>Error</code> é para tipos cujos valores podem agir como mensagens
de erro. Ela define a função <code>strMsg</code>, que recebe um erro na
forma de uma string e retorna um valor desse tipo. Um bom exemplo de uma
instância <code>Error</code> é, bem, o tipo <code>String</code>! No caso
da <code>String</code>, a função <code>strMsg</code> apenas retorna a
string que recebeu:</p>
<p><code>{.haskell:hs} ghci&gt; :t strMsg strMsg :: (Error a) =&gt; String -&gt; a ghci&gt; strMsg "boom!" :: String "boom!"</code></p>
<p>Mas, como geralmente usamos <code>String</code> para descrever o erro
ao usar <code>Either</code>, não precisamos nos preocupar muito com
isso. Quando um pattern match falha na <code>do notation</code>, um
valor <code>Left</code> é usado para significar essa falha.</p>
<p>De qualquer forma, aqui estão alguns exemplos de uso:</p>
<p><code>{.haskell:hs} ghci&gt; Left "boom" &gt;&gt;= \x -&gt; return (x+1) Left "boom" ghci&gt; Right 100 &gt;&gt;= \x -&gt; Left "de jeito nenhum!" Left "de jeito nenhum!"</code></p>
<p>Quando usamos o <code>&gt;&gt;=</code> para alimentar um valor
<code>Left</code> para uma função, a função é ignorada e um valor
<code>Left</code> idêntico é retornado. Quando alimentamos um valor
<code>Right</code> para uma função, a função é aplicada ao que está
dentro, mas no nosso caso essa função produziu um valor
<code>Left</code> de qualquer maneira!</p>
<p>Quando tentamos alimentar um valor <code>Right</code> para uma função
que também tem sucesso, somos surpreendidos por um erro de tipo
peculiar! Hmmm.</p>
<p>```{.haskell:hs} ghci&gt; Right 3 &gt;&gt;= \x -&gt; return (x +
100)</p>
<p>&lt;interactive&gt;:1:0: Ambiguous type variable
<code>a' in the constraints:</code>Error a' arising from a use of
<code>it' at &lt;interactive&gt;:1:0-33</code>Show a' arising from a use
of `print' at &lt;interactive&gt;:1:0-33 Probable fix: add a type
signature that fixes these type variable(s) ```</p>
<p>O Haskell diz que não sabe qual tipo escolher para a parte
<code>e</code> do nosso valor de tipo <code>Either e a</code>, embora
estejamos apenas imprimindo a parte <code>Right</code>. Isso se deve à
restrição <code>Error e</code> na Monad instance. Portanto, se você
receber erros de tipo como este ao usar o <code>Either</code> como uma
Monad, basta adicionar uma assinatura de tipo explícita:</p>
<p><code>{.haskell:hs} ghci&gt; Right 3 &gt;&gt;= \x -&gt; return (x + 100) :: Either String Int Right 103</code></p>
<p>Tudo bem, agora funciona!</p>
<p>Além desse pequeno contratempo, usar esta Monad é muito semelhante a
usar o <code>Maybe</code> como uma Monad. No capítulo anterior, usamos
os aspectos monádicos do <code>Maybe</code> para simular pássaros
pousando na vara de equilíbrio de um equilibrista. Como exercício, você
pode reescrever isso com a Error Monad para que, quando o equilibrista
escorregue e caia, lembremos de quantos pássaros estavam em cada lado da
vara quando ele caiu.</p>
<h2>Algumas monadic functions úteis {#useful-monadic-functions}</h2>
<p>Nesta seção, exploraremos algumas funções que operam em monadic
values ou retornam monadic values como resultados (ou ambos!). Tais
funções são geralmente chamadas de monadic functions. Embora algumas
delas sejam completamente novas, outras serão contrapartes monádicas de
funções que já conhecemos, como <code>filter</code> e
<code>foldl</code>. Vamos ver quais são!</p>
<h3>liftM e amigos</h3>
<p><img src="assets/images/for-a-few-monads-more/wolf.png"
alt="eu também sou um guarda" />{.right width=394 height=222}</p>
<p>Quando começamos nossa jornada rumo ao topo da Montanha Monad,
primeiro olhamos para os Functors, que são para coisas sobre as quais se
pode mapear. Em seguida, aprendemos sobre Functors aprimorados chamados
Applicative Functors, que nos permitiram aplicar funções normais entre
vários valores aplicativos, bem como pegar um valor normal e colocá-lo
em algum contexto padrão. Finalmente, introduzimos as Monads como
Applicative Functors aprimorados, que adicionaram a capacidade desses
valores com contexto de serem de alguma forma alimentados em funções
normais.</p>
<p>Portanto, toda Monad é um Applicative Functor e todo Applicative
Functor é um Functor. A typeclass <code>Applicative</code> tem uma
restrição de classe tal que o nosso tipo tem que ser uma instância de
<code>Functor</code> antes de podermos torná-lo uma instância de
<code>Applicative</code>. Mas, embora a <code>Monad</code> devesse ter a
mesma restrição para <code>Applicative</code>, já que toda Monad é um
Applicative Functor, não tem, porque a typeclass <code>Monad</code> foi
introduzida no Haskell muito antes da <code>Applicative</code>.</p>
<p>Mas apesar de toda Monad ser um Functor, não precisamos depender de
que ela tenha uma Functor instance por causa da função
<code>liftM</code>. O <code>liftM</code> recebe uma função e um monadic
value e o mapeia sobre o monadic value. Portanto, é praticamente a mesma
coisa que o <code>fmap</code>! Este é o tipo do <code>liftM</code>:</p>
<p><code>{.haskell:hs} liftM :: (Monad m) =&gt; (a -&gt; b) -&gt; m a -&gt; m b</code></p>
<p>E este é o tipo do <code>fmap</code>:</p>
<p><code>{.haskell:hs} fmap :: (Functor f) =&gt; (a -&gt; b) -&gt; f a -&gt; f b</code></p>
<p>Se as instâncias de <code>Functor</code> e <code>Monad</code> para um
tipo obedecerem às leis dos Functors e das Monads, estas duas coisas
resultam na mesma coisa (e todas as Monads que conhecemos até agora
obedecem a ambas). Isso é parecido com o <code>pure</code> e o
<code>return</code> fazendo a mesma coisa, só que um tem uma restrição
de classe <code>Applicative</code> enquanto o outro tem uma
<code>Monad</code>. Vamos testar o <code>liftM</code>:</p>
<p><code>{.haskell:hs} ghci&gt; liftM (*3) (Just 8) Just 24 ghci&gt; fmap (*3) (Just 8) Just 24 ghci&gt; runWriter $ liftM not $ Writer (True, "grao-de-bico") (False,"grao-de-bico") ghci&gt; runWriter $ fmap not $ Writer (True, "grao-de-bico") (False,"grao-de-bico") ghci&gt; runState (liftM (+100) pop) [1,2,3,4] (101,[2,3,4]) ghci&gt; runState (fmap (+100) pop) [1,2,3,4] (101,[2,3,4])</code></p>
<p>Já sabemos muito bem como o <code>fmap</code> funciona com valores
<code>Maybe</code>. E o <code>liftM</code> faz a mesma coisa. Para
valores <code>Writer</code>, a função é mapeada sobre o primeiro
componente da tupla, que é o resultado. Fazer <code>fmap</code> ou
<code>liftM</code> sobre uma computação estatal resulta em outra
computação estatal, apenas seu resultado eventual é modificado pela
função fornecida. Se não tivéssemos mapeado <code>(+100)</code> sobre o
<code>pop</code> neste caso antes de executá-lo, ele teria retornado
<code>(1,[2,3,4])</code>.</p>
<p>É assim que o <code>liftM</code> é implementado:</p>
<p><code>{.haskell:hs} liftM :: (Monad m) =&gt; (a -&gt; b) -&gt; m a -&gt; m b liftM f m = m &gt;&gt;= (\x -&gt; return (f x))</code></p>
<p>Ou com a notação <code>do</code>:</p>
<p><code>{.haskell:hs} liftM :: (Monad m) =&gt; (a -&gt; b) -&gt; m a -&gt; m b liftM f m = do     x &lt;- m     return (f x)</code></p>
<p>Alimentamos o monadic value <code>m</code> na função e então
aplicamos a função <code>f</code> ao seu resultado antes de colocá-lo de
volta em um contexto padrão. Por causa das leis das Monads, isso garante
não alterar o contexto, apenas o resultado que o monadic value
apresenta. Vemos que o <code>liftM</code> é implementado sem referenciar
a typeclass <code>Functor</code> de forma alguma. Isso significa que
podemos implementar o <code>fmap</code> (ou <code>liftM</code>, como
você preferir chamar) apenas usando as utilidades que as Monads nos
oferecem. Por isso, podemos concluir que as Monads são mais fortes que
os simples e velhos Functors.</p>
<p>A typeclass <code>Applicative</code> nos permite aplicar funções
entre valores com contextos como se fossem valores normais. Assim:</p>
<p><code>{.haskell:hs} ghci&gt; (+) &lt;$&gt; Just 3 &lt;*&gt; Just 5 Just 8 ghci&gt; (+) &lt;$&gt; Just 3 &lt;*&gt; Nothing Nothing</code></p>
<p>Usar este estilo aplicativo torna as coisas bem fáceis. O
<code>&lt;$&gt;</code> é apenas o <code>fmap</code> e o
<code>&lt;*&gt;</code> é uma função da typeclass
<code>Applicative</code> que tem o seguinte tipo:</p>
<p><code>{.haskell:hs} (&lt;*&gt;) :: (Applicative f) =&gt; f (a -&gt; b) -&gt; f a -&gt; f b</code></p>
<p>Portanto, é parecido com o <code>fmap</code>, só que a própria função
está em um contexto. Temos que de alguma forma extraí-la do contexto e
mapeá-la sobre o valor <code>f a</code> para depois montar o contexto
novamente. Como todas as funções são curried no Haskell por padrão,
podemos usar a combinação de <code>&lt;$&gt;</code> e
<code>&lt;*&gt;</code> para aplicar funções que recebem vários
parâmetros entre valores aplicativos.</p>
<p>Acontece que, assim como o <code>fmap</code>, o
<code>&lt;*&gt;</code> também pode ser implementado usando apenas o que
a typeclass <code>Monad</code> nos dá. A função <code>ap</code> é
basicamente o <code>&lt;*&gt;</code>, só que tem uma restrição
<code>Monad</code> em vez de uma <code>Applicative</code>. Aqui está a
sua definição:</p>
<p><code>{.haskell:hs} ap :: (Monad m) =&gt; m (a -&gt; b) -&gt; m a -&gt; m b ap mf m = do     f &lt;- mf     x &lt;- m     return (f x)</code></p>
<p><code>mf</code> é um valor monádico cujo resultado é uma função. Como
a função está em um contexto, assim como o valor, pegamos a função do
contexto e a chamamos de <code>f</code>, depois pegamos o valor e o
chamamos de <code>x</code> e então finalmente aplicamos a função ao
valor e apresentamos isso como resultado. Aqui está uma demonstração
rápida:</p>
<p><code>{.haskell:hs} ghci&gt; Just (+3) &lt;*&gt; Just 4 Just 7 ghci&gt; Just (+3) `ap` Just 4 Just 7 ghci&gt; [(+1),(+2),(+3)] &lt;*&gt; [10,11] [11,12,12,13,13,14] ghci&gt; [(+1),(+2),(+3)] `ap` [10,11] [11,12,12,13,13,14]</code></p>
<p>Agora vemos que as Monads também são mais fortes que os aplicativos,
porque podemos usar as funções da <code>Monad</code> para implementar as
da <code>Applicative</code>. Na verdade, muitas vezes, quando se
descobre que um tipo é uma Monad, as pessoas primeiro escrevem uma Monad
instance e depois criam uma Applicative instance apenas dizendo que o
<code>pure</code> é o <code>return</code> e o <code>&lt;*&gt;</code> é o
<code>ap</code>. Da mesma forma, se você já tem uma Monad instance para
algo, pode dar a ela uma Functor instance apenas dizendo que o
<code>fmap</code> é o <code>liftM</code>.</p>
<p>A função <code>liftA2</code> é uma função de conveniência para
aplicar uma função entre dois valores aplicativos. Ela é definida
simplesmente assim:</p>
<p><code>{.haskell:hs} liftA2 :: (Applicative f) =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c liftA2 f x y = f &lt;$&gt; x &lt;*&gt; y</code></p>
<p>A função <code>liftM2</code> faz a mesma coisa, só que tem uma
restrição <code>Monad</code>. Também existem o <code>liftM3</code>,
<code>liftM4</code> e <code>liftM5</code>.</p>
<p>Vimos como as Monads são mais fortes que os aplicativos e Functors e
como, apesar de toda Monad ser um Functor e um Applicative Functor, elas
não têm necessariamente Functor e Applicative instances, por isso
examinamos os equivalentes monádicos das funções que os Functors e
Applicative Functors usam.</p>
<h3>A função join</h3>
<p>Aqui está algo para se pensar: se o resultado de um monadic value é
outro monadic value, ou seja, se um monadic value está aninhado dentro
de outro, você pode achatá-los para apenas um único monadic value
normal? Por exemplo, se tivermos <code>Just (Just 9)</code>, podemos
transformar isso em <code>Just 9</code>? Acontece que qualquer monadic
value aninhado pode ser achatado e que essa é, na verdade, uma
propriedade única das Monads. Para isso, existe a função
<code>join</code>. O seu tipo é este:</p>
<p><code>{.haskell:hs} join :: (Monad m) =&gt; m (m a) -&gt; m a</code></p>
<p>Portanto, ela recebe um valor monádico dentro de um valor monádico e
nos dá apenas um valor monádico; ou seja, ela o achata de certa forma.
Aqui está ela com alguns valores <code>Maybe</code>:</p>
<p><code>{.haskell:hs} ghci&gt; join (Just (Just 9)) Just 9 ghci&gt; join (Just Nothing) Nothing ghci&gt; join Nothing Nothing</code></p>
<p>A primeira linha tem uma computação bem-sucedida como resultado de
uma computação bem-sucedida, então ambas são apenas unidas em uma única
computação bem-sucedida. A segunda linha apresenta um
<code>Nothing</code> como resultado de um valor <code>Just</code>.
Sempre que estávamos lidando com valores <code>Maybe</code> antes e
queríamos combinar vários deles em um só, fosse com
<code>&lt;*&gt;</code> ou <code>&gt;&gt;=</code>, todos tinham que ser
valores <code>Just</code> para que o resultado fosse um valor
<code>Just</code>. Se houvesse qualquer falha ao longo do caminho, o
resultado era uma falha, e o mesmo acontece aqui. Na terceira linha,
tentamos achatar o que é, desde o início, uma falha, de modo que o
resultado é uma falha também.</p>
<p>Achatar listas é bem intuitivo:</p>
<p><code>{.haskell:hs} ghci&gt; join [[1,2,3],[4,5,6]] [1,2,3,4,5,6]</code></p>
<p>Como você pode ver, para listas, <code>join</code> é apenas
<code>concat</code>. Para achatar um valor <code>Writer</code> cujo
resultado é um valor <code>Writer</code> por si só, temos que usar o
<code>mappend</code> no valor monóide.</p>
<p><code>{.haskell:hs} ghci&gt; runWriter $ join (Writer (Writer (1,"aaa"),"bbb")) (1,"bbbaaa")</code></p>
<p>O valor monóide externo <code>"bbb"</code> vem primeiro e depois
<code>"aaa"</code> é anexado a éle. Intuitivamente falando, quando você
quer examinar qual é o resultado de um valor <code>Writer</code>, você
tem que escrever seu valor monóide no log primeiro e só então pode
examinar o que ele tem dentro.</p>
<p>Achatar valores <code>Either</code> é muito semelhante a achatar
valores <code>Maybe</code>:</p>
<p><code>{.haskell:hs} ghci&gt; join (Right (Right 9)) :: Either String Int Right 9 ghci&gt; join (Right (Left "erro")) :: Either String Int Left "erro" ghci&gt; join (Left "erro") :: Either String Int Left "erro"</code></p>
<p>Se aplicarmos o <code>join</code> a uma computação estatal cujo
resultado é uma computação estatal por si só, o resultado é uma
computação estatal que executa primeiro a computação estatal externa e
depois a resultante. Veja:</p>
<p><code>{.haskell:hs} ghci&gt; runState (join (State $ \s -&gt; (push 10,1:2:s))) [0,0,0] ((),[10,1,2,0,0,0])</code></p>
<p>O lambda aqui recebe um estado e coloca <code>2</code> e
<code>1</code> na pilha e apresenta <code>push 10</code> como seu
resultado. Portanto, quando tudo isso é achatado com <code>join</code> e
depois executado, ele primeiro coloca <code>2</code> e <code>1</code> na
pilha e depois o <code>push 10</code> é realizado, colocando um
<code>10</code> no topo.</p>
<p>A implementação do <code>join</code> é a seguinte:</p>
<p><code>{.haskell:hs} join :: (Monad m) =&gt; m (m a) -&gt; m a join mm = do     m &lt;- mm     m</code></p>
<p>Como o resultado de <code>mm</code> é um valor monádico, pegamos esse
resultado e o colocamos em uma linha própria, pois se trata de um valor
monádico. O truque aqui é que, quando fazemos <code>m &lt;- mm</code>, o
contexto da mônada em que estamos é cuidado. É por isso que, por
exemplo, valores <code>Maybe</code> resultam em valores
<code>Just</code> apenas se os valores externo e interno forem ambos
valores <code>Just</code>. Aqui está como ficaria se o valor
<code>mm</code> fosse definido antecipadamente como
<code>Just (Just 8)</code>:</p>
<p><code>{.haskell:hs} joinedMaybes :: Maybe Int joinedMaybes = do     m &lt;- Just (Just 8)     m</code></p>
<p><img src="assets/images/for-a-few-monads-more/tipi.png"
alt="eu também sou um guarda também" />{.right width=253 height=379}</p>
<p>Talvez a coisa mais interessante sobre a <code>join</code> é que,
para toda Monad, alimentar um monadic value a uma função com
<code>&gt;&gt;=</code> é a mesma coisa que apenas mapear essa função
sobre o valor e depois usar o <code>join</code> para achatar o monadic
value aninhado resultante! Em outras palavras,
<code>m &gt;&gt;= f</code> é sempre a mesma coisa que
<code>join (fmap f m)</code>! Faz sentido quando você pensa sobre isso.
Com o <code>&gt;&gt;=</code>, estamos sempre pensando em como alimentar
um monadic value para uma função que recebe um valor normal mas retorna
um monadic value. Se apenas mapearmos essa função sobre o monadic value,
teremos um monadic value dentro de outro monadic value. Por exemplo,
digamos que tenhamos <code>Just 9</code> e a função
<code>\x -&gt; Just (x+1)</code>. Se mapearmos esta função sobre
<code>Just 9</code>, ficaremos com <code>Just (Just 10)</code>.</p>
<p>O fato de <code>m &gt;&gt;= f</code> ser sempre igual a
<code>join (fmap f m)</code> é muito útil se estivermos criando nossa
própria Monad instance para algum tipo, porque muitas vezes é mais fácil
descobrir como achatar um monadic value aninhado do que descobrir como
implementar o <code>&gt;&gt;=</code>.</p>
<h3>filterM</h3>
<p>A função <code>filter</code> é praticamente o pão de cada dia da
programação Haskell (<code>map</code> sendo a manteiga). Ela recebe um
predicado e uma lista para filtrar e então retorna uma nova lista onde
apenas os elementos que satisfazem o predicado são mantidos. O seu tipo
é este:</p>
<p><code>{.haskell:hs} filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</code></p>
<p>O predicado recebe um elemento da lista e retorna um valor
<code>Bool</code>. Agora, e se o valor <code>Bool</code> que ele
retornasse fosse na verdade um monadic value? Uau! Ou seja, e se ele
viesse com um contexto? Poderia funcionar? Por exemplo, e se cada valor
<code>True</code> ou <code>False</code> que o predicado produzisse
também tivesse um Monoid acompanhante, como
<code>["Aceitou o numero 5"]</code> ou
<code>["3 e muito pequeno"]</code>? Parece que poderia funcionar. Se
fosse esse o caso, esperaríamos que a lista resultante também viesse com
um log de todos os valores de log que foram produzidos ao longo do
caminho. Portanto, se o <code>Bool</code> que o predicado retornasse
viesse com um contexto, esperaríamos que a lista final resultante também
tivesse algum contexto anexado, caso contrário o contexto com o qual
cada <code>Bool</code> veio seria perdido.</p>
<p>A função <code>filterM</code> de <code>Control.Monad</code> faz
exatamente o que queremos! O seu tipo é este:</p>
<p><code>{.haskell:hs} filterM :: (Monad m) =&gt; (a -&gt; m Bool) -&gt; [a] -&gt; m [a]</code></p>
<p>O predicado retorna um monadic value cujo resultado é um
<code>Bool</code>, mas como é um monadic value, seu contexto pode ser
qualquer coisa, desde uma falha possível até o não-determinismo e muito
mais! Para garantir que o contexto seja refletido no resultado final, o
resultado também é um monadic value.</p>
<p>Vamos pegar uma lista e manter apenas os valores menores que 4. Para
começar, usaremos apenas a função <code>filter</code> normal:</p>
<p><code>{.haskell:hs} ghci&gt; filter (\x -&gt; x &lt; 4) [9,1,5,2,10,3] [1,2,3]</code></p>
<p>Isso é bem fácil. Agora, vamos criar um predicado que, além de
apresentar um resultado <code>True</code> ou <code>False</code>, também
forneça um log do que fez. É claro que usaremos a mônada
<code>Writer</code> para isso:</p>
<p><code>{.haskell:hs} keepSmall :: Int -&gt; Writer [String] Bool keepSmall x     | x &lt; 4 = do         tell ["Mantendo " ++ show x]         return True     | otherwise = do         tell [show x ++ " e muito grande, jogando fora"]         return False</code></p>
<p>Em vez de apenas retornar um <code>Bool</code>, esta função retorna
um <code>Writer [String] Bool</code>. É um predicado monádico. Parece
sofisticado, não é? Se o número for menor que <code>4</code>, relatamos
que o estamos mantendo e depois damos um <code>return True</code>.</p>
<p>Agora, vamos passá-lo para o <code>filterM</code> junto com uma
lista. Como o predicado retorna um valor <code>Writer</code>, a lista
resultante também será um valor <code>Writer</code>.</p>
<p><code>{.haskell:hs} ghci&gt; fst $ runWriter $ filterM keepSmall [9,1,5,2,10,3] [1,2,3]</code></p>
<p>Examinando o resultado do valor <code>Writer</code> resultante, vemos
que está tudo em ordem. Agora, vamos imprimir o log e ver o que
obtivemos:</p>
<p><code>{.haskell:hs} ghci&gt; mapM_ putStrLn $ snd $ runWriter $ filterM keepSmall [9,1,5,2,10,3] 9 e muito grande, jogando fora Mantendo 1 5 e muito grande, jogando fora Mantendo 2 10 e muito grande, jogando fora Mantendo 3</code></p>
<p>Incrível. Assim, apenas fornecendo um predicado monádico para o
<code>filterM</code>, fomos capazes de filtrar uma lista aproveitando o
contexto monádico que usamos.</p>
<p>Um truque de Haskell muito legal é usar <code>filterM</code> para
obter o conjunto das partes (<em>powerset</em>) de uma lista (se
pensarmos nela como conjuntos por enquanto). O conjunto das partes de
algum conjunto é o conjunto de todos os subconjuntos desse conjunto.
Portanto, se tivermos um conjunto como <code>[1,2,3]</code>, seu
conjunto das partes incluiria os seguintes conjuntos:</p>
<p><code>{.haskell:hs} [1,2,3] [1,2] [1,3] [1] [2,3] [2] [3] []</code></p>
<p>Em outras palavras, obter um conjunto das partes é como obter todas
as combinações de manter e descartar elementos de um conjunto.
<code>[2,3]</code> é como o conjunto original, só que excluímos o número
<code>1</code>.</p>
<p>Para fazer uma função que retorna o conjunto das partes de uma lista,
vamos contar com o não-determinismo. Pegamos a lista
<code>[1,2,3]</code> e então olhamos para o primeiro elemento, que é
<code>1</code>, e nos perguntamos: devemos mantê-lo ou descartá-lo? Bem,
gostaríamos de fazer ambos na verdade. Portanto, simularemos a filtragem
de uma lista e usaremos um predicado que, de forma não-determinística,
tanto mantém quanto descarta cada elemento da lista. Aqui está a nossa
função <code>powerset</code>:</p>
<p><code>{.haskell:hs} powerset :: [a] -&gt; [[a]] powerset xs = filterM (\x -&gt; [True, False]) xs</code></p>
<p>Espere, é só isso? Sim. Escolhemos descartar e manter cada elemento,
independentemente de qual seja esse elemento. Temos um predicado
não-determinístico, de modo que a lista resultante também será um valor
não-determinístico e será, portanto, uma lista de listas. Vamos
testar:</p>
<p><code>{.haskell:hs} ghci&gt; powerset [1,2,3] [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]</code></p>
<p>Isso exige um pouco de reflexão para entender, mas se você apenas
considerar as listas como valores não-determinísticos que não sabem o
que ser e então decidem ser tudo de uma vez, fica um pouco mais
fácil.</p>
<h3>foldM</h3>
<p>A contraparte monádica do <code>foldl</code> é o <code>foldM</code>.
Se você se lembra do seu <code>foldl</code>, ele recebia uma função
binária, um acumulador inicial e uma lista para dobrar e então reduzia a
lista a um único valor dobrando a função binária sobre a lista a partir
da esquerda. O <code>foldM</code> faz a mesma coisa, só que recebe uma
função binária que produz um resultado monádico e então dobra a lista
com essa função. O seu tipo é este:</p>
<p><code>{.haskell:hs} foldM :: (Monad m) =&gt; (a -&gt; b -&gt; m a) -&gt; a -&gt; [b] -&gt; m a</code></p>
<p>O valor retornado pela função binária é monádico e, portanto, o
resultado de toda a dobra também é monádico. Vamos pegar uma lista e
dobrá-la, mas em vez de apenas somar os números, vamos garantir que a
soma nunca ultrapasse <code>100</code>. Se a soma ultrapassar
<code>100</code>, falharemos.</p>
<p><code>{.haskell:hs} binSmalls :: Int -&gt; Int -&gt; Maybe Int binSmalls acc x     | x &gt; 9 = Nothing     | otherwise = Just (acc + x)</code></p>
<p>Nossa função binária recebe um acumulador e um elemento da lista e,
se o elemento for maior que <code>9</code>, ela falha retornando
<code>Nothing</code>, caso contrário, ela retorna a soma envolta em um
<code>Just</code>. Agora, vamos usá-la com o <code>foldM</code>:</p>
<p><code>{.haskell:hs} ghci&gt; foldM binSmalls 0 [2,8,3,1] Just 14 ghci&gt; foldM binSmalls 0 [2,11,3,1] Nothing</code></p>
<p>Se qualquer etapa da dobra falhar, todo o <code>foldM</code> resulta
em uma falha.</p>
<p>Logicamente, se usarmos um <code>Writer</code> como a Monad para o
<code>foldM</code>, o log resultante conterá tudo o que foi registrado
em cada etapa da dobra. E se usarmos uma lista como a Monad, o
<code>foldM</code> pode ser usado para dobras não-determinísticas, o que
é bem legal.</p>
<h2>Criando uma calculadora RPN segura {#safe-rpn-calculator}</h2>
<p>Quando resolvemos o problema de <a
href="functionally-solving-problems.html#reverse-polish-notation-calculator">implementar
uma calculadora RPN</a>, mencionamos que ela funcionava bem desde que a
entrada fizesse sentido. No entanto, se algo desse errado, todo o nosso
programa falharia. Agora que aprendemos sobre as Monads e o
<code>Maybe</code> em particular, vamos ver como podemos adicionar
tratamento de erro à nossa calculadora RPN.</p>
<p>Nós a implementamos fazendo um <code>foldl</code> sobre uma lista de
itens. No início, a pilha estava vazia e cada item da entrada era
processado um por um. Se fosse um número, ele era empilhado; se fosse um
operador, os dois números do topo eram desempilhados e opados e o
resultado era empilhado de volta.</p>
<p>Lembre-se da nossa implementação original:</p>
<p>```{.haskell:hs} import Data.List</p>
<p>solveRPN :: String -&gt; Double solveRPN = head . foldl
foldingFunction [] . words ```</p>
<p>E a função de dobra:</p>
<p><code>{.haskell:hs} foldingFunction :: [Double] -&gt; String -&gt; [Double] foldingFunction (x:y:ys) "*" = (x * y):ys foldingFunction (x:y:ys) "+" = (x + y):ys foldingFunction (x:y:ys) "-" = (y - x):ys foldingFunction xs numberString = read numberString:xs</code></p>
<p>Dobragem da esquerda para a direita, acumulador sendo a pilha. Agora,
vamos torná-la segura! Primeiro, vamos fazer de modo que a
<code>foldingFunction</code> possa falhar graciosamente. O seu tipo
mudará de <code>[Double] -&gt; String -&gt; [Double]</code> para
<code>[Double] -&gt; String -&gt; Maybe [Double]</code>. Isso significa
que ela retornará <code>Nothing</code> se algo der errado ou
<code>Just novaPilha</code> se tudo correr bem.</p>
<p>A função <code>read</code>, que usamos para converter strings em
números, falha e trava o nosso programa se a string não for um número
válido. Para corrigir isso, usaremos <code>reads</code>, que é como o
<code>read</code>, só que retorna uma lista com o resultado da leitura e
o resto da string se a leitura foi bem-sucedida ou uma lista vazia se
falhou. Podemos usá-la para fazer uma função que tenta ler uma string
como um número e, se conseguir, retorna um <code>Just numero</code>:</p>
<p><code>{.haskell:hs} readMaybe :: (Read a) =&gt; String -&gt; Maybe a readMaybe st = case reads st of [(x,"")] -&gt; Just x                                 _ -&gt; Nothing</code></p>
<p>Vamos testar:</p>
<p><code>{.haskell:hs} ghci&gt; readMaybe "1" :: Maybe Int Just 1 ghci&gt; readMaybe "GO TO HELL" :: Maybe Int Nothing</code></p>
<p>Parece que funciona. Agora, vamos reescrever nossa
<code>foldingFunction</code> para ser uma monadic function:</p>
<p><code>{.haskell:hs} foldingFunction :: [Double] -&gt; String -&gt; Maybe [Double] foldingFunction (x:y:ys) "*" = return ((x * y):ys) foldingFunction (x:y:ys) "+" = return ((x + y):ys) foldingFunction (x:y:ys) "-" = return ((y - x):ys) foldingFunction xs numberString = liftM (:xs) (readMaybe numberString)</code></p>
<p>As três primeiras linhas, que cuidam dos operadores, agora retornam
monadic values (usamos o <code>return</code> para envolver a nova pilha
em um <code>Just</code>). A última linha tenta ler a string como um
número e, se conseguir, coloca esse número no topo da pilha. Usamos o
<code>liftM</code> para aplicar o operador de construção de lista ao
resultado de <code>readMaybe</code>.</p>
<p>Agora que temos uma monadic folding function, usaremos o
<code>foldM</code> em vez do <code>foldl</code>. Veja como fica:</p>
<p><code>{.haskell:hs} solveRPN :: String -&gt; Maybe Double solveRPN st = do     [result] &lt;- foldM foldingFunction [] (words st)     return result</code></p>
<p>Usamos a notação <code>do</code> para obter o resultado da dobra
monádica. Como a dobra retorna um <code>Maybe [Double]</code>, se tudo
correu bem, terminamos com uma lista contendo um único elemento, que é o
resultado. Usamos o pattern matching <code>[result]</code> para extrair
esse elemento. Se a dobra resultar em um <code>Nothing</code>, o
resultado geral também será um <code>Nothing</code>. Se o resultado da
dobra for uma lista que não tem exatamente um elemento, o pattern match
falhará e a mônada <code>Maybe</code> cuidará disso para nós, retornando
um <code>Nothing</code>.</p>
<p><code>{.haskell:hs} ghci&gt; solveRPN "1 2 * 4 +" Just 6.0 ghci&gt; solveRPN "1 2 * 4 + 5 *" Just 30.0 ghci&gt; solveRPN "1 2 * 4" Nothing ghci&gt; solveRPN "1 8 blabla" Nothing</code></p>
<p>A primeira falha acontece porque a pilha final tinha dois elementos
(<code>[4.0,2.0]</code>), então o pattern match falhou. A segunda falha
acontece porque "blabla" não é um número.</p>
<p>Nossa calculadora RPN agora é muito mais robusta! Ela pode lidar com
erros de entrada sem explodir. E tudo isso graças ao <code>foldM</code>
e ao contexto de falha possível oferecido pela Maybe Monad.</p>
<h2>Composição de monadic functions {#composing-monadic-functions}</h2>
<p>Ao aprender sobre as Monad laws, aprendemos sobre a função
<code>&lt;=&lt;</code>, que é como a composição normal de funções, porém
em vez de funcionar com funções normais do tipo <code>a -&gt; b</code>,
ela funciona com monadic functions do tipo <code>a -&gt; m b</code>. Por
exemplo:</p>
<p><code>{.haskell:hs} ghci&gt; let f = (+1) . (*100) ghci&gt; f 4 401 ghci&gt; let g = (\x -&gt; return (x+1)) &lt;=&lt; (\x -&gt; return (x*100)) ghci&gt; Just 4 &gt;&gt;= g Just 401</code></p>
<p>Neste exemplo, primeiro compusemos duas funções normais, aplicamos o
resultado a <code>4</code> e depois fizemos o mesmo com monadic
functions usando <code>&lt;=&lt;</code> e alimentamos o monadic result
com <code>&gt;&gt;=</code>.</p>
<p>Se tivermos um monte de funções em uma lista, podemos compô-las todas
em uma única função gigante usando o <code>foldr</code> e a função de
composição normal.</p>
<p><code>{.haskell:hs} ghci&gt; let f = foldr (.) id [(+1),(*100),(+5)] ghci&gt; f 1 106</code></p>
<p>A função <code>f</code> recebe um número, soma <code>5</code> a ele,
multiplica o resultado por <code>100</code> e depois soma
<code>1</code>. Podemos fazer o mesmo para monadic functions, só que
usamos o <code>&lt;=&lt;</code> em vez de <code>.</code> e o
<code>return</code> em vez de <code>id</code>. Não precisamos nem mesmo
de uma contraparte monádica do <code>foldr</code>, porque o
<code>foldr</code> funciona para qualquer tipo, e o tipo das nossas
monadic functions é <code>a -&gt; m a</code>.</p>
<p><code>{.haskell:hs} ghci&gt; let f = foldr (&lt;=&lt;) return [(\x -&gt; [x,x]),(\x -&gt; [x,x,x])] ghci&gt; f 4 [4,4,4,4,4,4]</code></p>
<p>A função <code>f</code> recebe um número e cria uma lista que o
contém três vezes, e depois essa lista é alimentada na função que
duplica os elementos.</p>
<p>No capítulo sobre as Monads, usamos esta técnica de compor muitas
monadic functions para resolver o problema de se o nosso cavalo de
xadrez poderia chegar a uma certa posição em três movimentos. Lá,
tínhamos uma função chamada <code>moveKnight</code>, que retornava todas
as posições possíveis onde o cavalo poderia estar após um movimento.
Então, para calcular todas as posições possíveis após três movimentos,
criamos a seguinte função:</p>
<p><code>{.haskell:hs} in3 start = return start &gt;&gt;= moveKnight &gt;&gt;= moveKnight &gt;&gt;= moveKnight</code></p>
<p>Para verificar se ele poderia chegar a uma posição <code>end</code>
começando em <code>start</code>, apenas verificávamos se
<code>end</code> estava na lista resultante.</p>
<p>Agora, e se quiséssemos fazer uma função que nos dissesse se o cavalo
pode chegar em <code>n</code> movimentos? Gostaríamos de uma função que
recebesse <code>n</code> e retornasse uma monadic function como
<code>moveKnight</code>, mas que em vez de um movimento, fizesse
<code>n</code> movimentos. O <code>foldr</code> e o
<code>&lt;=&lt;</code> são perfeitos para isso:</p>
<p>```{.haskell:hs} import Control.Monad</p>
<p>canReachIn :: Int -&gt; KnightPos -&gt; KnightPos -&gt; Bool
canReachIn n start end = end <code>elem</code> res where res = res
(foldr (&lt;=&lt;) return (replicate n moveKnight)) start ```</p>
<p>Primeiro usamos o <code>replicate</code> para criar uma lista de
tamanho <code>n</code> contendo a função <code>moveKnight</code>. Em
seguida, compusemos todas essas funções monádicas em uma só e aplicamos
a posição inicial à função resultante.</p>
<h2>Criando Monads {#making-monads}</h2>
<p>Nesta seção, vamos ver um exemplo de como um tipo é criado,
identificado como um Functor e, em seguida, recebe Applicative e Monad
instances.</p>
<p>Digamos que queiramos modelar valores não-determinísticos como
listas, mas queiramos deixar claro que alguns resultados são mais
prováveis que outros. Se pensarmos que <code>[3,5,9]</code> é um valor
não-determinístico, poderíamos vê-lo como um valor que é <code>3</code>,
<code>5</code> e <code>9</code> ao mesmo tempo. Mas e se quiséssemos
dizer que há 50% de chance de ele ser <code>3</code> e 25% de chance de
ser <code>5</code> ou <code>9</code>?</p>
<p><img src="assets/images/for-a-few-monads-more/dice.png"
alt="probabilidade" />{.left width=200 height=200}</p>
<p>Para modelar isso, representaremos um valor com sua probabilidade
como um par, onde o primeiro componente do par é o valor e o segundo é a
probabilidade. Para representar uma lista de probabilidades, basta
termos uma lista de tais pares.</p>
<p><code>{.haskell:hs} [(3,0.5),(5,0.25),(9,0.25)]</code></p>
<p>Em Haskell, as probabilidades são representadas por números de ponto
flutuante, mas os números racionais (como os do módulo
<code>Data.Ratio</code>) são muito adequados para probabilidades porque
são precisos e não apresentam os erros de arredondamento inerentes aos
<code>Double</code>. Por isso, usaremos <code>Rational</code>.</p>
<p>```{.haskell:hs} import Data.Ratio</p>
<p>ghci&gt; 1%4 1 % 4 ghci&gt; 1%2 + 1%2 1 % 1 ghci&gt; 1%3 + 5%4 19 %
12 ```</p>
<p>Como já temos listas para representar o não-determinismo, e o que
estamos fazendo aqui é apenas adicionar uma probabilidade a cada item da
lista, vamos dar um nome ao nosso novo tipo.</p>
<p><code>{.haskell:hs} newtype Prob a = Prob { getProb :: [(a,Rational)] } deriving Show</code></p>
<p>Tudo bem, este é o nosso tipo. Ele é um functor? Bem, a lista é um
functor, então este provavelmente também é, já que apenas adicionamos
algo aos elementos da lista. Quando mapeamos uma função sobre uma lista,
nós a aplicamos a cada elemento. Aqui, faremos o mesmo, mas manteremos a
probabilidade intacta.</p>
<p><code>{.haskell:hs} instance Functor Prob where     fmap f (Prob xs) = Prob $ map (\(x,p) -&gt; (f x,p)) xs</code></p>
<p>Mapeamos a função sobre os valores, deixando as probabilidades como
estão. Vamos ver se funciona:</p>
<p><code>{.haskell:hs} ghci&gt; fmap negate (Prob [(3,1%2),(5,1%4),(9,1%4)]) Prob {getProb = [(-3,1 % 2),(-5,1 % 4),(-9,1 % 4)]}</code></p>
<p>Agora, e quanto à sua Monad instance? Bem, antes de podermos torná-la
uma <code>Monad</code>, ela também precisa ser um Applicative Functor.
Como já aprendemos, poderíamos apenas usar o <code>return</code> e o
<code>ap</code> para isso, mas como vamos implementar as funções da
Monad de qualquer maneira, vamos fazê-lo agora.</p>
<p>O <code>return</code> é fácil. Ele tem que pegar um valor e colocá-lo
em um contexto mínimo. O que seria uma probabilidade mínima para um
valor? Se o valor tem que ser exatamente esse valor, sua probabilidade
deve ser <code>1</code> (ou seja, 100%).</p>
<p><code>{.haskell:hs} return x = Prob [(x,1%1)]</code></p>
<p>E o <code>&gt;&gt;=</code>? O <code>&gt;&gt;=</code> recebe um valor
monádico e uma função que retorna um valor monádico e tem que nos dar um
novo valor monádico. No nosso caso, o valor monádico é uma lista de
resultados com probabilidades. A função pegará um resultado e o
transformará em outra lista de resultados com probabilidades.</p>
<p>Considere este exemplo: temos um valor que tem 25% de chance de ser
<code>'a'</code> e 75% de chance de ser <code>'b'</code>. Se for
<code>'a'</code>, há 10% de chance de que ele se torne <code>1</code> e
90% de chance de se tornar <code>2</code>. Se for <code>'b'</code>, há
50% de chance de se tornar tanto <code>3</code> quanto <code>4</code>.
Qual é a probabilidade total de obter cada um destes números?</p>
<p>Para descobrir isso, só temos que multiplicar as probabilidades. Se
tivermos 25% de chance de obter <code>'a'</code>, ficaremos com 2,5%
(0,25 * 0,10) de chance de obter <code>1</code>. O mesmo vale para o
restante.</p>
<p>O <code>&gt;&gt;=</code> para a nossa mônada de probabilidade será
agora fácil. Primeiro mapeamos a função sobre o nosso valor
<code>Prob a</code>. Isso nos dá um <code>Prob (Prob b)</code>. Se
apenas achatar isso, ou seja, se calcularmos o <code>join</code> dele,
teremos o nosso resultado.</p>
<p>Mas antes de escrever o <code>&gt;&gt;=</code>, vamos escrever o
<code>flatten</code>, que achata um <code>Prob (Prob a)</code> em um
<code>Prob a</code>.</p>
<p><code>{.haskell:hs} flatten :: Prob (Prob a) -&gt; Prob a flatten (Prob xs) = Prob $ concat $ map multAll xs     where multAll (Prob innerxs,p) = map (\(x,r) -&gt; (x,p*r)) innerxs</code></p>
<p>Recebemos uma lista de probabilidades de probabilidades
(<code>xs</code>). Para cada uma delas, chamamos o par
<code>(Prob innerxs, p)</code>. Então, multiplicamos a probabilidade
<code>p</code> por cada uma das probabilidades internas em
<code>innerxs</code> e retornamos essa lista. Ao final, apenas
concatenamos tudo isso em uma única lista grande.</p>
<p>Agora podemos escrever a nossa Monad instance:</p>
<p><code>{.haskell:hs} instance Monad Prob where     return x = Prob [(x,1%1)]     m &gt;&gt;= f = flatten (fmap f m)     fail _ = Prob []</code></p>
<p>Como já tínhamos o <code>flatten</code>, o <code>&gt;&gt;=</code> foi
apenas uma questão de usá-lo junto com o <code>fmap</code>, conforme
aprendemos anteriormente. Agora que temos a Monad, vamos ver o que
podemos fazer com ela!</p>
<p>Digamos que tenhamos duas moedas viciadas. Uma tem 10% de chance de
dar cara e a outra tem 75% de chance. Se jogarmos ambas, qual a
probabilidade de ambas darem cara? Primeiro, vamos representar as
moedas:</p>
<p>```{.haskell:hs} data Coin = Heads | Tails deriving (Show, Eq)</p>
<p>coin :: Prob Coin coin = Prob [(Heads,1%10),(Tails,9%10)]</p>
<p>loadedCoin :: Prob Coin loadedCoin = Prob [(Heads,1%2),(Tails,1%2)]
```</p>
<p>E agora, o lançamento:</p>
<p>```{.haskell:hs} import Data.List (all)</p>
<p>flipTwo :: Prob Bool flipTwo = do a &lt;- coin b &lt;- loadedCoin
return (all (==Heads) [a,b]) ```</p>
<p>Vamos ver o resultado:</p>
<p><code>{.haskell:hs} ghci&gt; getProb flipTwo [(True,1 % 20),(False,1 % 20),(False,9 % 20),(False,9 % 20)]</code></p>
<p>Se somarmos todos os resultados <code>False</code>, veremos que a
probabilidade de não obtermos duas caras é de 19/20, que é 95%.
Portanto, a probabilidade de ambas serem cara é de 5%.</p>
<p>Vimos como as Monads podem nos ajudar a modelar problemas complexos
de uma maneira que parece muito natural e elegante. O poder de abstração
das Monads nos permite focar na lógica do nosso problema enquanto o
contexto (seja ele falha, estado, log ou probabilidade) é tratado
automaticamente por baixo dos panos.</p>
<p>Esperamos que, depois deste capítulo (e do anterior), você tenha uma
compreensão sólida do que as Monads são, de como elas funcionam e de por
que elas são tão importantes no mundo do Haskell. Elas não são tão
assustadoras quanto parecem à primeira vista, e assim que você começa a
usá-las, fica difícil imaginar a programação funcional sem elas!</p>
            </article>
<div class="footdiv">
    <ul>
<li class="prev"><a href="a-fistful-of-monads.html">Anterior</a></li>
        <li class="toc"><a href="index.html">Sumário</a></li>
<li class="next"><a href="zippers.html">Próximo</a></li>
    </ul>
</div>

        </div>
    </div>
    <script type="text/javascript" src="sh/Scripts/shCore.js"></script>
    <script type="text/javascript" src="sh/Scripts/shBrushHaskell.js"></script>
    <script type="text/javascript" src="sh/Scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="assets/js/toggleShow.js"></script>
    <script type="text/javascript">
        dp.SyntaxHighlighter.HighlightAll('code');
    </script>
</body>
</html>
