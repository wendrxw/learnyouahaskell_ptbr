<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aprenda Haskell para o Bem de Todos!</title>
    <link rel="stylesheet" href="assets/css/reset.css" type="text/css" />
    <link rel="stylesheet" href="assets/css/style.css" type="text/css" />
    <link rel="stylesheet" href="sh/Styles/SyntaxHighlighter.css" type="text/css" />
    <link rel="shortcut icon" href="assets/images/favicon.png" type="image/png" />
</head>
<body class="introcontent">
    <div class="bgwrapper">
        <div id="content">
<div class="footdiv" style="margin-bottom:25px;">
    <ul>
        <li style="text-align:left">
<a href="starting-out.html">Anterior (Começando)</a>
        </li>
        <li style="text-align:center">
            <a href="chapters.html">Índice de capítulos</a>
        </li>
        <li style="text-align:right">
<a href="syntax-in-functions.html" class="nxtlink">Próximo (Sintaxe em Funções)</a>
        </li>
    </ul>
</div>

            <article>
<h1 id="tipos-e-typeclasses">Tipos e Typeclasses</h1>
<h2 id="believe-the-type">Acredite no tipo (Believe the type)</h2>
<p><img src="assets/images/types-and-typeclasses/cow.png" class="left"
width="180" height="127" alt="moo" /></p>
<p>Anteriormente, mencionamos que o Haskell possui um sistema de tipos
estático. O tipo de cada expressão é conhecido em tempo de compilação, o
que leva a um código mais seguro. Se você escrever um programa onde
tenta dividir um tipo booleano por algum número, ele nem compilará. Isso
é bom porque é melhor detectar esses erros em tempo de compilação do que
ter seu programa travando. Tudo em Haskell tem um tipo, então o
compilador pode raciocinar bastante sobre seu programa antes de
compilá-lo.</p>
<p>Ao contrário de Java ou Pascal, Haskell possui inferência de tipo. Se
escrevermos um número, não precisamos dizer a Haskell que é um número.
Ele pode <em>inferir</em> isso por conta própria, portanto, não
precisamos escrever explicitamente os tipos de nossas funções e
expressões para fazer as coisas. Cobrimos alguns dos fundamentos do
Haskell com apenas uma visão muito superficial dos tipos. No entanto,
entender o sistema de tipos é uma parte muito importante do aprendizado
de Haskell.</p>
<p>Um tipo é uma espécie de rótulo que toda expressão possui. Ele nos
diz em qual categoria de coisas essa expressão se encaixa. A expressão
<code>True</code> é um booleano, <code>"hello"</code> é uma string,
etc.</p>
<p>Agora usaremos o GHCI para examinar os tipos de algumas expressões.
Faremos isso usando o comando <code>:t</code> que, seguido por qualquer
expressão válida, nos diz seu tipo. Vamos dar uma volta.</p>
<pre class="haskell: ghci"><code>ghci&gt; :t &#39;a&#39;
&#39;a&#39; :: Char
ghci&gt; :t True
True :: Bool
ghci&gt; :t &quot;HELLO!&quot;
&quot;HELLO!&quot; :: [Char]
ghci&gt; :t (True, &#39;a&#39;)
(True, &#39;a&#39;) :: (Bool, Char)
ghci&gt; :t 4 == 5
4 == 5 :: Bool</code></pre>
<p><img src="assets/images/types-and-typeclasses/bomb.png" class="right"
width="171" height="144" alt="bomb" /> Aqui vemos que fazer
<code>:t</code> em uma expressão imprime a expressão seguida por
<code>::</code> e seu tipo. <code>::</code> é lido como “tem o tipo de”.
Tipos explícitos são sempre denotados com a primeira letra em maiúscula.
<code>'a'</code>, ao que parece, tem um tipo de <code>Char</code>. Não é
difícil concluir que significa <em>caractere</em>. <code>True</code> é
do tipo <code>Bool</code>. Isso faz sentido. Mas o que é isso? Examinar
o tipo de <code>"HELLO!"</code> produz um <code>[Char]</code>. Os
colchetes denotam uma lista. Então lemos isso como sendo <em>uma lista
de caracteres</em>. Ao contrário das listas, cada tamanho de tupla tem
seu próprio tipo. Portanto, a expressão <code>(True, 'a')</code> tem um
tipo de <code>(Bool, Char)</code>, enquanto uma expressão como
<code>('a', 'b', 'c')</code> teria o tipo de
<code>(Char, Char, Char)</code>. <code>4 == 5</code> sempre retornará
<code>False</code>, então seu tipo é <code>Bool</code>.</p>
<p>Funções também têm tipos. Ao escrever nossas próprias funções,
podemos optar por dar-lhes uma declaração de tipo explícita. Isso
geralmente é considerado uma boa prática, exceto ao escrever funções
muito curtas. A partir daqui, daremos a todas as funções que fizermos
declarações de tipo. Lembra da compreensão de lista que fizemos
anteriormente que filtra uma string para que apenas as maiúsculas
permaneçam? Veja como fica com uma declaração de tipo.</p>
<pre class="haskell:hs"><code>removeNonUppercase :: [Char] -&gt; [Char]
removeNonUppercase st = [ c | c &lt;- st, c `elem` [&#39;A&#39;..&#39;Z&#39;]]</code></pre>
<p><code>removeNonUppercase</code> tem um tipo de
<code>[Char] -&gt; [Char]</code>, o que significa que mapeia de uma
string para uma string. Isso ocorre porque recebe uma string como
parâmetro e retorna outra como resultado. O tipo <code>[Char]</code> é
sinônimo de <code>String</code>, então é mais claro se escrevermos
<code>removeNonUppercase :: String -&gt; String</code>. Não precisávamos
dar a essa função uma declaração de tipo porque o compilador pode
inferir por si mesmo que é uma função de uma string para uma string, mas
fizemos assim mesmo. Mas como escrevemos o tipo de uma função que recebe
vários parâmetros? Aqui está uma função simples que pega três inteiros e
os soma:</p>
<pre class="haskell:hs"><code>addThree :: Int -&gt; Int -&gt; Int -&gt; Int
addThree x y z = x + y + z</code></pre>
<p>Os parâmetros são separados por <code>-&gt;</code> e não há distinção
especial entre os parâmetros e o tipo de retorno. O tipo de retorno é o
último item na declaração e os parâmetros são os três primeiros. Mais
tarde, veremos por que todos eles são apenas separados por
<code>-&gt;</code> em vez de ter alguma distinção mais explícita entre
os tipos de retorno e os parâmetros, como
<code>Int, Int, Int -&gt; Int</code> ou algo assim.</p>
<p>Se você quiser dar à sua função uma declaração de tipo, mas não tiver
certeza de qual deve ser, sempre poderá apenas escrever a função sem ela
e depois verificá-la com <code>:t</code>. Funções são expressões também,
então <code>:t</code> funciona nelas sem problemas.</p>
<p>Aqui está uma visão geral de alguns tipos comuns.</p>
<p><code class="label type">Int</code> significa inteiro. É usado para
números inteiros. <code>7</code> pode ser um <code>Int</code>, mas
<code>7.2</code> não pode.</p>
<h2 id="believe-the-type">Acredite no tipo</h2>
<p><code>Int</code> é limitado, o que significa que tem um valor mínimo
e um máximo. Geralmente em máquinas de 32 bits o máximo <code>Int</code>
possível é 2147483647 e o mínimo é -2147483648.</p>
<p><code class="label type">Integer</code> significa, er… também
inteiro. A principal diferença é que não é limitado, então pode ser
usado para representar números realmente muito grandes. Quero dizer,
muito grandes mesmo. <code>Int</code>, no entanto, é mais eficiente.</p>
<pre class="haskell:hs"><code>factorial :: Integer -&gt; Integer
factorial n = product [1..n]</code></pre>
<pre class="haskell: ghci"><code>ghci&gt; factorial 50
30414093201713378043612608166064768844377641568960512000000000000</code></pre>
<p><code class="label type">Float</code> é um ponto flutuante real com
precisão simples.</p>
<pre class="haskell:hs"><code>circumference :: Float -&gt; Float
circumference r = 2 * pi * r</code></pre>
<pre class="haskell: ghci"><code>ghci&gt; circumference 4.0
25.132742</code></pre>
<p><code class="label type">Double</code> é um ponto flutuante real com
o dobro da precisão!</p>
<pre class="haskell:hs"><code>circumference&#39; :: Double -&gt; Double
circumference&#39; r = 2 * pi * r</code></pre>
<pre class="haskell: ghci"><code>ghci&gt; circumference&#39; 4.0
25.132741228718345</code></pre>
<p><code class="label type">Bool</code> é um tipo booleano. Pode ter
apenas dois valores: <code>True</code> e <code>False</code>.</p>
<p><code class="label type">Char</code> representa um caractere. É
denotado por aspas simples. Uma lista de caracteres é uma string.</p>
<p>Tuplas são tipos, mas dependem de seu comprimento, bem como dos tipos
de seus componentes, portanto, teoricamente, há um número infinito de
tipos de tuplas, o que é demais para cobrir neste tutorial. Observe que
a tupla vazia <code class="label type">()</code> também é um tipo que
pode ter apenas um único valor: <code>()</code></p>
<h2 id="type-variables">Variáveis de tipo (Type variables)</h2>
<p>Qual você acha que é o tipo da função <code>head</code>? Como
<code>head</code> pega uma lista de qualquer tipo e retorna o primeiro
elemento, o que poderia ser? Vamos verificar!</p>
<pre class="haskell: ghci"><code>ghci&gt; :t head
head :: [a] -&gt; a</code></pre>
<p><img src="assets/images/types-and-typeclasses/box.png" class="left"
width="130" height="93" alt="box" /> Hmmm! O que é esse <code>a</code>?
É um tipo? Lembre-se de que declaramos anteriormente que os tipos são
escritos em letras maiúsculas, portanto, não pode ser exatamente um
tipo. Como não está em maiúsculas, na verdade é uma <strong>variável de
tipo</strong>. Isso significa que <code>a</code> pode ser de qualquer
tipo. Isso é muito parecido com genéricos em outras linguagens, só que
em Haskell é muito mais poderoso porque nos permite escrever facilmente
funções muito gerais se elas não usarem nenhum comportamento específico
dos tipos nelas. Funções que possuem variáveis de tipo são chamadas de
<strong>funções polimórficas</strong>. A declaração de tipo de
<code>head</code> afirma que ela recebe uma lista de qualquer tipo e
retorna um elemento desse tipo.</p>
<p>Embora as variáveis de tipo possam ter nomes com mais de um
caractere, geralmente damos a elas nomes como a, b, c, d …</p>
<p>Lembra de <code>fst</code>? Retorna o primeiro componente de um par.
Vamos examinar seu tipo.</p>
<pre class="haskell: ghci"><code>ghci&gt; :t fst
fst :: (a, b) -&gt; a</code></pre>
<p>Vemos que <code>fst</code> recebe uma tupla que contém dois tipos e
retorna um elemento que é do mesmo tipo que o primeiro componente do
par. É por isso que podemos usar <code>fst</code> em um par que contém
quaisquer dois tipos. Observe que apenas porque <code>a</code> e
<code>b</code> são variáveis de tipo diferentes, eles não precisam ser
tipos diferentes. Apenas afirma que o tipo do primeiro componente e o
tipo do valor de retorno são os mesmos.</p>
<h2 id="typeclasses-101">Typeclasses 101</h2>
<p><img src="assets/images/types-and-typeclasses/classes.png"
class="right" width="210" height="158" alt="class" /></p>
<p>Uma typeclass é uma espécie de interface que define algum
comportamento. Se um tipo faz parte de uma typeclass, isso significa que
ele suporta e implementa o comportamento que a typeclass descreve.
Muitas pessoas vindas de OOP (Programação Orientada a Objetos) ficam
confusas com typeclasses porque acham que são como classes em linguagens
orientadas a objetos. Bem, elas não são. Você pode pensar nelas como
interfaces Java, só que melhores.</p>
<p>Qual é a assinatura de tipo da função <code>==</code>?</p>
<pre class="haskell: ghci"><code>ghci&gt; :t (==)
(==) :: (Eq a) =&gt; a -&gt; a -&gt; Bool</code></pre>
<div class="hintbox">
<p><strong>Nota</strong>: o operador de igualdade, <code>==</code> é uma
função. Assim como <code>+</code>, <code>*</code>, <code>-</code>,
<code>/</code> e praticamente todos os operadores. Se o nome de uma
função for composto apenas por caracteres especiais, ela é considerada
uma função infixa por padrão. Se quisermos examinar seu tipo, passá-la
para outra função ou chamá-la como uma função prefixa, temos que
cercá-la entre parênteses.</p>
</div>
<p>Interessante. Vemos uma coisa nova aqui, o símbolo
<code>=&gt;</code>. Tudo antes do símbolo <code>=&gt;</code> é chamado
de <strong>restrição de classe</strong> (class constraint). Podemos ler
a declaração de tipo anterior assim: a função de igualdade recebe
quaisquer dois valores que sejam do mesmo tipo e retorna um
<code>Bool</code>. O tipo desses dois valores deve ser um membro da
classe <code>Eq</code> (esta era a restrição de classe).</p>
<p>A typeclass <code>Eq</code> fornece uma interface para testar a
igualdade. Qualquer tipo em que faça sentido testar a igualdade entre
dois valores desse tipo deve ser um membro da classe <code>Eq</code>.
Todos os tipos padrão de Haskell, exceto IO (o tipo para lidar com
entrada e saída) e funções, fazem parte da typeclass
<code>Eq</code>.</p>
<p>A função <code>elem</code> tem um tipo de
<code>(Eq a) =&gt; a -&gt; [a] -&gt; Bool</code> porque usa
<code>==</code> sobre uma lista para verificar se algum valor que
estamos procurando está nela.</p>
<p>Algumas typeclasses básicas:</p>
<p><code class="label class">Eq</code> é usado para tipos que suportam
teste de igualdade. As funções que seus membros implementam são
<code>==</code> e <code>/=</code>. Portanto, se houver uma restrição de
classe <code>Eq</code> para uma variável de tipo em uma função, ela usa
<code>==</code> ou <code>/=</code> em algum lugar dentro de sua
definição. Todos os tipos que mencionamos anteriormente, exceto funções,
fazem parte de <code>Eq</code>, então eles podem ser testados quanto à
igualdade.</p>
<pre class="haskell: ghci"><code>ghci&gt; 5 == 5
True
ghci&gt; 5 /= 5
False
ghci&gt; &#39;a&#39; == &#39;a&#39;
True
ghci&gt; &quot;Ho Ho&quot; == &quot;Ho Ho&quot;
True
ghci&gt; 3.432 == 3.432
True</code></pre>
<p><code class="label class">Ord</code> é para tipos que têm uma
ordenação.</p>
<pre class="haskell: ghci"><code>ghci&gt; :t (&gt;)
(&gt;) :: (Ord a) =&gt; a -&gt; a -&gt; Bool</code></pre>
<p>Todos os tipos que cobrimos até agora, exceto funções, fazem parte de
<code>Ord</code>. <code>Ord</code> cobre todas as funções de comparação
padrão, como <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code> e
<code>&lt;=</code>. A função <code>compare</code> pega dois membros
<code>Ord</code> do mesmo tipo e retorna uma ordenação. <code
class="label type">Ordering</code> é um tipo que pode ser
<code>GT</code>, <code>LT</code> ou <code>EQ</code>, significando
<em>maior que</em> (greater than), <em>menor que</em> (lesser than) e
<em>igual</em> (equal), respectivamente.</p>
<p>Para ser um membro de <code>Ord</code>, um tipo deve primeiro ter
associação no prestigioso e exclusivo clube <code>Eq</code>.</p>
<pre class="haskell: ghci"><code>ghci&gt; &quot;Abrakadabra&quot; &lt; &quot;Zebra&quot;
True
ghci&gt; &quot;Abrakadabra&quot; `compare` &quot;Zebra&quot;
LT
ghci&gt; 5 &gt;= 2
True
ghci&gt; 5 `compare` 3
GT</code></pre>
<p>Membros de <code class="label class">Show</code> podem ser
apresentados como strings. Todos os tipos cobertos até agora, exceto
funções, fazem parte de <code>Show</code>. A função mais usada que lida
com a typeclass <code>Show</code> é <code>show</code>. Ela pega um valor
cujo tipo é um membro de <code>Show</code> e o apresenta para nós como
uma string.</p>
<pre class="haskell: ghci"><code>ghci&gt; show 3
&quot;3&quot;
ghci&gt; show 5.334
&quot;5.334&quot;
ghci&gt; show True
&quot;True&quot;</code></pre>
<p><code class="label class">Read</code> é uma espécie de typeclass
oposta a <code>Show</code>. A função <code>read</code> pega uma string e
retorna um tipo que é membro de <code>Read</code>.</p>
<pre class="haskell: ghci"><code>ghci&gt; read &quot;True&quot; || False
True
ghci&gt; read &quot;8.2&quot; + 3.8
12.0
ghci&gt; read &quot;5&quot; - 2
3
ghci&gt; read &quot;[1,2,3,4]&quot; ++ [3]
[1,2,3,4,3]</code></pre>
<p>Até aqui tudo bem. Novamente, todos os tipos cobertos até agora estão
nesta typeclass. Mas o que acontece se tentarmos fazer apenas
<code>read "4"</code>?</p>
<pre class="haskell: ghci"><code>ghci&gt; read &quot;4&quot;
&lt;interactive&gt;:1:0:
    Ambiguous type variable `a&#39; in the constraint:
      `Read a&#39; arising from a use of `read&#39; at &lt;interactive&gt;:1:0-7
    Probable fix: add a type signature that fixes these type variable(s)</code></pre>
<p>O que o GHCI está nos dizendo aqui é que ele não sabe o que queremos
em troca. Observe que nos usos anteriores de <code>read</code> fizemos
algo com o resultado depois. Dessa forma, o GHCI poderia inferir que
tipo de resultado queríamos de nosso <code>read</code>. Se o usássemos
como booleano, ele sabia que tinha que retornar um
<code>Bool</code>.</p>
<p>Mas agora, ele sabe que queremos algum tipo que faça parte da classe
<code>Read</code>, apenas não sabe qual. Vamos dar uma olhada na
assinatura de tipo de <code>read</code>.</p>
<pre class="haskell: ghci"><code>ghci&gt; :t read
read :: (Read a) =&gt; String -&gt; a</code></pre>
<p>Viu? Ele retorna um tipo que faz parte de <code>Read</code>, mas se
não tentarmos usá-lo de alguma forma mais tarde, ele não tem como saber
qual tipo. É por isso que podemos usar <strong>anotações de
tipo</strong> explícitas. Anotações de tipo são uma maneira de dizer
explicitamente qual deve ser o tipo de uma expressão. Fazemos isso
adicionando <code>::</code> no final da expressão e depois especificando
um tipo. Observe:</p>
<pre class="haskell: ghci"><code>ghci&gt; read &quot;5&quot; :: Int
5
ghci&gt; read &quot;5&quot; :: Float
5.0
ghci&gt; (read &quot;5&quot; :: Float) * 4
20.0
ghci&gt; read &quot;[1,2,3,4]&quot; :: [Int]
[1,2,3,4]
ghci&gt; read &quot;(3, &#39;a&#39;)&quot; :: (Int, Char)
(3, &#39;a&#39;)</code></pre>
<p>A maioria das expressões é tal que o compilador pode inferir qual é o
seu tipo por si mesmo. Mas às vezes, o compilador não sabe se deve
retornar um valor do tipo <code>Int</code> ou <code>Float</code> para
uma expressão como <code>read "5"</code>. Para ver qual é o tipo,
Haskell teria que realmente avaliar <code>read "5"</code>. Mas como
Haskell é uma linguagem estaticamente tipada, ele precisa saber todos os
tipos antes que o código seja compilado (ou no caso do GHCI, avaliado).
Então temos que dizer a Haskell: “Ei, essa expressão deve ter esse tipo,
caso você não saiba!”.</p>
<p>Membros de <code class="label class">Enum</code> são tipos ordenados
sequencialmente — eles podem ser enumerados. A principal vantagem da
typeclass <code>Enum</code> é que podemos usar seus tipos em intervalos
de lista. Eles também têm sucessores e antecessores definidos, que você
pode obter com as funções <code>succ</code> e <code>pred</code>. Tipos
nesta classe: <code>()</code>, <code>Bool</code>, <code>Char</code>,
<code>Ordering</code>, <code>Int</code>, <code>Integer</code>,
<code>Float</code> e <code>Double</code>.</p>
<pre class="haskell: ghci"><code>ghci&gt; [&#39;a&#39;..&#39;e&#39;]
&quot;abcde&quot;
ghci&gt; [LT .. GT]
[LT,EQ,GT]
ghci&gt; [3 .. 5]
[3,4,5]
ghci&gt; succ &#39;B&#39;
&#39;C&#39;</code></pre>
<p>Membros de <code class="label class">Bounded</code> têm um limite
superior e um inferior.</p>
<pre class="haskell: ghci"><code>ghci&gt; minBound :: Int
-2147483648
ghci&gt; maxBound :: Char
&#39;\1114111&#39;
ghci&gt; maxBound :: Bool
True
ghci&gt; minBound :: Bool
False</code></pre>
<p><code>minBound</code> e <code>maxBound</code> são interessantes
porque têm um tipo de <code>(Bounded a) =&gt; a</code>. Em certo
sentido, são constantes polimórficas.</p>
<p>Todas as tuplas também fazem parte de <code>Bounded</code> se os
componentes também estiverem nela.</p>
<pre class="haskell: ghci"><code>ghci&gt; maxBound :: (Bool, Int, Char)
(True,2147483647,&#39;\1114111&#39;)</code></pre>
<p><code class="label class">Num</code> é uma typeclass numérica. Seus
membros têm a propriedade de poder agir como números. Vamos examinar o
tipo de um número.</p>
<pre class="haskell: ghci"><code>ghci&gt; :t 20
20 :: (Num t) =&gt; t</code></pre>
<p>Parece que números inteiros também são constantes polimórficas. Eles
podem agir como qualquer tipo que seja um membro da typeclass
<code>Num</code>.</p>
<pre class="haskell: ghci"><code>ghci&gt; 20 :: Int
20
ghci&gt; 20 :: Integer
20
ghci&gt; 20 :: Float
20.0
ghci&gt; 20 :: Double
20.0</code></pre>
<p>Esses são tipos que estão na typeclass <code>Num</code>. Se
examinarmos o tipo de <code>*</code>, veremos que ele aceita todos os
números.</p>
<pre class="haskell: ghci"><code>ghci&gt; :t (*)
(*) :: (Num a) =&gt; a -&gt; a -&gt; a</code></pre>
<p>Ele pega dois números do mesmo tipo e retorna um número desse tipo. É
por isso que <code>(5 :: Int) * (6 :: Integer)</code> resultará em um
erro de tipo, enquanto <code>5 * (6 :: Integer)</code> funcionará bem e
produzirá um <code>Integer</code> porque <code>5</code> pode agir como
um <code>Integer</code> ou um <code>Int</code>.</p>
<p>Para ingressar em <code>Num</code>, um tipo já deve ser amigo de
<code>Show</code> e <code>Eq</code>.</p>
<p><code class="class label">Integral</code> também é uma typeclass
numérica. <code>Num</code> inclui todos os números, incluindo números
reais e números inteiros, <code>Integral</code> inclui apenas números
inteiros (whole). Nesta typeclass estão <code>Int</code> e
<code>Integer</code>.</p>
<p><code class="class label">Floating</code> inclui apenas números de
ponto flutuante, então <code>Float</code> e <code>Double</code>.</p>
<p>Uma função muito útil para lidar com números é <code
class="label function">fromIntegral</code>. Ela tem uma declaração de
tipo de
<code>fromIntegral :: (Num b, Integral a) =&gt; a -&gt; b</code>. Pela
sua assinatura de tipo, vemos que ela pega um número integral e o
transforma em um número mais geral. Isso é útil quando você quer que
tipos inteiros e de ponto flutuante funcionem bem juntos. Por exemplo, a
função <code>length</code> tem uma declaração de tipo de
<code>length :: [a] -&gt; Int</code> em vez de ter um tipo mais geral de
<code>(Num b) =&gt; length :: [a] -&gt; b</code>. Se tentarmos obter o
comprimento de uma lista e depois adicioná-lo a <code>3.2</code>,
obteremos um erro porque tentamos adicionar um <code>Int</code> e um
número de ponto flutuante. Portanto, para contornar isso, fazemos
<code>fromIntegral (length [1,2,3,4]) + 3.2</code> e tudo funciona.</p>
<p>Observe que <code>fromIntegral</code> possui várias restrições de
classe em sua assinatura de tipo. Isso é completamente válido e, como
você pode ver, as restrições de classe são separadas por vírgulas dentro
dos parênteses.</p>
            </article>
<div class="footdiv">
    <ul>
        <li style="text-align:left">
<a href="starting-out.html">Anterior (Começando)</a>
        </li>
        <li style="text-align:center">
            <a href="chapters.html">Índice de capítulos</a>
        </li>
        <li style="text-align:right">
<a href="syntax-in-functions.html" class="nxtlink">Próximo (Sintaxe em Funções)</a>
        </li>
    </ul>
</div>

        </div>
    </div>
    <script type="text/javascript" src="sh/Scripts/shCore.js"></script>
    <script type="text/javascript" src="sh/Scripts/shBrushHaskell.js"></script>
    <script type="text/javascript" src="sh/Scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="assets/js/toggleShow.js"></script>
    <script type="text/javascript">
        dp.SyntaxHighlighter.HighlightAll('code');
    </script>
</body>
</html>
