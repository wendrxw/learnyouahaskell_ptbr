<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aprenda Haskell para o Bem de Todos!</title>
    <link rel="stylesheet" href="assets/css/reset.css" type="text/css" />
    <link rel="stylesheet" href="assets/css/style.css" type="text/css" />
    <link rel="stylesheet" href="sh/Styles/SyntaxHighlighter.css" type="text/css" />
    <link rel="shortcut icon" href="assets/images/favicon.png" type="image/png" />
</head>
<body class="introcontent">
    <div class="bgwrapper">
        <div id="content">
<div class="footdiv" style="margin-bottom:25px;">
    <ul>
        <li style="text-align:left">
<a href="higher-order-functions.html">Anterior (Funções de Alta Ordem)</a>
        </li>
        <li style="text-align:center">
            <a href="chapters.html">Índice de capítulos</a>
        </li>
        <li style="text-align:right">
<a href="making-our-own-types-and-typeclasses.html" class="nxtlink">Próximo (Criando Nossos Próprios Tipos e Typeclasses)</a>
        </li>
    </ul>
</div>

            <article>
<h1 id="módulos-modules">Módulos (Modules)</h1>
<p><img src="assets/images/modules/modules.png" class="right"
width="230" height="162" alt="modules" /></p>
<p>Um módulo Haskell é uma coleção de funções, tipos e typeclasses
relacionados. Um programa Haskell é uma coleção de módulos onde o módulo
principal carrega os outros módulos e, em seguida, usa as funções
definidas neles para fazer algo. Ter o código dividido em vários módulos
tem muitas vantagens. Se um módulo for genérico o suficiente, as funções
que ele exporta podem ser usadas em uma infinidade de programas
diferentes. Se o seu próprio código for separado em módulos
independentes que não dependem muito uns dos outros (também dizemos que
eles são fracamente acoplados), você poderá reutilizá-los mais tarde.
Isso torna todo o negócio de escrever código mais gerenciável,
dividindo-o em várias partes, cada uma das quais tem algum tipo de
propósito.</p>
<p>A biblioteca padrão do Haskell é dividida em módulos, cada um deles
contém funções e tipos que estão de alguma forma relacionados e servem a
algum propósito comum. Há um módulo para manipular listas, um módulo
para programação concorrente, um módulo para lidar com números
complexos, etc. Todas as funções, tipos e typeclasses com os quais
lidamos até agora faziam parte do módulo <code>Prelude</code>, que é
importado por padrão. Neste capítulo, vamos examinar alguns módulos
úteis e as funções que eles têm. Mas primeiro, vamos ver como importar
módulos.</p>
<h2 id="loading-modules">Carregando módulos (Loading modules)</h2>
<p>A sintaxe para importar módulos em um script Haskell é
<code>import &lt;nome do módulo&gt;</code>. Isso deve ser feito antes de
definir quaisquer funções, portanto, as importações geralmente são
feitas no topo do arquivo. Um script pode, é claro, importar vários
módulos. Basta colocar cada instrução de importação em uma linha
separada. Vamos importar o módulo <code>Data.List</code>, que tem um
monte de funções úteis para trabalhar com listas e usar uma função que
ele exporta para criar uma função que nos diz quantos elementos únicos
uma lista tem.</p>
<pre class="haskell:hs"><code>import Data.List

numUniques :: (Eq a) =&gt; [a] -&gt; Int
numUniques = length . nub</code></pre>
<p>Quando você faz <code>import Data.List</code>, todas as funções que
<code>Data.List</code> exporta tornam-se disponíveis no namespace
global, o que significa que você pode chamá-las de qualquer lugar no
script. <code>nub</code> é uma função definida em <code>Data.List</code>
que pega uma lista e elimina elementos duplicados. Compor
<code>length</code> e <code>nub</code> fazendo <code>length . nub</code>
produz uma função que é o equivalente a
<code>\xs -&gt; length (nub xs)</code>.</p>
<p>Você também pode colocar as funções de módulos no namespace global ao
usar o GHCI. Se você estiver no GHCI e quiser chamar as funções
exportadas por <code>Data.List</code>, faça isso:</p>
<pre class="haskell:ghci"><code>ghci&gt; :m + Data.List</code></pre>
<p>Se quisermos carregar os nomes de vários módulos dentro do GHCI, não
precisamos fazer <code>:m +</code> várias vezes, podemos apenas carregar
vários módulos de uma vez.</p>
<pre class="haskell:ghci"><code>ghci&gt; :m + Data.List Data.Map Data.Set</code></pre>
<p>No entanto, se você carregou um script que já importa um módulo, não
precisa usar <code>:m +</code> para obter acesso a ele.</p>
<p>Se você precisar apenas de algumas funções de um módulo, poderá
importar seletivamente apenas essas funções. Se quiséssemos importar
apenas as funções <code>nub</code> e <code>sort</code> de
<code>Data.List</code>, faríamos isso:</p>
<pre class="haskell:hs"><code>import Data.List (nub, sort)</code></pre>
<p>Você também pode optar por importar todas as funções de um módulo,
exceto algumas selecionadas. Isso geralmente é útil quando vários
módulos exportam funções com o mesmo nome e você deseja se livrar das
ofensivas. Digamos que já temos nossa própria função chamada
<code>nub</code> e queremos importar todas as funções de
<code>Data.List</code>, exceto a função <code>nub</code>:</p>
<pre class="haskell:hs"><code>import Data.List hiding (nub)</code></pre>
<p>Outra maneira de lidar com conflitos de nomes é fazer importações
qualificadas. O módulo <code>Data.Map</code>, que oferece uma estrutura
de dados para pesquisar valores por chave, exporta um monte de funções
com o mesmo nome que as funções do <code>Prelude</code>, como
<code>filter</code> ou <code>null</code>. Portanto, quando importamos
<code>Data.Map</code> e chamamos <code>filter</code>, o Haskell não
saberá qual função usar. Veja como resolvemos isso:</p>
<pre class="haskell:hs"><code>import qualified Data.Map</code></pre>
<p>Isso faz com que, se quisermos referenciar a função
<code>filter</code> de <code>Data.Map</code>, tenhamos que fazer
<code>Data.Map.filter</code>, enquanto apenas <code>filter</code> ainda
se refere ao <code>filter</code> normal que todos conhecemos e amamos.
Mas digitar <code>Data.Map</code> na frente de cada função desse módulo
é meio tedioso. É por isso que podemos renomear a importação qualificada
para algo mais curto:</p>
<pre class="haskell:hs"><code>import qualified Data.Map as M</code></pre>
<p>Agora, para referenciar a função <code>filter</code> de
<code>Data.Map</code>, apenas usamos <code>M.filter</code>.</p>
<p>Use <a
href="https://downloads.haskell.org/~ghc/latest/docs/html/libraries/">esta
referência útil</a> para ver quais módulos estão na biblioteca padrão.
Uma ótima maneira de obter novos conhecimentos de Haskell é simplesmente
clicar na referência da biblioteca padrão e explorar os módulos e suas
funções. Você também pode visualizar o código-fonte do Haskell para cada
módulo. Ler o código-fonte de alguns módulos é uma maneira muito boa de
aprender Haskell e ter uma noção sólida dele.</p>
<p>Para procurar funções ou descobrir onde estão localizadas, use o <a
href="https://hoogle.haskell.org/">Hoogle</a>. É um mecanismo de
pesquisa Haskell realmente incrível, você pode pesquisar por nome, nome
do módulo ou até assinatura de tipo.</p>
<h2 id="data-list">Data.List</h2>
<p>O módulo <code>Data.List</code> é tudo sobre listas, obviamente. Ele
fornece algumas funções muito úteis para lidar com elas. Já conhecemos
algumas de suas funções (como <code>map</code> e <code>filter</code>)
porque o módulo <code>Prelude</code> exporta algumas funções de
<code>Data.List</code> por conveniência. Você não precisa importar
<code>Data.List</code> por meio de uma importação qualificada porque não
entra em conflito com nenhum nome do <code>Prelude</code>, exceto
aqueles que o <code>Prelude</code> já rouba de <code>Data.List</code>.
Vamos dar uma olhada em algumas das funções que não conhecemos
antes.</p>
<p><code class="label function">intersperse</code> pega um elemento e
uma lista e, em seguida, coloca esse elemento entre cada par de
elementos na lista. Aqui está uma demonstração:</p>
<pre class="haskell:ghci"><code>ghci&gt; intersperse &#39;.&#39; &quot;MONKEY&quot;
&quot;M.O.N.K.E.Y&quot;
ghci&gt; intersperse 0 [1,2,3,4,5,6]
[1,0,2,0,3,0,4,0,5,0,6]</code></pre>
<p><code class="label function">intercalate</code> pega uma lista e uma
lista de listas. Ele então insere essa lista entre todas essas listas e
depois nivela o resultado.</p>
<pre class="haskell:ghci"><code>ghci&gt; intercalate &quot; &quot; [&quot;hey&quot;,&quot;there&quot;,&quot;folks&quot;]
&quot;hey there folks&quot;
ghci&gt; intercalate [0,0,0] [[1,2,3],[4,5,6],[7,8,9]]
[1,2,3,0,0,0,4,5,6,0,0,0,7,8,9]</code></pre>
<p><code class="label function">transpose</code> transpõe uma lista de
listas. Se você olhar para uma lista de listas como uma matriz 2D, as
colunas se tornarão as linhas e vice-versa.</p>
<pre class="haskell:ghci"><code>ghci&gt; transpose [[1,2,3],[4,5,6],[7,8,9]]
[[1,4,7],[2,5,8],[3,6,9]]
ghci&gt; transpose [&quot;hey&quot;,&quot;there&quot;,&quot;folks&quot;]
[&quot;htf&quot;,&quot;eho&quot;,&quot;yel&quot;,&quot;rk&quot;,&quot;es&quot;]</code></pre>
<p>Digamos que temos os polinômios <em>3x<sup>2</sup> + 5x + 9</em>,
<em>10x<sup>3</sup> + 9</em> e <em>8x<sup>3</sup> + 5x<sup>2</sup> + x -
1</em> e queremos somá-los. Podemos usar as listas
<code>[0,3,5,9]</code>, <code>[10,0,0,9]</code> e
<code>[8,5,1,-1]</code> para representá-los em Haskell. Agora, para
adicioná-los, tudo o que temos a fazer é isso:</p>
<pre class="haskell:ghci"><code>ghci&gt; map sum $ transpose [[0,3,5,9],[10,0,0,9],[8,5,1,-1]]
[18,8,6,17]</code></pre>
<p>Quando transpusemos essas três listas, as terceiras potências estão
na primeira linha, as segundas potências na segunda e assim por diante.
Mapear <code>sum</code> para isso produz nosso resultado desejado.</p>
<p><img src="assets/images/modules/legolists.png" class="left"
width="230" height="212" alt="shopping lists" /></p>
<p><code class="label function">foldl'</code> e <code
class="label function">foldl1'</code> são versões mais estritas de suas
respectivas encarnações preguiçosas. Ao usar dobras preguiçosas em
listas realmente grandes, você pode frequentemente obter um erro de
estouro de pilha (stack overflow error). O culpado por isso é que,
devido à natureza preguiçosa das dobras, o valor do acumulador não é
realmente atualizado à medida que a dobra acontece. O que realmente
acontece é que o acumulador faz uma promessa de que calculará seu valor
quando solicitado a realmente produzir o resultado (também chamado de
thunk). Isso acontece para cada acumulador intermediário e todos esses
thunks estouram sua pilha. As dobras estritas não são preguiçosas e
realmente calculam os valores intermediários à medida que avançam, em
vez de encher sua pilha com thunks. Portanto, se você receber erros de
estouro de pilha ao fazer dobras preguiçosas, tente mudar para suas
versões estritas.</p>
<p><code class="label function">concat</code> nivela uma lista de listas
em apenas uma lista de elementos.</p>
<pre class="haskell:ghci"><code>ghci&gt; concat [&quot;foo&quot;,&quot;bar&quot;,&quot;car&quot;]
&quot;foobarcar&quot;
ghci&gt; concat [[3,4,5],[2,3,4],[2,1,1]]
[3,4,5,2,3,4,2,1,1]</code></pre>
<p>Ele removerá apenas um nível de aninhamento. Portanto, se você deseja
nivelar completamente <code>[[[2,3],[3,4,5],[2]],[[2,3],[3,4]]]</code>,
que é uma lista de listas de listas, você deve concatená-la duas
vezes.</p>
<p>Fazer <code class="label function">concatMap</code> é o mesmo que
primeiro mapear uma função para uma lista e depois concatenar a lista
com <code>concat</code>.</p>
<pre class="haskell:ghci"><code>ghci&gt; concatMap (replicate 4) [1..3]
[1,1,1,1,2,2,2,2,3,3,3,3]</code></pre>
<p><code class="label function">and</code> pega uma lista de valores
booleanos e retorna <code>True</code> apenas se todos os valores na
lista forem <code>True</code>.</p>
<pre class="haskell:ghci"><code>ghci&gt; and $ map (&gt;4) [5,6,7,8]
True
ghci&gt; and $ map (==4) [4,4,4,3,4]
False</code></pre>
<p><code class="label function">or</code> é como <code>and</code>, só
que retorna <code>True</code> se algum dos valores booleanos em uma
lista for <code>True</code>.</p>
<pre class="haskell:ghci"><code>ghci&gt; or $ map (==4) [2,3,4,5,6,1]
True
ghci&gt; or $ map (&gt;4) [1,2,3]
False</code></pre>
<p><code class="label function">any</code> e <code
class="label function">all</code> pegam um predicado e verificam se
algum ou todos os elementos de uma lista satisfazem o predicado,
respectivamente. Geralmente usamos essas duas funções em vez de mapear
sobre uma lista e depois fazer <code>and</code> ou <code>or</code>.</p>
<pre class="haskell:ghci"><code>ghci&gt; any (==4) [2,3,5,6,1,4]
True
ghci&gt; all (&gt;4) [6,9,10]
True
ghci&gt; all (`elem` [&#39;A&#39;..&#39;Z&#39;]) &quot;HEYGUYSwhatsup&quot;
False
ghci&gt; any (`elem` [&#39;A&#39;..&#39;Z&#39;]) &quot;HEYGUYSwhatsup&quot;
True</code></pre>
<p><code class="label function">iterate</code> pega uma função e um
valor inicial. Ele aplica a função ao valor inicial, depois aplica essa
função ao resultado, depois aplica a função a esse resultado novamente,
etc. Ele retorna todos os resultados na forma de uma lista infinita.</p>
<pre class="haskell:ghci"><code>ghci&gt; take 10 $ iterate (*2) 1
[1,2,4,8,16,32,64,128,256,512]
ghci&gt; take 3 $ iterate (++ &quot;haha&quot;) &quot;haha&quot;
[&quot;haha&quot;,&quot;hahahaha&quot;,&quot;hahahahahaha&quot;]</code></pre>
<p><code class="label function">splitAt</code> pega um número e uma
lista. Ele então divide a lista em muitos elementos, retornando as duas
listas resultantes em uma tupla.</p>
<pre class="haskell:ghci"><code>ghci&gt; splitAt 3 &quot;heyman&quot;
(&quot;hey&quot;,&quot;man&quot;)
ghci&gt; splitAt 100 &quot;heyman&quot;
(&quot;heyman&quot;,&quot;&quot;)
ghci&gt; splitAt (-3) &quot;heyman&quot;
(&quot;&quot;,&quot;heyman&quot;)
ghci&gt; let (a,b) = splitAt 3 &quot;foobar&quot; in b ++ a
&quot;barfoo&quot;</code></pre>
<p><code class="label function">takeWhile</code> é uma pequena função
realmente útil. Ela pega elementos de uma lista enquanto o predicado se
mantém e, quando um elemento é encontrado que não satisfaz o predicado,
é cortado. Acontece que isso é muito útil.</p>
<pre class="haskell:ghci"><code>ghci&gt; takeWhile (&gt;3) [6,5,4,3,2,1,2,3,4,5,4,3,2,1]
[6,5,4]
ghci&gt; takeWhile (/=&#39; &#39;) &quot;This is a sentence&quot;
&quot;This&quot;</code></pre>
<p>Digamos que queríamos saber a soma de todas as terceiras potências
que estão abaixo de 10.000. Não podemos mapear <code>(^3)</code> para
<code>[1..]</code>, aplicar um filtro e depois tentar somar isso porque
filtrar uma lista infinita nunca termina. Você pode saber que todos os
elementos aqui são ascendentes, mas Haskell não. É por isso que podemos
fazer isso:</p>
<pre class="haskell:ghci"><code>ghci&gt; sum $ takeWhile (&lt;10000) $ map (^3) [1..]
53361</code></pre>
<p>Aplicamos <code>(^3)</code> a uma lista infinita e, uma vez que um
elemento superior a 10.000 é encontrado, a lista é cortada. Agora
podemos somar facilmente.</p>
<p><code class="label function">dropWhile</code> é semelhante, apenas
descarta todos os elementos enquanto o predicado é verdadeiro. Quando o
predicado é igual a <code>False</code>, ele retorna o restante da lista.
Uma função extremamente útil e adorável!</p>
<pre class="haskell:ghci"><code>ghci&gt; dropWhile (/=&#39; &#39;) &quot;This is a sentence&quot;
&quot; is a sentence&quot;
ghci&gt; dropWhile (&lt;3) [1,2,2,2,3,4,5,4,3,2,1]
[3,4,5,4,3,2,1]</code></pre>
<p>Recebemos uma lista que representa o valor de uma ação por data. A
lista é composta por tuplas cujo primeiro componente é o valor da ação,
o segundo é o ano, o terceiro é o mês e o quarto é a data. Queremos
saber quando o valor das ações excedeu mil dólares!</p>
<pre class="haskell:ghci"><code>ghci&gt; let stock = [(994.4,2008,9,1),(995.2,2008,9,2),(999.2,2008,9,3),(1001.4,2008,9,4),(998.3,2008,9,5)]
ghci&gt; head (dropWhile (\(val,y,m,d) -&gt; val &lt; 1000) stock)
(1001.4,2008,9,4)</code></pre>
<p><code class="label function">span</code> é meio que como
<code>takeWhile</code>, só que retorna um par de listas. A primeira
lista contém tudo o que a lista resultante de <code>takeWhile</code>
conteria se fosse chamada com o mesmo predicado e a mesma lista. A
segunda lista contém a parte da lista que teria sido descartada.</p>
<pre class="haskell:ghci"><code>ghci&gt; let (fw, rest) = span (/=&#39; &#39;) &quot;This is a sentence&quot; in &quot;First word:&quot; ++ fw ++ &quot;, the rest:&quot; ++ rest
&quot;First word: This, the rest: is a sentence&quot;</code></pre>
<p>Considerando que <code>span</code> abrange a lista enquanto o
predicado é verdadeiro, <code class="label function">break</code> a
quebra quando o predicado é verdadeiro. Fazer <code>break p</code> é o
equivalente a fazer <code>span (not . p)</code>.</p>
<pre class="haskell:ghci"><code>ghci&gt; break (==4) [1,2,3,4,5,6,7]
([1,2,3],[4,5,6,7])
ghci&gt; span (/=4) [1,2,3,4,5,6,7]
([1,2,3],[4,5,6,7])</code></pre>
<p>Ao usar <code>break</code>, a segunda lista no resultado começará com
o primeiro elemento que satisfaz o predicado.</p>
<p><code class="label function">sort</code> simplesmente classifica uma
lista. O tipo dos elementos na lista deve fazer parte da typeclass
<code>Ord</code>, porque se os elementos de uma lista não puderem ser
colocados em algum tipo de ordem, a lista não poderá ser
classificada.</p>
<pre class="haskell:ghci"><code>ghci&gt; sort [8,5,3,2,1,6,4,2]
[1,2,2,3,4,5,6,8]
ghci&gt; sort &quot;This will be sorted soon&quot;
&quot;    Tbdeehiillnooorssstw&quot;</code></pre>
<p><code class="label function">group</code> pega uma lista e agrupa
elementos adjacentes em sublistas se eles forem iguais.</p>
<pre class="haskell:ghci"><code>ghci&gt; group [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]
[[1,1,1,1],[2,2,2,2],[3,3],[2,2,2],[5],[6],[7]]</code></pre>
<p>Se classificarmos uma lista antes de agrupá-la, podemos descobrir
quantas vezes cada elemento aparece na lista.</p>
<pre class="haskell:ghci"><code>ghci&gt; map (\l@(x:xs) -&gt; (x,length l)) . group . sort $ [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]
[(1,4),(2,7),(3,2),(5,1),(6,1),(7,1)]</code></pre>
<p><code class="label function">inits</code> e <code
class="label function">tails</code> são como <code>init</code> e
<code>tail</code>, apenas aplicam recursivamente isso a uma lista até
que não resta nada. Observe.</p>
<pre class="haskell:ghci"><code>ghci&gt; inits &quot;w00t&quot;
[&quot;&quot;,&quot;w&quot;,&quot;w0&quot;,&quot;w00&quot;,&quot;w00t&quot;]
ghci&gt; tails &quot;w00t&quot;
[&quot;w00t&quot;,&quot;00t&quot;,&quot;0t&quot;,&quot;t&quot;,&quot;&quot;]
ghci&gt; let w = &quot;w00t&quot; in zip (inits w) (tails w)
[(&quot;&quot;,&quot;w00t&quot;),(&quot;w&quot;,&quot;00t&quot;),(&quot;w0&quot;,&quot;0t&quot;),(&quot;w00&quot;,&quot;t&quot;),(&quot;w00t&quot;,&quot;&quot;)]</code></pre>
<p>Vamos usar uma dobra para implementar a pesquisa em uma lista por uma
sublista.</p>
<pre class="haskell:hs"><code>search :: (Eq a) =&gt; [a] -&gt; [a] -&gt; Bool
search needle haystack =
    let nlen = length needle
    in  foldl (\acc x -&gt; if take nlen x == needle then True else acc) False (tails haystack)</code></pre>
<p>Primeiro, chamamos <code>tails</code> com a lista na qual estamos
pesquisando. Então passamos por cima de cada cauda e vemos se ela começa
com o que estamos procurando.</p>
<p>Com isso, na verdade, acabamos de fazer uma função que se comporta
como <code class="label function">isInfixOf</code>.
<code>isInfixOf</code> procura uma sublista dentro de uma lista e
retorna <code>True</code> se a sublista que estamos procurando estiver
em algum lugar dentro da lista de destino.</p>
<pre class="haskell:ghci"><code>ghci&gt; &quot;cat&quot; `isInfixOf` &quot;im a cat burglar&quot;
True
ghci&gt; &quot;Cat&quot; `isInfixOf` &quot;im a cat burglar&quot;
False
ghci&gt; &quot;cats&quot; `isInfixOf` &quot;im a cat burglar&quot;
False</code></pre>
<p><code class="label function">isPrefixOf</code> e <code
class="label function">isSuffixOf</code> procuram uma sublista no início
e no final de uma lista, respectivamente.</p>
<pre class="haskell:ghci"><code>ghci&gt; &quot;hey&quot; `isPrefixOf` &quot;hey there!&quot;
True
ghci&gt; &quot;hey&quot; `isPrefixOf` &quot;oh hey there!&quot;
False
ghci&gt; &quot;there!&quot; `isSuffixOf` &quot;oh hey there!&quot;
True
ghci&gt; &quot;there!&quot; `isSuffixOf` &quot;oh hey there&quot;
False</code></pre>
<p><code class="label function">elem</code> e <code
class="label function">notElem</code> verificam se um elemento está ou
não dentro de uma lista.</p>
<p><code class="label function">partition</code> pega uma lista e um
predicado e retorna um par de listas. A primeira lista no resultado
contém todos os elementos que satisfazem o predicado, a segunda contém
todos os que não satisfazem.</p>
<pre class="haskell:ghci"><code>ghci&gt; partition (`elem` [&#39;A&#39;..&#39;Z&#39;]) &quot;BOBsidneyMORGANeddy&quot;
(&quot;BOBMORGAN&quot;,&quot;sidneyeddy&quot;)
ghci&gt; partition (&gt;3) [1,3,5,6,3,2,1,0,3,7]
([5,6,7],[1,3,3,2,1,0,3])</code></pre>
<p>É importante entender como isso é diferente de <code>span</code> e
<code>break</code>:</p>
<pre class="haskell:ghci"><code>ghci&gt; span (`elem` [&#39;A&#39;..&#39;Z&#39;]) &quot;BOBsidneyMORGANeddy&quot;
(&quot;BOB&quot;,&quot;sidneyMORGANeddy&quot;)</code></pre>
<p>Enquanto <code>span</code> e <code>break</code> terminam quando
encontram o primeiro elemento que não satisfaz e satisfaz o predicado,
<code>partition</code> passa por toda a lista e a divide de acordo com o
predicado.</p>
<p><code class="label function">find</code> pega uma lista e um
predicado e retorna o primeiro elemento que satisfaz o predicado. Mas
retorna esse elemento envolvido em um valor <code>Maybe</code>.
Estaremos cobrindo tipos de dados algébricos mais aprofundadamente no
próximo capítulo, mas, por enquanto, é isso que você precisa saber: um
valor <code>Maybe</code> pode ser <code>Just something</code> ou
<code>Nothing</code>. Assim como uma lista pode ser uma lista vazia ou
uma lista com alguns elementos, um valor <code>Maybe</code> pode ser
nenhum elemento ou um único elemento. E como o tipo de uma lista de,
digamos, inteiros é <code>[Int]</code>, o tipo de maybe ter um inteiro é
<code>Maybe Int</code>. De qualquer forma, vamos testar nossa função
<code>find</code>.</p>
<pre class="haskell:ghci"><code>ghci&gt; find (&gt;4) [1,2,3,4,5,6]
Just 5
ghci&gt; find (&gt;9) [1,2,3,4,5,6]
Nothing
ghci&gt; :t find
find :: (a -&gt; Bool) -&gt; [a] -&gt; Maybe a</code></pre>
<p>Observe o tipo de <code>find</code>. Seu resultado é
<code>Maybe a</code>. É como ter o tipo de <code>[a]</code>, apenas um
valor do tipo <code>Maybe</code> pode conter nenhum elemento ou um
elemento, enquanto uma lista pode conter nenhum elemento, um elemento ou
vários elementos.</p>
<p>Lembre -se de quando estávamos procurando pela primeira vez que
nossas ações ultrapassaram US $ 1.000. Fizemos
<code>head (dropWhile (\(val,y,m,d) -&gt; val &lt; 1000) stock)</code>.
Lembre-se de que <code>head</code> não é realmente seguro. O que
aconteceria se o nosso estoque nunca ultrapassasse US $ 1000? Nossa
aplicação de <code>dropWhile</code> retornaria uma lista vazia e obter o
head de uma lista vazia resultaria em um erro. No entanto, se
reescrevêssemos isso como
<code>find (\(val,y,m,d) -&gt; val &gt; 1000) stock</code>, estaríamos
muito mais seguros. Se nossas ações nunca ultrapassassem US $ 1000
(portanto, se nenhum elemento satisfaz o predicado), receberíamos um
<code>Nothing</code>. Mas se houvesse uma resposta válida nessa lista,
receberíamos, digamos, <code>Just (1001.4,2008,9,4)</code>.</p>
<p><code class="label function">elemIndex</code> é meio que como
<code>elem</code>, só que não retorna um valor booleano. Talvez retorne
o índice do elemento que estamos procurando. Se esse elemento não
estiver em nossa lista, ele retornará <code>Nothing</code>.</p>
<pre class="haskell:ghci"><code>ghci&gt; :t elemIndex
elemIndex :: (Eq a) =&gt; a -&gt; [a] -&gt; Maybe Int
ghci&gt; 4 `elemIndex` [1,2,3,4,5,6]
Just 3
ghci&gt; 10 `elemIndex` [1,2,3,4,5,6]
Nothing</code></pre>
<p><code class="label function">elemIndices</code> é como
<code>elemIndex</code>, só que retorna uma lista de índices, caso o
elemento que estamos procurando apareça na nossa lista várias vezes.
Como estamos usando uma lista para representar os índices, não
precisamos de um tipo <code>Maybe</code>, porque a falha pode ser
representada como a lista vazia, que é muito sinônimo de
<code>Nothing</code>.</p>
<pre class="haskell:ghci"><code>ghci&gt; &#39; &#39; `elemIndices` &quot;Where are the spaces?&quot;
[5,9,13]</code></pre>
<p><code class="label function">findIndex</code> é como find, mas talvez
retorne o índice do primeiro elemento que satisfaz o predicado. <code
class="label function">findIndices</code> retorna os índices de todos os
elementos que satisfazem o predicado na forma de uma lista.</p>
<pre class="haskell:ghci"><code>ghci&gt; findIndex (==4) [5,3,2,1,6,4]
Just 5
ghci&gt; findIndex (==7) [5,3,2,1,6,4]
Nothing
ghci&gt; findIndices (`elem` [&#39;A&#39;..&#39;Z&#39;]) &quot;Where Are The Caps?&quot;
[0,6,10,14]</code></pre>
<p>Já cobrimos <code>zip</code> e <code>zipWith</code>. Observamos que
eles compactam duas listas, em uma tupla ou com uma função binária (o
que significa uma função que aceita dois parâmetros). Mas e se quisermos
compactar três listas? Ou compactar três listas com uma função que
aceita três parâmetros? Bem, para isso, temos <code
class="label function">zip3</code>, <code
class="label function">zip4</code>, etc. e <code
class="label function">zipWith3</code>, <code
class="label function">zipWith4</code>, etc. Essas variantes vão até 7.
Embora isso possa parecer uma gambiarra, funciona muito bem, porque não
há muitas vezes em que você deseja compactar 8 listas juntas. Também
existe uma maneira muito inteligente de compactar números infinitos de
listas, mas não somos avançados o suficiente para cobrir isso ainda.</p>
<pre class="haskell:ghci"><code>ghci&gt; zipWith3 (\x y z -&gt; x + y + z) [1,2,3] [4,5,2,2] [2,2,3]
[7,9,8]
ghci&gt; zip4 [2,3,3] [2,2,2] [5,5,3] [2,2,2]
[(2,2,5,2),(3,2,5,2),(3,2,3,2)]</code></pre>
<p>Assim como no zipping normal, as listas mais longas que a lista mais
curta que está sendo compactada são cortadas no tamanho.</p>
<p><code class="label function">lines</code> é uma função útil ao lidar
com arquivos ou entrada de algum lugar. Pega uma string e retorna cada
linha dessa string como elemento separado de uma lista.</p>
<pre class="haskell:ghci"><code>ghci&gt; lines &quot;first line\nsecond line\nthird line&quot;
[&quot;first line&quot;,&quot;second line&quot;,&quot;third line&quot;]</code></pre>
<p><code>'\n'</code> é o caractere para uma nova linha unix. As barras
invertidas têm significado especial em strings e caracteres de
Haskell.</p>
<p><code class="label function">unlines</code> é a função inversa de
<code>lines</code>. Pega uma lista de strings e as une usando um
<code>'\n'</code>.</p>
<pre class="haskell:ghci"><code>ghci&gt; unlines [&quot;first line&quot;, &quot;second line&quot;, &quot;third line&quot;]
&quot;first line\nsecond line\nthird line\n&quot;</code></pre>
<p><code class="label function">words</code> e <code
class="label function">unwords</code> são para dividir uma linha de
texto em palavras ou unir uma lista de palavras em um texto. Muito
útil.</p>
<pre class="haskell:ghci"><code>ghci&gt; words &quot;hey these are the words in this sentence&quot;
[&quot;hey&quot;,&quot;these&quot;,&quot;are&quot;,&quot;the&quot;,&quot;words&quot;,&quot;in&quot;,&quot;this&quot;,&quot;sentence&quot;]
ghci&gt; words &quot;hey these           are    the words in this\nsentence&quot;
[&quot;hey&quot;,&quot;these&quot;,&quot;are&quot;,&quot;the&quot;,&quot;words&quot;,&quot;in&quot;,&quot;this&quot;,&quot;sentence&quot;]
ghci&gt; unwords [&quot;hey&quot;,&quot;there&quot;,&quot;mate&quot;]
&quot;hey there mate&quot;</code></pre>
<p>Já mencionamos <code class="label function">nub</code>. Pega uma
lista e elimina os elementos duplicados, retornando uma lista cujo
elemento é um floco de neve único! A função tem um nome meio estranho.
Acontece que “nub” significa um pequeno pedaço ou parte essencial de
algo. Na minha opinião, eles deveriam usar palavras reais para nomes de
funções em vez de palavras de pessoas velhas.</p>
<pre class="haskell:ghci"><code>ghci&gt; nub [1,2,3,4,3,2,1,2,3,4,3,2,1]
[1,2,3,4]
ghci&gt; nub &quot;Lots of words and stuff&quot;
&quot;Lots fwrdanu&quot;</code></pre>
<p><code class="label function">delete</code> pega um elemento e uma
lista e exclui a primeira ocorrência desse elemento na lista.</p>
<pre class="haskell:ghci"><code>ghci&gt; delete &#39;h&#39; &quot;hey there ghang!&quot;
&quot;ey there ghang!&quot;
ghci&gt; delete &#39;h&#39; . delete &#39;h&#39; $ &quot;hey there ghang!&quot;
&quot;ey tere ghang!&quot;
ghci&gt; delete &#39;h&#39; . delete &#39;h&#39; . delete &#39;h&#39; $ &quot;hey there ghang!&quot;
&quot;ey tere gang!&quot;</code></pre>
<p><code class="label function">\\</code> é a função de diferença de
lista. Ele age como uma diferença de conjunto, basicamente. Para cada
elemento na lista do lado direito, ele remove um elemento correspondente
na esquerda.</p>
<pre class="haskell:ghci"><code>ghci&gt; [1..10] \\ [2,5,9]
[1,3,4,6,7,8,10]
ghci&gt; &quot;Im a big baby&quot; \\ &quot;big&quot;
&quot;Im a  baby&quot;</code></pre>
<p>Fazer <code>[1..10] \\ [2,5,9]</code> é como fazer
<code>delete 2 . delete 5 . delete 9 $ [1..10]</code>.</p>
<p><code class="label function">union</code> também atua como uma função
em conjuntos. Ele retorna a união de duas listas. Ele praticamente
repassa todos os elementos da segunda lista e o acrescenta ao primeiro
se ainda não estiver dentro. Cuidado, porém, as duplicatas são removidas
da segunda lista!</p>
<pre class="haskell:ghci"><code>ghci&gt; &quot;hey man&quot; `union` &quot;man what&#39;s up&quot;
&quot;hey manwt&#39;sup&quot;
ghci&gt; [1..7] `union` [5..10]
[1,2,3,4,5,6,7,8,9,10]</code></pre>
<p><code class="label function">intersect</code> funciona como
interseção de conjuntos. Ele retorna apenas os elementos encontrados nas
duas listas.</p>
<pre class="haskell:ghci"><code>ghci&gt; [1..7] `intersect` [5..10]
[5,6,7]</code></pre>
<p><code class="label function">insert</code> pega um elemento e uma
lista de elementos que podem ser classificados e o insere na última
posição, onde ainda é menor ou igual ao próximo elemento. Em outras
palavras, <code>insert</code> começará no início da lista e continuará
até encontrar um elemento igual ou maior que o elemento que estamos
inserindo e o inserirá logo antes do elemento.</p>
<pre class="haskell:ghci"><code>ghci&gt; insert 4 [3,5,1,2,8,2]
[3,4,5,1,2,8,2]
ghci&gt; insert 4 [1,3,4,4,1]
[1,3,4,4,4,1]</code></pre>
<p>O <code>4</code> é inserido logo após o <code>3</code> e antes do
<code>5</code> no primeiro exemplo e entre <code>3</code> e
<code>4</code> no segundo exemplo.</p>
<p>Se usarmos <code>insert</code> para inserir em uma lista
classificada, a lista resultante será mantida classificada.</p>
<pre class="haskell:ghci"><code>ghci&gt; insert 4 [1,2,3,5,6,7]
[1,2,3,4,5,6,7]
ghci&gt; insert &#39;g&#39; $ [&#39;a&#39;..&#39;f&#39;] ++ [&#39;h&#39;..&#39;z&#39;]
&quot;abcdefghijklmnopqrstuvwxyz&quot;
ghci&gt; insert 3 [1,2,4,3,2,1]
[1,2,3,4,3,2,1]</code></pre>
<p>O que <code>length</code>, <code>take</code>, <code>drop</code>,
<code>splitAt</code>, <code>!!</code> e <code>replicate</code> têm em
comum é que eles tomam um <code>Int</code> como um de seus parâmetros
(ou retornam um <code>Int</code>), embora pudessem ser mais genéricos e
utilizáveis se apenas pegassem qualquer tipo que faça parte das
typeclasses <code>Integral</code> ou <code>Num</code> (dependendo das
funções). Eles fazem isso por razões históricas. No entanto, corrigir
isso provavelmente quebraria muito código existente. É por isso que
<code>Data.List</code> tem seus equivalentes mais genéricos, chamado
<code class="label function">genericLength</code>, <code
class="label function">genericTake</code>, <code
class="label function">genericDrop</code>, <code
class="label function">genericSplitAt</code>, <code
class="label function">genericIndex</code> e <code
class="label function">genericReplicate</code>. Por exemplo,
<code>length</code> tem uma assinatura de tipo de
<code>length :: [a] -&gt; Int</code>. Se tentarmos obter a média de uma
lista de números fazendo
<code>let xs = [1..6] in sum xs / length xs</code>, recebemos um erro de
tipo, porque você não pode usar <code>/</code> com um <code>Int</code>.
<code>genericLength</code>, por outro lado, tem uma assinatura de tipo
de <code>genericLength :: (Num a) =&gt; [b] -&gt; a</code>. Como um
<code>Num</code> pode agir como um número de ponto flutuante, obter a
média fazendo <code>let xs = [1..6] in sum xs / genericLength xs</code>
funciona muito bem.</p>
<p>As funções <code>nub</code>, <code>delete</code>, <code>union</code>,
<code>intersect</code> e <code>group</code> têm todas as suas
contrapartes mais gerais chamadas <code
class="label function">nubBy</code>, <code
class="label function">deleteBy</code>, <code
class="label function">unionBy</code>, <code
class="label function">intersectBy</code> e <code
class="label function">groupBy</code>. A diferença entre eles é que o
primeiro conjunto de funções usa <code>==</code> para testar a
igualdade, enquanto as <em>By</em> também recebem uma função de
igualdade e depois as comparam usando essa função de igualdade.
<code>group</code> é o mesmo que <code>groupBy (==)</code>.</p>
<p>Por exemplo, digamos que temos uma lista que descreve o valor de uma
função a cada segundo. Queremos segmentá-la em sublistas com base em
quando o valor estava abaixo de zero e quando subiu. Se fizéssemos
apenas um <code>group</code> normal, ele apenas agruparia os valores
adjacentes iguais. Mas o que queremos é agrupá-los se eles são negativos
ou não. É aí que entra o <code>groupBy</code>! A função de igualdade
fornecida às funções <em>By</em> deve receber dois elementos do mesmo
tipo e retornar <code>True</code> se os considerar iguais pelos seus
padrões.</p>
<pre class="haskell:ghci"><code>ghci&gt; let values = [-4.3, -2.4, -1.2, 0.4, 2.3, 5.9, 10.5, 29.1, 5.3, -2.4, -14.5, 2.9, 2.3]
ghci&gt; groupBy (\x y -&gt; (x &gt; 0) == (y &gt; 0)) values
[[-4.3,-2.4,-1.2],[0.4,2.3,5.9,10.5,29.1,5.3],[-2.4,-14.5],[2.9,2.3]]</code></pre>
<p>A partir disso, vemos claramente quais seções são positivas e quais
são negativas. A função de igualdade fornecida pega dois elementos e
retorna <code>True</code> apenas se ambos forem negativos ou se ambos
forem positivos. Essa função de igualdade também pode ser escrita como
<code>\x y -&gt; (x &gt; 0) &amp;&amp; (y &gt; 0) || (x &lt;= 0) &amp;&amp; (y &lt;= 0)</code>,
embora eu ache que a primeira maneira é mais legível. Uma maneira ainda
mais clara de escrever funções de igualdade para as funções <em>By</em>
é se você importar a função <code class="label function">on</code> de
<code>Data.Function</code>. <code>on</code> é definido assim:</p>
<pre class="haskell:ghci"><code>on :: (b -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; a -&gt; c
f `on` g = \x y -&gt; f (g x) (g y)</code></pre>
<p>Portanto, fazer <code>(==)</code>on<code>(&gt; 0)</code> retorna uma
função de igualdade semelhante a
<code>\x y -&gt; (x &gt; 0) == (y &gt; 0)</code>. <code>on</code> é
usado muito com as funções <em>By</em> porque com ela, podemos
fazer:</p>
<pre class="haskell:ghci"><code>ghci&gt; groupBy ((==) `on` (&gt; 0)) values
[[-4.3,-2.4,-1.2],[0.4,2.3,5.9,10.5,29.1,5.3],[-2.4,-14.5],[2.9,2.3]]</code></pre>
<p>Muito legível de fato! Você pode ler em voz alta: agrupe isso por
igualdade se os elementos forem maiores que zero.</p>
<p>Da mesma forma, <code>sort</code>, <code>insert</code>,
<code>maximum</code> e <code>minimum</code> também têm seus equivalentes
mais gerais. Funções como <code>groupBy</code> pegam uma função que
determina quando dois elementos são iguais. <code
class="label function">sortBy</code>, <code
class="label function">insertBy</code>, <code
class="label function">maximumBy</code> e <code
class="label function">minimumBy</code> pegam uma função que determina
se um elemento é maior, menor ou igual ao outro. A assinatura de tipo de
<code>sortBy</code> é
<code>sortBy :: (a -&gt; a -&gt; Ordering) -&gt; [a] -&gt; [a]</code>.
Se você se lembra de antes, o tipo <code>Ordering</code> pode ter um
valor de <code>LT</code>, <code>EQ</code> ou <code>GT</code>.
<code>sort</code> é o equivalente a <code>sortBy compare</code>, porque
compare apenas pega dois elementos cujo tipo está na typeclass
<code>Ord</code> e retorna seu relacionamento de pedidos.</p>
<p>Listas podem ser comparadas, mas quando são, são comparadas
lexicograficamente. E se tivermos uma lista de listas e queremos
classificá-la não com base no conteúdo das listas internas, mas em seus
comprimentos? Bem, como você provavelmente adivinhou, usaremos a função
<code>sortBy</code>.</p>
<pre class="haskell:ghci"><code>ghci&gt; let xs = [[5,4,5,4,4],[1,2,3],[3,5,4,3],[],[2],[2,2]]
ghci&gt; sortBy (compare `on` length) xs
[[],[2],[2,2],[1,2,3],[3,5,4,3],[5,4,5,4,4]]</code></pre>
<p>Incrível! <code>compare</code>on<code>length</code> … cara, isso lê
quase como inglês real! Se você não tem certeza de como exatamente o
<code>on</code> funciona aqui, <code>compare</code>on<code>length</code>
é o equivalente a
<code>\x y -&gt; length x</code>compare<code>length y</code>. Quando
você está lidando com funções <em>By</em> que assumem uma função de
igualdade, geralmente faz <code>(==)</code>on<code>something</code> e
quando está lidando com funções <em>By</em> que executam uma função de
ordenação, geralmente faz
<code>compare</code>on<code>something</code>.</p>
<h2 id="data-char">Data.Char</h2>
<p><img src="assets/images/modules/legochar.png" class="right"
width="230" height="323" alt="lego char" /></p>
<p>O módulo <code>Data.Char</code> faz o que o nome sugere. Ele exporta
funções que lidam com caracteres. Também é útil ao filtrar e mapear
strings, porque elas são apenas listas de caracteres.</p>
<p><code>Data.Char</code> exporta um monte de predicados sobre
caracteres. Ou seja, funções que pegam um caractere e nos dizem se
alguma suposição sobre ele é verdadeira ou falsa. Aqui está o que eles
são:</p>
<p><code class="label function">isControl</code> verifica se um
caractere é um caractere de controle.</p>
<p><code class="label function">isSpace</code> verifica se um caractere
é um caractere de espaço em branco. Isso inclui espaços, caracteres de
tabulação, novas linhas, etc.</p>
<p><code class="label function">isLower</code> verifica se um caractere
é minúsculo.</p>
<p><code class="label function">isUpper</code> verifica se um caractere
é maiúsculo.</p>
<p><code class="label function">isAlpha</code> verifica se um caractere
é uma letra.</p>
<p><code class="label function">isAlphaNum</code> verifica se um
caractere é uma letra ou um número.</p>
<p><code class="label function">isPrint</code> verifica se um caractere
é imprimível. Caracteres de controle, por exemplo, não são
imprimíveis.</p>
<p><code class="label function">isDigit</code> verifica se um caractere
é um dígito.</p>
<p><code class="label function">isOctDigit</code> verifica se um
caractere é um dígito octal.</p>
<p><code class="label function">isHexDigit</code> verifica se um
caractere é um dígito hexadecimal.</p>
<p><code class="label function">isLetter</code> verifica se um caractere
é uma letra.</p>
<p><code class="label function">isMark</code> verifica se há caracteres
de marca Unicode. Esses são caracteres que combinam com as letras
anteriores para formar letras com sotaques. Use isso se você for
francês.</p>
<p><code class="label function">isNumber</code> verifica se um caractere
é numérico.</p>
<p><code class="label function">isPunctuation</code> verifica se um
caractere é pontuação.</p>
<p><code class="label function">isSymbol</code> verifica se um caractere
é um símbolo matemático ou de moeda extravagante.</p>
<p><code class="label function">isSeparator</code> verifica se há
espaços e separadores Unicode.</p>
<p><code class="label function">isAscii</code> verifica se um caractere
cai nos primeiros 128 caracteres do conjunto de caracteres Unicode.</p>
<p><code class="label function">isLatin1</code> verifica se um caractere
cai nos primeiros 256 caracteres do Unicode.</p>
<p><code class="label function">isAsciiUpper</code> verifica se um
caractere é ASCII e maiúsculo.</p>
<p><code class="label function">isAsciiLower</code> verifica se um
caractere é ASCII e minúsculo.</p>
<p>Todos esses predicados têm uma assinatura de tipo de
<code>Char -&gt; Bool</code>. Na maioria das vezes, você usará isso para
filtrar strings ou algo assim. Por exemplo, digamos que estamos fazendo
um programa que pega um nome de usuário que consiste apenas em
caracteres alfanuméricos. Podemos usar a função <code>Data.List</code>
<code>all</code> em combinação com os predicados <code>Data.Char</code>
para determinar se o nome de usuário está bem.</p>
<pre class="haskell:ghci"><code>ghci&gt; all isAlphaNum &quot;bobby283&quot;
True
ghci&gt; all isAlphaNum &quot;eddy the fish!&quot;
False</code></pre>
<p>Kewl. Caso você não se lembre, <code>all</code> pega um predicado e
uma lista e retorna <code>True</code> apenas se esse predicado for
válido para cada elemento da lista.</p>
<p>Também podemos usar <code>isSpace</code> para simular a função
<code>Data.List</code> <code>words</code>.</p>
<pre class="haskell:ghci"><code>ghci&gt; words &quot;hey folks its me&quot;
[&quot;hey&quot;,&quot;folks&quot;,&quot;its&quot;,&quot;me&quot;]
ghci&gt; groupBy ((==) `on` isSpace) &quot;hey folks its me&quot;
[&quot;hey&quot;,&quot; &quot;,&quot;folks&quot;,&quot; &quot;,&quot;its&quot;,&quot; &quot;,&quot;me&quot;]
ghci&gt;</code></pre>
<p>Hmmm, bem, isso faz o que <code>words</code> faz, mas ficamos com
elementos de apenas espaços. Hmm, o que faremos? Eu sei, vamos filtrar
esse otário.</p>
<pre class="haskell:ghci"><code>ghci&gt; filter (not . any isSpace) . groupBy ((==) `on` isSpace) $ &quot;hey folks its me&quot;
[&quot;hey&quot;,&quot;folks&quot;,&quot;its&quot;,&quot;me&quot;]</code></pre>
<p>Ah.</p>
<p>O <code>Data.Char</code> também exporta um tipo de dados que é meio
que o <code>Ordering</code>. O tipo <code>Ordering</code> pode ter um
valor de <code>LT</code>, <code>EQ</code> ou <code>GT</code>. É uma
espécie de enumeração. Ele descreve alguns resultados possíveis que
podem surgir da comparação de dois elementos. O tipo
<code>GeneralCategory</code> também é uma enumeração. Ele nos apresenta
algumas categorias possíveis em que um caractere pode cair. A principal
função para obter a categoria geral de um caractere é
<code>generalCategory</code>. Tem um tipo de
<code>generalCategory :: Char -&gt; GeneralCategory</code>. Existem
cerca de 31 categorias, então não vamos listá-las todas aqui, mas vamos
brincar com a função.</p>
<pre class="haskell:ghci"><code>ghci&gt; generalCategory &#39; &#39;
Space
ghci&gt; generalCategory &#39;A&#39;
UppercaseLetter
ghci&gt; generalCategory &#39;a&#39;
LowercaseLetter
ghci&gt; generalCategory &#39;.&#39;
OtherPunctuation
ghci&gt; generalCategory &#39;9&#39;
DecimalNumber
ghci&gt; map generalCategory &quot; \t\nA9?|&quot;
[Space,Control,Control,UppercaseLetter,DecimalNumber,OtherPunctuation,MathSymbol]</code></pre>
<p>Como o tipo <code>GeneralCategory</code> faz parte da typeclass
<code>Eq</code>, também podemos testar coisas como
<code>generalCategory c == Space</code>.</p>
<p><code class="label function">toUpper</code> converte um caractere em
maiúsculas. Espaços, números e afins permanecem inalterados.</p>
<p><code class="label function">toLower</code> converte um caractere em
minúsculas.</p>
<p><code class="label function">toTitle</code> converte um caractere
para title-case. Para a maioria dos caracteres, title-case é o mesmo que
maiúsculas.</p>
<p><code class="label function">digitToInt</code> converte um caractere
em um <code>Int</code>. Para ter sucesso, o caractere deve estar nos
intervalos <code>'0'..'9'</code>, <code>'a'..'f'</code> ou
<code>'A'..'F'</code>.</p>
<pre class="haskell:ghci"><code>ghci&gt; map digitToInt &quot;34538&quot;
[3,4,5,3,8]
ghci&gt; map digitToInt &quot;FF85AB&quot;
[15,15,8,5,10,11]</code></pre>
<p><code class="label function">intToDigit</code> é a função inversa de
<code>digitToInt</code>. Pega um <code>Int</code> na faixa de
<code>0..15</code> e o converte em um caractere minúsculo.</p>
<pre class="haskell:ghci"><code>ghci&gt; intToDigit 15
&#39;f&#39;
ghci&gt; intToDigit 5
&#39;5&#39;</code></pre>
<p>As funções <code class="label function">ord</code> e <code>chr</code>
convertem caracteres em seus números correspondentes e vice-versa:</p>
<pre class="haskell:ghci"><code>ghci&gt; ord &#39;a&#39;
97
ghci&gt; chr 97
&#39;a&#39;
ghci&gt; map ord &quot;abcdefgh&quot;
[97,98,99,100,101,102,103,104]</code></pre>
<p>A diferença entre os valores <code>ord</code> de dois caracteres é
igual à distância entre eles na tabela Unicode.</p>
<p>A cifra de César é um método primitivo de codificar mensagens,
deslocando cada caractere nelas por um número fixo de posições no
alfabeto. Podemos criar facilmente uma espécie de cifra de César, só que
não nos restringiremos ao alfabeto.</p>
<pre class="haskell:hs"><code>encode :: Int -&gt; String -&gt; String
encode shift msg =
    let ords = map ord msg
        shifted = map (+ shift) ords
    in  map chr shifted</code></pre>
<p>Aqui, primeiro convertemos a string em uma lista de números. Em
seguida, adicionamos o valor de deslocamento a cada número antes de
converter a lista de números de volta aos caracteres. Se você é um
cowboy de composição, pode escrever o corpo desta função como
<code>map (chr . (+ shift) . ord) msg</code>. Vamos tentar codificar
algumas mensagens.</p>
<pre class="haskell:ghci"><code>ghci&gt; encode 3 &quot;Heeeeey&quot;
&quot;Khhhhh|&quot;
ghci&gt; encode 4 &quot;Heeeeey&quot;
&quot;Liiiii}&quot;
ghci&gt; encode 1 &quot;abcd&quot;
&quot;bcde&quot;
ghci&gt; encode 5 &quot;Marry Christmas! Ho ho ho!&quot;
&quot;Rfww~%Hmwnxyrfx&amp;%Mt%mt%mt&amp;&quot;</code></pre>
<p>Isso está codificado bem. A decodificação de uma mensagem é
basicamente apenas deslocá-la de volta pelo número de lugares que foi
deslocado em primeiro lugar.</p>
<pre class="haskell:hs"><code>decode :: Int -&gt; String -&gt; String
decode shift msg = encode (negate shift) msg</code></pre>
<pre class="haskell:ghci"><code>ghci&gt; encode 3 &quot;Im a little teapot&quot;
&quot;Lp#d#olwwoh#whdsrw&quot;
ghci&gt; decode 3 &quot;Lp#d#olwwoh#whdsrw&quot;
&quot;Im a little teapot&quot;
ghci&gt; decode 5 . encode 5 $ &quot;This is a sentence&quot;
&quot;This is a sentence&quot;</code></pre>
<h2 id="data-map">Data.Map</h2>
<p>Listas de associação (também chamadas de dicionários) são listas
usadas para armazenar pares de chave-valor onde a ordem não importa. Por
exemplo, podemos usar uma lista de associação para armazenar números de
telefone, onde os números de telefone seriam os valores e os nomes das
pessoas seriam as chaves. Não nos importamos em que ordem eles são
armazenados, apenas queremos obter o número de telefone certo para a
pessoa certa.</p>
<p>A maneira mais óbvia de representar listas de associação em Haskell
seria ter uma lista de pares. O primeiro componente no par seria a
chave, o segundo componente o valor. Aqui está um exemplo de uma lista
de associação com números de telefone:</p>
<pre class="haskell:hs"><code>phoneBook =
    [(&quot;amelia&quot;,&quot;555-2938&quot;)
    ,(&quot;freya&quot;,&quot;452-2928&quot;)
    ,(&quot;isabella&quot;,&quot;493-2928&quot;)
    ,(&quot;neil&quot;,&quot;205-2928&quot;)
    ,(&quot;roald&quot;,&quot;939-8282&quot;)
    ,(&quot;tenzing&quot;,&quot;853-2492&quot;)
    ]</code></pre>
<p>Apesar dessa indentação aparentemente estranha, essa é apenas uma
lista de pares de strings. A tarefa mais comum ao lidar com listas de
associação é procurar algum valor por chave. Vamos fazer uma função que
procure algum valor dada uma chave.</p>
<pre class="haskell:hs"><code>findKey :: (Eq k) =&gt; k -&gt; [(k,v)] -&gt; v
findKey key xs = snd . head . filter (\(k,v) -&gt; key == k) $ xs</code></pre>
<p>Bem simples. A função que pega uma chave e uma lista, filtra a lista
para que apenas as chaves correspondentes permaneçam, pega o primeiro
par chave-valor que corresponde e retorna o valor. Mas o que acontece se
a chave que estamos procurando não estiver na lista de associação? Hmm.
Aqui, se uma chave não estiver na lista de associação, acabaremos
tentando obter a cabeça de uma lista vazia, o que gera um erro de tempo
de execução. No entanto, devemos evitar tornar nossos programas tão
fáceis de travar; portanto, vamos usar o tipo de dados
<code>Maybe</code>. Se não encontrarmos a chave, retornaremos um
<code>Nothing</code>. Se o encontrarmos, retornaremos
<code>Just something</code>, onde algo é o valor correspondente a essa
chave.</p>
<pre class="haskell:hs"><code>findKey :: (Eq k) =&gt; k -&gt; [(k,v)] -&gt; Maybe v
findKey key [] = Nothing
findKey key ((k,v):xs) = if key == k
                            then Just v
                            else findKey key xs</code></pre>
<p>Olhe para a declaração de tipo. Ele pega uma chave que pode ser
equiparada, uma lista de associação e talvez produz um valor. Parece
certo.</p>
<p>Esta é uma função recursiva de livro didático que opera em uma lista.
Caso de borda, dividindo uma lista em uma cabeça e uma cauda, chamadas
recursivas, estão todas lá. Esse é o padrão clássico de dobra, então
vamos ver como isso seria implementado como uma dobra.</p>
<pre class="haskell:hs"><code>findKey :: (Eq k) =&gt; k -&gt; [(k,v)] -&gt; Maybe v
findKey key = foldr (\(k,v) acc -&gt; if key == k then Just v else acc) Nothing</code></pre>
<div class="hintbox">
<p><strong>Nota:</strong> Geralmente, é melhor usar dobras para esse
padrão de recursão de lista padrão, em vez de escrever explicitamente a
recursão, porque são mais fáceis de ler e identificar. Todo mundo sabe
que é uma dobra quando vê a chamada <code>foldr</code>, mas é preciso
pensar um pouco mais para ler a recursão explícita.</p>
</div>
<pre class="haskell:ghci"><code>ghci&gt; findKey &quot;tenzing&quot; phoneBook
Just &quot;853-2492&quot;
ghci&gt; findKey &quot;amelia&quot; phoneBook
Just &quot;555-2938&quot;
ghci&gt; findKey &quot;christopher&quot; phoneBook
Nothing</code></pre>
<p><img src="assets/images/modules/legomap.png" class="left" width="214"
height="240" alt="legomap" /></p>
<p>Funciona como um encanto! Se tivermos o número de telefone do amigo,
<code>Just</code> obtemos o número, caso contrário, obtemos
<code>Nothing</code>.</p>
<p>Acabamos de implementar a função <code>lookup</code> de
<code>Data.List</code>. Se quisermos encontrar o valor correspondente a
uma chave, temos que percorrer todos os elementos da lista até
encontrá-la. O módulo <code>Data.Map</code> oferece listas de associação
muito mais rápidas (porque são implementadas internamente com árvores) e
também fornece muitas funções utilitárias. A partir de agora, diremos
que estamos trabalhando com mapas (maps) em vez de listas de
associação.</p>
<p>Como o <code>Data.Map</code> exporta funções que conflitam com as do
<code>Prelude</code> e <code>Data.List</code>, faremos uma importação
qualificada.</p>
<pre class="haskell:hs"><code>import qualified Data.Map as Map</code></pre>
<p>Coloque esta declaração de importação em um script e, em seguida,
carregue o script via GHCI.</p>
<p>Vamos em frente e ver o que <code>Data.Map</code> tem reservado para
nós! Aqui está o resumo básico de suas funções.</p>
<p>A função <code class="label function">fromList</code> pega uma lista
de associação (na forma de uma lista) e retorna um mapa com as mesmas
associações.</p>
<pre class="haskell:ghci"><code>ghci&gt; Map.fromList [(&quot;amelia&quot;,&quot;555-2938&quot;),(&quot;freya&quot;,&quot;452-2928&quot;),(&quot;neil&quot;,&quot;205-2928&quot;)]
fromList [(&quot;amelia&quot;,&quot;555-2938&quot;),(&quot;freya&quot;,&quot;452-2928&quot;),(&quot;neil&quot;,&quot;205-2928&quot;)]
ghci&gt; Map.fromList [(1,2),(3,4),(3,2),(5,5)]
fromList [(1,2),(3,2),(5,5)]</code></pre>
<p>Se houver chaves duplicadas na lista de associação original, as
duplicatas serão descartadas. Esta é a assinatura de tipo de
<code>fromList</code></p>
<pre class="haskell:hs"><code>Map.fromList :: (Ord k) =&gt; [(k, v)] -&gt; Map.Map k v</code></pre>
<p>Ele diz que pega uma lista de pares do tipo <code>k</code> e
<code>v</code> e retorna um mapa que mapeia de chaves do tipo
<code>k</code> para o tipo <code>v</code>. Observe que, quando estávamos
fazendo listas de associação com listas normais, as chaves só precisavam
ser equiparáveis (seu tipo pertencente à typeclass <code>Eq</code>), mas
agora elas precisam ser ordenáveis. Essa é uma restrição essencial no
módulo <code>Data.Map</code>. Ele precisa que as chaves sejam ordenáveis
para que possa organizá-las em uma árvore.</p>
<p>Você deve sempre usar <code>Data.Map</code> para associações de
valores-chave, a menos que tenha chaves que não fazem parte da typeclass
<code>Ord</code>.</p>
<p><code class="label function">empty</code> representa um mapa vazio.
Não aceita argumentos, apenas retorna um mapa vazio.</p>
<pre class="haskell:ghci"><code>ghci&gt; Map.empty
fromList []</code></pre>
<p><code class="label function">insert</code> pega uma chave, um valor e
um mapa e retorna um novo mapa que é exatamente como o antigo, apenas
com a chave e o valor inseridos.</p>
<pre class="haskell:ghci"><code>ghci&gt; Map.empty
fromList []
ghci&gt; Map.insert 3 100 Map.empty
fromList [(3,100)]
ghci&gt; Map.insert 5 600 (Map.insert 4 200 ( Map.insert 3 100  Map.empty))
fromList [(3,100),(4,200),(5,600)]
ghci&gt; Map.insert 5 600 . Map.insert 4 200 . Map.insert 3 100 $ Map.empty
fromList [(3,100),(4,200),(5,600)]</code></pre>
<p>Podemos implementar nosso próprio <code>fromList</code> usando o mapa
vazio, <code>insert</code> e uma dobra. Assista:</p>
<pre class="haskell:ghci"><code>fromList&#39; :: (Ord k) =&gt; [(k,v)] -&gt; Map.Map k v
fromList&#39; = foldr (\(k,v) acc -&gt; Map.insert k v acc) Map.empty</code></pre>
<p>É uma dobra bastante direta. Começamos com um mapa vazio e o dobramos
da direita, inserindo os pares de valores-chave no acumulador à medida
que avançamos.</p>
<p><code class="label function">null</code> verifica se um mapa está
vazio.</p>
<pre class="haskell:ghci"><code>ghci&gt; Map.null Map.empty
True
ghci&gt; Map.null $ Map.fromList [(2,3),(5,5)]
False</code></pre>
<p><code class="label function">size</code> relata o tamanho de um
mapa.</p>
<pre class="haskell:ghci"><code>ghci&gt; Map.size Map.empty
0
ghci&gt; Map.size $ Map.fromList [(2,4),(3,3),(4,2),(5,4),(6,4)]
5</code></pre>
<p><code class="label function">singleton</code> pega uma chave e um
valor e cria um mapa que possui exatamente um mapeamento.</p>
<pre class="haskell:ghci"><code>ghci&gt; Map.singleton 3 9
fromList [(3,9)]
ghci&gt; Map.insert 5 9 $ Map.singleton 3 9
fromList [(3,9),(5,9)]</code></pre>
<p><code class="label function">lookup</code> funciona como o
<code>lookup</code> de <code>Data.List</code>, apenas opera em mapas.
Ele retorna <code>Just something</code> se encontrar algo para a chave e
<code>Nothing</code> se não encontrar.</p>
<p><code class="label function">member</code> é um predicado que pega
uma chave e um mapa e relata se a chave está no mapa ou não.</p>
<pre class="haskell:ghci"><code>ghci&gt; Map.member 3 $ Map.fromList [(3,6),(4,3),(6,9)]
True
ghci&gt; Map.member 3 $ Map.fromList [(2,5),(4,5)]
False</code></pre>
<p><code class="label function">map</code> e <code
class="label function">filter</code> funcionam muito como seus
equivalentes de lista.</p>
<pre class="haskell:ghci"><code>ghci&gt; Map.map (*100) $ Map.fromList [(1,1),(2,4),(3,9)]
fromList [(1,100),(2,400),(3,900)]
ghci&gt; Map.filter isUpper $ Map.fromList [(1,&#39;a&#39;),(2,&#39;A&#39;),(3,&#39;b&#39;),(4,&#39;B&#39;)]
fromList [(2,&#39;A&#39;),(4,&#39;B&#39;)]</code></pre>
<p><code class="label function">toList</code> é o inverso de
<code>fromList</code>.</p>
<pre class="haskell:ghci"><code>ghci&gt; Map.toList . Map.insert 9 2 $ Map.singleton 4 3
[(4,3),(9,2)]</code></pre>
<p><code class="label function">keys</code> e <code
class="label function">elems</code> retornam listas de chaves e valores,
respectivamente. <code>keys</code> é o equivalente a
<code>map fst . Map.toList</code> e <code>elems</code> é o equivalente a
<code>map snd . Map.toList</code>.</p>
<p><code class="label function">fromListWith</code> é uma pequena função
legal. Ele age como <code>fromList</code>, mas não descarta chaves
duplicadas, mas usa uma função fornecida a ele para decidir o que fazer
com elas. Digamos que um amigo possa ter vários números e tenhamos uma
lista de associação configurada assim.</p>
<pre class="haskell:hs"><code>phoneBook =
    [(&quot;amelia&quot;,&quot;555-2938&quot;)
    ,(&quot;amelia&quot;,&quot;342-2492&quot;)
    ,(&quot;freya&quot;,&quot;452-2928&quot;)
    ,(&quot;isabella&quot;,&quot;493-2928&quot;)
    ,(&quot;isabella&quot;,&quot;943-2929&quot;)
    ,(&quot;isabella&quot;,&quot;827-9162&quot;)
    ,(&quot;neil&quot;,&quot;205-2928&quot;)
    ,(&quot;roald&quot;,&quot;939-8282&quot;)
    ,(&quot;tenzing&quot;,&quot;853-2492&quot;)
    ,(&quot;tenzing&quot;,&quot;555-2111&quot;)
    ]</code></pre>
<p>Agora, se apenas usarmos <code>fromList</code> para colocar isso em
um mapa, perderemos alguns números! Então, aqui está o que faremos:</p>
<pre class="haskell:hs"><code>phoneBookToMap :: (Ord k) =&gt; [(k, String)] -&gt; Map.Map k String
phoneBookToMap xs = Map.fromListWith (\number1 number2 -&gt; number1 ++ &quot;, &quot; ++ number2) xs</code></pre>
<pre class="haskell:hs"><code>ghci&gt; Map.lookup &quot;isabella&quot; $ phoneBookToMap phoneBook
&quot;827-9162, 943-2929, 493-2928&quot;
ghci&gt; Map.lookup &quot;roald&quot; $ phoneBookToMap phoneBook
&quot;939-8282&quot;
ghci&gt; Map.lookup &quot;amelia&quot; $ phoneBookToMap phoneBook
&quot;342-2492, 555-2938&quot;</code></pre>
<p>Se uma chave duplicada for encontrada, a função que passamos será
usada para combinar os valores dessas chaves em algum outro valor.
Também poderíamos fazer com que todos os valores na lista de associação
fossem listas singleton e, em seguida, podemos usar <code>++</code> para
combinar os números.</p>
<pre class="haskell:hs"><code>phoneBookToMap :: (Ord k) =&gt; [(k, a)] -&gt; Map.Map k [a]
phoneBookToMap xs = Map.fromListWith (++) $ map (\(k,v) -&gt; (k,[v])) xs</code></pre>
<pre class="haskell:ghci"><code>ghci&gt; Map.lookup &quot;isabella&quot; $ phoneBookToMap phoneBook
[&quot;827-9162&quot;,&quot;943-2929&quot;,&quot;493-2928&quot;]</code></pre>
<p>Muito legal! Outro caso de uso é se estamos criando um mapa a partir
de uma lista de associação de números e, quando uma chave duplicada é
encontrada, queremos que o maior valor da chave seja mantido.</p>
<pre class="haskell:ghci"><code>ghci&gt; Map.fromListWith max [(2,3),(2,5),(2,100),(3,29),(3,22),(3,11),(4,22),(4,15)]
fromList [(2,100),(3,29),(4,22)]</code></pre>
<p>Ou poderíamos optar por somar valores nas mesmas chaves.</p>
<pre class="haskell:ghci"><code>ghci&gt; Map.fromListWith (+) [(2,3),(2,5),(2,100),(3,29),(3,22),(3,11),(4,22),(4,15)]
fromList [(2,108),(3,62),(4,37)]</code></pre>
<p><code class="label function">insertWith</code> está para
<code>insert</code> assim como <code>fromListWith</code> está para
<code>fromList</code>. Ele insere um par de chave-valor em um mapa, mas
se esse mapa já contiver a chave, ele usa a função passada para
determinar o que fazer.</p>
<pre class="haskell:ghci"><code>ghci&gt; Map.insertWith (+) 3 100 $ Map.fromList [(3,4),(5,103),(6,339)]
fromList [(3,104),(5,103),(6,339)]</code></pre>
<p>Essas foram apenas algumas funções do <code>Data.Map</code>. Você
pode ver uma lista completa de funções na <a
href="https://hackage.haskell.org/package/containers/docs/Data-Map.html">documentação</a>.</p>
<h2 id="data-set">Data.Set</h2>
<p><img src="assets/images/modules/legosets.png" class="right"
width="150" height="236" alt="legosets" /></p>
<p>O módulo <code>Data.Set</code> nos oferece, bem, conjuntos. Como
conjuntos da matemática. Conjuntos são como um cruzamento entre listas e
mapas. Todos os elementos de um conjunto são únicos. E como eles são
implementados internamente com árvores (como mapas em
<code>Data.Map</code>), eles são ordenados. Verificar a associação,
inserir, excluir etc. é muito mais rápido do que fazer a mesma coisa com
as listas. A operação mais comum ao lidar com conjuntos é inserir em um
conjunto, verificar a associação e converter um conjunto em uma
lista.</p>
<p>Como os nomes em <code>Data.Set</code> entram em conflito com muitos
nomes de <code>Prelude</code> e <code>Data.List</code>, fazemos uma
importação qualificada.</p>
<p>Coloque esta declaração de importação em um script:</p>
<pre class="haskell:ghci"><code>import qualified Data.Set as Set</code></pre>
<p>E então carregue o script via GHCI.</p>
<p>Digamos que temos dois pedaços de texto. Queremos descobrir quais
caracteres foram usados em ambos.</p>
<pre class="haskell:ghci"><code>text1 = &quot;I just had an anime dream. Anime... Reality... Are they so different?&quot;
text2 = &quot;The old man left his garbage can out and now his trash is all over my lawn!&quot;</code></pre>
<p>A função <code class="label function">fromList</code> funciona muito
como você esperaria. Pega uma lista e a converte em um conjunto.</p>
<pre class="haskell:ghci"><code>ghci&gt; let set1 = Set.fromList text1
ghci&gt; let set2 = Set.fromList text2
ghci&gt; set1
fromList &quot; .?AIRadefhijlmnorstuy&quot;
ghci&gt; set2
fromList &quot; !Tabcdefghilmnorstuvwy&quot;</code></pre>
<p>Como você pode ver, os itens são ordenados e cada elemento é único.
Agora vamos usar a função <code
class="label function">intersection</code> para ver quais elementos
ambos compartilham.</p>
<pre class="haskell:ghci"><code>ghci&gt; Set.intersection set1 set2
fromList &quot; adefhilmnorstuy&quot;</code></pre>
<p>Podemos usar a função <code class="label function">difference</code>
para ver quais letras estão no primeiro conjunto, mas não estão no
segundo e vice-versa.</p>
<pre class="haskell:ghci"><code>ghci&gt; Set.difference set1 set2
fromList &quot;.?AIRj&quot;
ghci&gt; Set.difference set2 set1
fromList &quot;!Tbcgvw&quot;</code></pre>
<p>Ou podemos ver todas as letras únicas usadas nas duas frases usando
<code class="label function">union</code>.</p>
<pre class="haskell:ghci"><code>ghci&gt; Set.union set1 set2
fromList &quot; !.?AIRTabcdefghijlmnorstuvwy&quot;</code></pre>
<p>As funções <code class="label function">null</code>, <code
class="label function">size</code>, <code
class="label function">member</code>, <code
class="label function">empty</code>, <code
class="label function">singleton</code>, <code
class="label function">insert</code> e <code
class="label function">delete</code> funcionam todas como você
esperaria.</p>
<pre class="haskell:ghci"><code>ghci&gt; Set.null Set.empty
True
ghci&gt; Set.null $ Set.fromList [3,4,5,5,4,3]
False
ghci&gt; Set.size $ Set.fromList [3,4,5,3,4,5]
3
ghci&gt; Set.singleton 9
fromList [9]
ghci&gt; Set.insert 4 $ Set.fromList [9,3,8,1]
fromList [1,3,4,8,9]
ghci&gt; Set.insert 8 $ Set.fromList [5..10]
fromList [5,6,7,8,9,10]
ghci&gt; Set.delete 4 $ Set.fromList [3,4,5,4,3,4,5]
fromList [3,5]</code></pre>
<p>Também podemos verificar subconjuntos ou subconjunto próprio. O
conjunto A é um subconjunto do conjunto B se B contiver todos os
elementos que A possui. O conjunto A é um subconjunto próprio do
conjunto B se B contiver todos os elementos que A possui, mas tiver mais
elementos.</p>
<pre class="haskell:ghci"><code>ghci&gt; Set.fromList [2,3,4] `Set.isSubsetOf` Set.fromList [1,2,3,4,5]
True
ghci&gt; Set.fromList [1,2,3,4,5] `Set.isSubsetOf` Set.fromList [1,2,3,4,5]
True
ghci&gt; Set.fromList [1,2,3,4,5] `Set.isProperSubsetOf` Set.fromList [1,2,3,4,5]
False
ghci&gt; Set.fromList [2,3,4,8] `Set.isSubsetOf` Set.fromList [1,2,3,4,5]
False</code></pre>
<p>Também podemos mapear <code class="label function">map</code> sobre
conjuntos e filtrar <code class="label function">filter</code> eles.</p>
<pre class="haskell:ghci"><code>ghci&gt; Set.filter odd $ Set.fromList [3,4,5,6,7,2,3,4]
fromList [3,5,7]
ghci&gt; Set.map (+1) $ Set.fromList [3,4,5,6,7,2,3,4]
fromList [3,4,5,6,7,8]</code></pre>
<p>Os conjuntos são frequentemente usados para eliminar uma lista de
duplicatas de uma lista, transformando-a primeiro em um conjunto com
<code>fromList</code> e depois convertendo-o de volta para uma lista com
<code class="label function">toList</code>. A função
<code>Data.List</code> <code>nub</code> já faz isso, mas eliminar
duplicatas para listas grandes é muito mais rápido se você as colocar em
um conjunto e depois convertê-las novamente em uma lista do que usar o
<code>nub</code>. Mas usar <code>nub</code> exige apenas que o tipo dos
elementos da lista faça parte da typeclass <code>Eq</code>, ao passo
que, se você deseja colocar elementos em um conjunto, o tipo da lista
deve estar em <code>Ord</code>.</p>
<pre class="haskell:ghci"><code>ghci&gt; let setNub xs = Set.toList $ Set.fromList xs
ghci&gt; setNub &quot;HEY WHATS CRACKALACKIN&quot;
&quot; ACEHIKLNRSTWY&quot;
ghci&gt; nub &quot;HEY WHATS CRACKALACKIN&quot;
&quot;HEY WATSCRKLIN&quot;</code></pre>
<p><code>setNub</code> geralmente é mais rápido que <code>nub</code> em
grandes listas, mas como você pode ver, <code>nub</code> preserva a
ordem dos elementos da lista, enquanto <code>setNub</code> não.</p>
<h2 id="making-our-own-modules">Fazendo nossos próprios módulos (Making
our own modules)</h2>
<p><img src="assets/images/modules/making_modules.png" class="right"
width="345" height="224" alt="making modules" /></p>
<p>Vimos alguns módulos legais até agora, mas como fazemos nosso próprio
módulo? Quase todas as linguagens de programação permitem dividir seu
código em vários arquivos e o Haskell não é diferente. Ao fazer
programas, é uma boa prática pegar funções e tipos que trabalham para um
objetivo semelhante e colocá-los em um módulo. Dessa forma, você pode
reutilizar facilmente essas funções em outros programas apenas
importando seu módulo.</p>
<p>Vamos ver como podemos criar nossos próprios módulos criando um
pequeno módulo que fornece algumas funções para calcular o volume e a
área de alguns objetos geométricos. Começaremos criando um arquivo
chamado <code>Geometry.hs</code>.</p>
<p>Dizemos que um módulo <em>exporta</em> funções. O que isso significa
é que, quando importo um módulo, posso usar as funções que ele exporta.
Ele pode definir funções que suas funções chamam internamente, mas só
podemos ver e usar as que ele exporta.</p>
<p>No início de um módulo, especificamos o nome do módulo. Se tivermos
um arquivo chamado <code>Geometry.hs</code>, devemos nomear nosso módulo
<code>Geometry</code>. Em seguida, especificamos as funções que ele
exporta e, depois disso, podemos começar a escrever as funções. Então
começaremos com isso.</p>
<pre class="haskell:ghci"><code>module Geometry
( sphereVolume
, sphereArea
, cubeVolume
, cubeArea
, cuboidArea
, cuboidVolume
) where</code></pre>
<p>Como você pode ver, faremos áreas e volumes para esferas, cubos e
cubóides. Vamos em frente e definir nossas funções então:</p>
<pre class="haskell:ghci"><code>module Geometry
( sphereVolume
, sphereArea
, cubeVolume
, cubeArea
, cuboidArea
, cuboidVolume
) where

sphereVolume :: Float -&gt; Float
sphereVolume radius = (4.0 / 3.0) * pi * (radius ^ 3)

sphereArea :: Float -&gt; Float
sphereArea radius = 4 * pi * (radius ^ 2)

cubeVolume :: Float -&gt; Float
cubeVolume side = cuboidVolume side side side

cubeArea :: Float -&gt; Float
cubeArea side = cuboidArea side side side

cuboidVolume :: Float -&gt; Float -&gt; Float -&gt; Float
cuboidVolume a b c = rectangleArea a b * c

cuboidArea :: Float -&gt; Float -&gt; Float -&gt; Float
cuboidArea a b c = rectangleArea a b * 2 + rectangleArea a c * 2 + rectangleArea c b * 2

rectangleArea :: Float -&gt; Float -&gt; Float
rectangleArea a b = a * b</code></pre>
<p>Geometria bastante padrão aqui. Há algumas coisas a serem observadas.
Como um cubo é apenas um caso especial de cubóide, definimos sua área e
volume, tratando-o como um cubóide cujos lados são todos do mesmo
comprimento. Também definimos uma função auxiliar chamada
<code>rectangleArea</code>, que calcula a área de um retângulo com base
no comprimento de seus lados. É bastante trivial, porque é apenas
multiplicação. Observe que o usamos em nossas funções no módulo (a saber
<code>cuboidArea</code> e <code>cuboidVolume</code>), mas não o
exportamos! Como queremos que nosso módulo apresente apenas funções para
lidar com objetos tridimensionais, usamos <code>rectangleArea</code>,
mas não o exportamos.</p>
<p>Ao criar um módulo, geralmente exportamos apenas as funções que atuam
como uma espécie de interface para o nosso módulo, para que a
implementação seja ocultada. Se alguém estiver usando nosso módulo
<code>Geometry</code>, não precisará se preocupar com funções que não
exportamos. Podemos decidir mudar essas funções completamente ou
excluí-las em uma versão mais recente (poderíamos excluir
<code>rectangleArea</code> e apenas usar <code>*</code> em vez disso) e
ninguém se importará, porque não as exportávamos em primeiro lugar.</p>
<p>Para usar nosso módulo, basta fazer:</p>
<pre class="haskell:ghci"><code>import Geometry</code></pre>
<p><code>Geometry.hs</code> deve estar na mesma pasta em que está o
programa que o importa.</p>
<p>Os módulos também podem ter uma estrutura hierárquica. Cada módulo
pode ter vários submódulos e eles podem ter seus próprios submódulos.
Vamos separar essas funções para que <code>Geometry</code> seja um
módulo que tenha três submódulos, um para cada tipo de objeto.</p>
<p>Primeiro, faremos uma pasta chamada <code>Geometry</code>. Cuidado
com o G maiúsculo. Nele, colocaremos três arquivos:
<code>Sphere.hs</code>, <code>Cuboid.hs</code> e <code>Cube.hs</code>.
Aqui está o que os arquivos conterão:</p>
<p><code>Sphere.hs</code></p>
<pre class="haskell:ghci"><code>module Geometry.Sphere
( volume
, area
) where

volume :: Float -&gt; Float
volume radius = (4.0 / 3.0) * pi * (radius ^ 3)

area :: Float -&gt; Float
area radius = 4 * pi * (radius ^ 2)</code></pre>
<p><code>Cuboid.hs</code></p>
<pre class="haskell:ghci"><code>module Geometry.Cuboid
( volume
, area
) where

volume :: Float -&gt; Float -&gt; Float -&gt; Float
volume a b c = rectangleArea a b * c

area :: Float -&gt; Float -&gt; Float -&gt; Float
area a b c = rectangleArea a b * 2 + rectangleArea a c * 2 + rectangleArea c b * 2

rectangleArea :: Float -&gt; Float -&gt; Float
rectangleArea a b = a * b</code></pre>
<p><code>Cube.hs</code></p>
<pre class="haskell:ghci"><code>module Geometry.Cube
( volume
, area
) where

import qualified Geometry.Cuboid as Cuboid

volume :: Float -&gt; Float
volume side = Cuboid.volume side side side

area :: Float -&gt; Float
area side = Cuboid.area side side side</code></pre>
<p>Tudo certo! Então, primeiro é <code>Geometry.Sphere</code>. Observe
como o colocamos em uma pasta chamada <code>Geometry</code> e depois
definimos o nome do módulo como <code>Geometry.Sphere</code>. Fizemos o
mesmo para o cubóide. Observe também como nos três submódulos definimos
funções com os mesmos nomes. Podemos fazer isso porque são módulos
separados. Queremos usar funções de <code>Geometry.Cuboid</code> em
<code>Geometry.Cube</code>, mas não podemos simplesmente fazer
<code>import Geometry.Cuboid</code> porque exporta funções com os mesmos
nomes que <code>Geometry.Cube</code>. É por isso que fazemos uma
importação qualificada e está tudo bem.</p>
<p>Então, agora, se estivermos em um arquivo que está no mesmo nível que
a pasta <code>Geometry</code>, podemos fazer, digamos:</p>
<pre class="haskell:ghci"><code>import Geometry.Sphere</code></pre>
<p>E então podemos chamar <code>area</code> e <code>volume</code> e eles
nos darão a área e o volume para uma esfera. E se quisermos fazer
malabarismos com dois ou mais desses módulos, temos que fazer
importações qualificadas porque eles exportam funções com os mesmos
nomes. Então, fazemos algo como:</p>
<pre class="haskell:ghci"><code>import qualified Geometry.Sphere as Sphere
import qualified Geometry.Cuboid as Cuboid
import qualified Geometry.Cube as Cube</code></pre>
<p>E então podemos chamar <code>Sphere.area</code>,
<code>Sphere.volume</code>, <code>Cuboid.area</code>, etc. e cada um
calculará a área ou o volume para seu objeto correspondente.</p>
<p>Na próxima vez que você se encontrar escrevendo um arquivo realmente
grande e com muitas funções, tente ver quais funções atendem a algum
objetivo comum e depois veja se você pode colocá-las em seu próprio
módulo. Você poderá importar seu módulo na próxima vez em que estiver
escrevendo um programa que requer a mesma funcionalidade.</p>
            </article>
<div class="footdiv">
    <ul>
        <li style="text-align:left">
<a href="higher-order-functions.html">Anterior (Funções de Alta Ordem)</a>
        </li>
        <li style="text-align:center">
            <a href="chapters.html">Índice de capítulos</a>
        </li>
        <li style="text-align:right">
<a href="making-our-own-types-and-typeclasses.html" class="nxtlink">Próximo (Criando Nossos Próprios Tipos e Typeclasses)</a>
        </li>
    </ul>
</div>

        </div>
    </div>
    <script type="text/javascript" src="sh/Scripts/shCore.js"></script>
    <script type="text/javascript" src="sh/Scripts/shBrushHaskell.js"></script>
    <script type="text/javascript" src="sh/Scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="assets/js/toggleShow.js"></script>
    <script type="text/javascript">
        dp.SyntaxHighlighter.HighlightAll('code');
    </script>
</body>
</html>
