<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aprenda Haskell para o Bem de Todos!</title>
    <link rel="stylesheet" href="assets/css/reset.css" type="text/css" />
    <link rel="stylesheet" href="assets/css/style.css" type="text/css" />
    <link rel="stylesheet" href="sh/Styles/SyntaxHighlighter.css" type="text/css" />
    <link rel="shortcut icon" href="assets/images/favicon.png" type="image/png" />
</head>
<body class="introcontent">
    <div class="bgwrapper">
        <div id="content">
<div class="footdiv" style="margin-bottom:25px;">
    <ul>
        <li style="text-align:left">
<a href="for-a-few-monads-more.html">Anterior (Por mais Alguns Monads)</a>
        </li>
        <li style="text-align:center">
            <a href="chapters.html">Índice de capítulos</a>
        </li>
        <li style="text-align:right">

        </li>
    </ul>
</div>

            <article>
<h1 id="zippers">Zippers</h1>
<p><img src="assets/images/zippers/60sdude.png" class="right"
width="122" height="407" alt="oi, eu sou o chet" /></p>
<p>Embora a pureza do Haskell traga um monte de benefícios, ela nos faz
abordar alguns problemas de forma diferente do que faríamos em
linguagens impuras. Por causa da transparência referencial, um valor é
tão bom quanto outro no Haskell se representar a mesma coisa.</p>
<p>Então, se tivermos uma árvore cheia de cincos (high-fives, talvez?) e
quisermos mudar um deles para um seis, temos que ter alguma maneira de
saber exatamente qual cinco em nossa árvore queremos mudar. Temos que
saber onde ele está na nossa árvore. Em linguagens impuras, poderíamos
apenas notar onde na nossa memória o cinco está localizado e mudá-lo.
Mas no Haskell, um cinco é tão bom quanto outro, então não podemos
discriminar com base em onde eles estão na nossa memória. Também não
podemos realmente <em>mudar</em> nada; quando dizemos que mudamos uma
árvore, na verdade queremos dizer que pegamos uma árvore e retornamos
uma nova que é semelhante à árvore original, mas ligeiramente
diferente.</p>
<p>Uma coisa que podemos fazer é lembrar um caminho da raiz da árvore
até o elemento que queremos mudar. Poderíamos dizer: pegue esta árvore,
vá para a esquerda, vá para a direita e depois para a esquerda novamente
e mude o elemento que está lá. Embora isso funcione, pode ser
ineficiente. Se quisermos mudar mais tarde um elemento que esteja perto
do elemento que mudamos anteriormente, temos que percorrer todo o
caminho desde a raiz da árvore até o nosso elemento novamente!</p>
<p>Neste capítulo, veremos como podemos pegar alguma estrutura de dados
e focar em uma parte dela de uma maneira que torne a mudança de seus
elementos fácil e o caminhar por ela eficiente. Legal!</p>
<h2 id="taking-a-walk">Dando um passeio</h2>
<p>Como aprendemos na aula de biologia, existem muitos tipos diferentes
de árvores, então vamos escolher uma semente que usaremos para plantar a
nossa. Aqui está:</p>
<pre class="haskell:hs"><code>data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show)</code></pre>
<p>Então a nossa árvore ou está vazia ou é um nó que tem um elemento e
duas subárvores. Aqui está um belo exemplo de tal árvore, que eu dou a
você, leitor, de graça!</p>
<pre class="haskell:hs"><code>freeTree :: Tree Char
freeTree =
    Node &#39;P&#39;
        (Node &#39;O&#39;
            (Node &#39;L&#39;
                (Node &#39;N&#39; Empty Empty)
                (Node &#39;T&#39; Empty Empty)
            )
            (Node &#39;Y&#39;
                (Node &#39;S&#39; Empty Empty)
                (Node &#39;A&#39; Empty Empty)
            )
        )
        (Node &#39;L&#39;
            (Node &#39;W&#39;
                (Node &#39;C&#39; Empty Empty)
                (Node &#39;R&#39; Empty Empty)
            )
            (Node &#39;A&#39;
                (Node &#39;A&#39; Empty Empty)
                (Node &#39;C&#39; Empty Empty)
            )
        )</code></pre>
<p>E aqui está esta árvore representada graficamente:</p>
<p><img src="assets/images/zippers/pollywantsa.png" class="center"
width="780" height="504" alt="polly diz que suas costas doem" /></p>
<p>Notou aquele <code>W</code> na árvore ali? Digamos que queiramos
mudá-lo para um <code>P</code>. Como faríamos isso? Bem, uma maneira
seria fazer pattern matching na nossa árvore até encontrarmos o elemento
localizado indo primeiro para a direita e depois para a esquerda e
mudando o dito elemento. Aqui está o código para isso:</p>
<pre class="haskell:hs"><code>changeToP :: Tree Char -&gt; Tree Char
changeToP (Node x l (Node y (Node _ m n) r)) = Node x l (Node y (Node &#39;P&#39; m n) r)</code></pre>
<p>Eca! Não só isso é bastante feio, como também é meio confuso. O que
acontece aqui? Bem, fazemos pattern matching na nossa árvore e nomeamos
seu elemento raiz como <code>x</code> (que se torna o <code>'P'</code>
na raiz) e sua subárvore esquerda como <code>l</code>. Em vez de dar um
nome à sua subárvore direita, fazemos mais pattern matching nela.
Continuamos este pattern matching até chegarmos à subárvore cuja raiz é
o nosso <code>'W'</code>. Uma vez feito isso, reconstruímos a árvore, só
que a subárvore que continha o <code>'W'</code> na sua raiz agora tem um
<code>'P'</code>.</p>
<p>Existe uma maneira melhor de fazer isso? Que tal fazermos nossa
função receber uma árvore junto com uma lista de direções. As direções
serão <code>L</code> ou <code>R</code>, representando esquerda (left) e
direita (right) respectivamente, e mudaremos o elemento em que chegarmos
se seguirmos as direções fornecidas. Aqui está:</p>
<pre class="haskell:hs"><code>data Direction = L | R deriving (Show)
type Directions = [Direction]

changeToP :: Directions -&gt; Tree Char -&gt; Tree Char
changeToP (L:ds) (Node x l r) = Node x (changeToP ds l) r
changeToP (R:ds) (Node x l r) = Node x l (changeToP ds r)
changeToP [] (Node _ l r) = Node &#39;P&#39; l r</code></pre>
<p>Se o primeiro elemento na nossa lista de direções for <code>L</code>,
construímos uma nova árvore que é como a árvore antiga, só que sua
subárvore esquerda tem um elemento alterado para <code>'P'</code>.
Quando chamamos recursivamente <code>changeToP</code>, passamos apenas o
resto da lista de direções, porque já fomos para a esquerda. Fazemos a
mesma coisa no caso de um <code>R</code>. Se a lista de direções estiver
vazia, isso significa que estamos no nosso destino, então retornamos uma
árvore que é como a fornecida, só que tem <code>'P'</code> como seu
elemento raiz.</p>
<p>Para evitar imprimir a árvore toda, vamos fazer uma função que receba
uma lista de direções e nos diga qual é o elemento no destino:</p>
<pre class="haskell:hs"><code>elemAt :: Directions -&gt; Tree a -&gt; a
elemAt (L:ds) (Node _ l _) = elemAt ds l
elemAt (R:ds) (Node _ _ r) = elemAt ds r
elemAt [] (Node x _ _) = x</code></pre>
<p>Esta função é na verdade bastante semelhante à
<code>changeToP</code>, só que em vez de lembrar as coisas ao longo do
caminho e reconstruir a árvore, ela ignora tudo exceto seu destino. Aqui
mudamos o <code>'W'</code> para um <code>'P'</code> e vemos se a mudança
na nossa nova árvore permanece:</p>
<pre class="haskell:hs"><code>ghci&gt; let newTree = changeToP [R,L] freeTree
ghci&gt; elemAt [R,L] newTree
&#39;P&#39;</code></pre>
<p>Legal, isso parece funcionar. Nestas funções, a lista de direções
atua como uma espécie de <em>foco</em>, porque aponta para uma subárvore
exata da nossa árvore. Uma lista de direções <code>[R]</code> foca na
subárvore que está à direita da raiz, por exemplo. Uma lista de direções
vazia foca na árvore principal em si.</p>
<p>Embora esta técnica possa parecer legal, ela pode ser bastante
ineficiente, especialmente se quisermos mudar elementos repetidamente.
Digamos que temos uma árvore realmente enorme e uma longa lista de
direções que aponta para algum elemento lá no fundo da árvore. Usamos a
lista de direções para dar um passeio pela árvore e mudar um elemento no
fundo. Se quisermos mudar outro elemento que esteja perto do elemento
que acabamos de mudar, temos que começar pela raiz da árvore e percorrer
todo o caminho até ao fundo novamente! Que chato.</p>
<p>Na próxima seção, encontraremos uma maneira melhor de focar em uma
subárvore, uma que nos permita mudar o foco eficientemente para
subárvores que estejam próximas.</p>
<h2 id="a-trail-of-breadcrumbs">Um rastro de migalhas</h2>
<p><img src="assets/images/zippers/bread.png" class="right" width="321"
height="250" alt="whoop dee doo" /></p>
<p>Certo, então para focar em uma subárvore, queremos algo melhor do que
apenas uma lista de direções que sempre seguimos a partir da raiz da
nossa árvore. Ajudaria se começássemos na raiz da árvore e nos
movêssemos um passo de cada vez para a esquerda ou para a direita e
deixássemos uma espécie de rastro de migalhas? Ou seja, quando vamos
para a esquerda, lembramos que fomos para a esquerda e quando vamos para
a direita, lembramos que fomos para a direita. Com certeza, podemos
tentar isso.</p>
<p>Para representar nossas migalhas de pão, também usaremos uma lista de
<code>Direction</code> (que é <code>L</code> ou <code>R</code>), só que
em vez de chamá-la de <code>Directions</code>, vamos chamá-la de
<code>Breadcrumbs</code> (migalhas), porque as nossas direções agora
estarão invertidas, já que as estamos deixando à medida que descemos
pela nossa árvore:</p>
<pre class="haskell:hs"><code>type Breadcrumbs = [Direction]</code></pre>
<p>Aqui está uma função que recebe uma árvore e algumas migalhas e se
move para a subárvore esquerda enquanto adiciona <code>L</code> ao
início da lista que representa nossas migalhas:</p>
<pre class="haskell:hs"><code>goLeft :: (Tree a, Breadcrumbs) -&gt; (Tree a, Breadcrumbs)
goLeft (Node _ l _, bs) = (l, L:bs)</code></pre>
<p>Ignoramos o elemento na raiz e a subárvore direita e apenas
retornamos a subárvore esquerda junto com as migalhas antigas com
<code>L</code> no início. Aqui está uma função para ir para a
direita:</p>
<pre class="haskell:hs"><code>goRight :: (Tree a, Breadcrumbs) -&gt; (Tree a, Breadcrumbs)
goRight (Node _ _ r, bs) = (r, R:bs)</code></pre>
<p>Ela funciona da mesma maneira. Vamos usar essas funções para pegar a
nossa <code>freeTree</code> e ir para a direita e depois para a
esquerda:</p>
<pre class="haskell:hs"><code>ghci&gt; goLeft (goRight (freeTree, []))
(Node &#39;W&#39; (Node &#39;C&#39; Empty Empty) (Node &#39;R&#39; Empty Empty),[L,R])</code></pre>
<p><img src="assets/images/zippers/almostzipper.png" class="left"
width="399" height="224" alt="almostthere" /></p>
<p>Certo, então agora temos uma árvore que tem <code>'W'</code> na sua
raiz e <code>'C'</code> na raiz da sua subárvore esquerda e
<code>'R'</code> na raiz da sua subárvore direita. As migalhas são
<code>[L,R]</code>, porque primeiro fomos para a direita e depois para a
esquerda.</p>
<p>Para tornar o caminhar pela nossa árvore mais claro, podemos usar a
função <code>-:</code> que definimos assim:</p>
<pre class="haskell:hs"><code>x -: f = f x</code></pre>
<p>O que nos permite aplicar funções a valores escrevendo primeiro o
valor, depois um <code>-:</code> e então a função. Então, em vez de
<code>goRight (freeTree, [])</code>, podemos escrever
<code>(freeTree, []) -: goRight</code>. Usando isso, podemos reescrever
o exemplo acima para que fique mais aparente que primeiro estamos indo
para a direita e depois para a esquerda:</p>
<pre class="haskell:hs"><code>ghci&gt; (freeTree, []) -: goRight -: goLeft
(Node &#39;W&#39; (Node &#39;C&#39; Empty Empty) (Node &#39;R&#39; Empty Empty),[L,R])</code></pre>
<h3 id="voltando-para-cima">Voltando para cima</h3>
<p>E se quisermos agora voltar para cima na nossa árvore? Pelas nossas
migalhas de pão, sabemos que a árvore atual é a subárvore esquerda do
seu pai e que ela é a subárvore direita do seu pai, mas é só isso. Elas
não nos contam o suficiente sobre o pai da subárvore atual para podermos
subir na árvore. Parece que, além da direção que tomamos, uma única
migalha deveria conter também todos os outros dados necessários para
voltarmos. Neste caso, esse dado é o elemento na árvore pai junto com a
sua subárvore direita.</p>
<p>Em geral, uma única migalha de pão deve conter todos os dados
necessários para reconstruir o nó pai. Portanto, deve ter a informação
de todos os caminhos que não tomamos e também deve saber a direção que
tomamos, mas não deve conter a subárvore em que estamos focando
atualmente. Isso ocorre porque já temos essa subárvore no primeiro
componente da tupla, então se a tivéssemos também nas migalhas, teríamos
informação duplicada.</p>
<p>Vamos modificar as nossas migalhas para que elas também contenham
informações sobre tudo o que ignoramos anteriormente ao nos movermos
para a esquerda e para a direita. Em vez de <code>Direction</code>,
criaremos um novo tipo de dado:</p>
<pre class="haskell:hs"><code>data Crumb a = LeftCrumb a (Tree a) | RightCrumb a (Tree a) deriving (Show)</code></pre>
<p>Agora, em vez de apenas <code>L</code>, temos um
<code>LeftCrumb</code> que também contém o elemento no nó do qual nos
movemos e a árvore direita que não visitamos. Em vez de <code>R</code>,
temos <code>RightCrumb</code>, que contém o elemento no nó do qual nos
movemos e a árvore esquerda que não visitamos.</p>
<p>Estas migalhas agora contêm todos os dados necessários para recriar a
árvore pela qual caminhamos. Portanto, em vez de serem apenas migalhas
de pão normais, agora elas são mais como disquetes que deixamos à medida
que avançamos, porque contêm muito mais informação do que apenas a
direção que tomamos.</p>
<p>Em essência, cada migalha de pão agora é como um nó de árvore com um
buraco. Quando nos movemos para mais fundo na árvore, a migalha carrega
toda a informação que o nó do qual nos distanciamos carregava,
<em>exceto</em> a subárvore na qual escolhemos focar. Ela também tem que
notar onde está o buraco. No caso de um <code>LeftCrumb</code>, sabemos
que nos movemos para a esquerda, então a subárvore que falta é a da
esquerda.</p>
<p>Vamos também mudar o nosso sinônimo de tipo <code>Breadcrumbs</code>
para refletir isso:</p>
<pre class="haskell:hs"><code>type Breadcrumbs a = [Crumb a]</code></pre>
<p>Em seguida, temos que modificar as funções <code>goLeft</code> e
<code>goRight</code> para armazenar informações sobre os caminhos que
não tomamos nas nossas migalhas de pão, em vez de ignorar essa
informação como faziam antes. Aqui está a <code>goLeft</code>:</p>
<pre class="haskell:hs"><code>goLeft :: (Tree a, Breadcrumbs a) -&gt; (Tree a, Breadcrumbs a)
goLeft (Node x l r, bs) = (l, LeftCrumb x r:bs)</code></pre>
<p>Você pode ver que ela é muito semelhante à nossa <code>goLeft</code>
anterior, só que em vez de apenas adicionar um <code>L</code> ao início
da nossa lista de migalhas, adicionamos um <code>LeftCrumb</code> para
significar que fomos para a esquerda e equipamos o nosso
<code>LeftCrumb</code> com o elemento no nó do qual nos movemos (que é o
<code>x</code>) e a subárvore direita que escolhemos não visitar.</p>
<p>Observe que esta função assume que a árvore atual sob foco não é
<code>Empty</code>. Uma árvore vazia não tem subárvores, então se
tentarmos ir para a esquerda a partir de uma árvore vazia, ocorrerá um
erro porque o pattern match em <code>Node</code> não terá sucesso e não
há nenhum padrão que cuide de <code>Empty</code>.</p>
<p>A <code>goRight</code> é semelhante:</p>
<pre class="haskell:hs"><code>goRight :: (Tree a, Breadcrumbs a) -&gt; (Tree a, Breadcrumbs a)
goRight (Node x l r, bs) = (r, RightCrumb x l:bs)</code></pre>
<p>Anteriormente fomos capazes de ir para a esquerda e para a direita. O
que conseguimos agora é a habilidade de realmente voltar para cima
lembrando coisas sobre os nós pais e os caminhos que não visitamos. Aqui
está a função <code>goUp</code>:</p>
<pre class="haskell:hs"><code>goUp :: (Tree a, Breadcrumbs a) -&gt; (Tree a, Breadcrumbs a)
goUp (t, LeftCrumb x r:bs) = (Node x t r, bs)
goUp (t, RightCrumb x l:bs) = (Node x l t, bs)</code></pre>
<p><img src="assets/images/zippers/asstronaut.png" class="left"
width="511" height="433" alt="asstronaut" /></p>
<p>Estamos focando na árvore <code>t</code> e verificamos qual é a
última <code>Crumb</code>. Se for uma <code>LeftCrumb</code>, então
construímos uma nova árvore onde a nossa árvore <code>t</code> é a
subárvore esquerda e usamos a informação sobre a subárvore direita que
não visitamos e o elemento para preencher o resto do <code>Node</code>.
Como voltamos, por assim dizer, e pegamos a última migalha para recriar
com ela a árvore pai, a nova lista de migalhas não a contém.</p>
<p>Observe que esta função causa um erro se já estivermos no topo de uma
árvore e quisermos subir.</p>
<p>Mais tarde, usaremos a Maybe Monad para representar possíveis falhas
ao mover o foco.</p>
<p>Com um par de <code>Tree a</code> e <code>Breadcrumbs a</code>, temos
todas as informações para reconstruir a árvore inteira e também temos um
foco em uma subárvore. Este esquema também nos permite mover facilmente
para cima, para a esquerda e para a direita. Tal par que contém uma
parte focada de uma estrutura de dados e seus arredores é chamado de
<strong>zipper</strong>, porque mover o nosso foco para cima e para
baixo na estrutura de dados assemelha-se à operação de um zíper em uma
calça comum. Portanto, é legal criarmos um sinônimo de tipo como
este:</p>
<pre class="haskell:hs"><code>type Zipper a = (Tree a, Breadcrumbs a)</code></pre>
<p>Eu preferiria nomear o sinônimo de tipo como <code>Focus</code>,
porque isso deixaria mais claro que estamos focando em uma parte de uma
estrutura de dados, mas o termo <em>zipper</em> é mais amplamente
utilizado para descrever tal configuração, então ficaremos com
<code>Zipper</code>.</p>
<h3 id="manipulando-árvores-sob-foco">Manipulando árvores sob foco</h3>
<p>Agora que podemos nos mover para cima e para baixo, vamos fazer uma
função que modifique o elemento na raiz da subárvore em que o zipper
está focando:</p>
<pre class="haskell:hs"><code>modify :: (a -&gt; a) -&gt; Zipper a -&gt; Zipper a
modify f (Node x l r, bs) = (Node (f x) l r, bs)
modify f (Empty, bs) = (Empty, bs)</code></pre>
<p>Se estivermos focando em um nó, modificamos seu elemento raiz com a
função <code>f</code>. Se estivermos focando em uma árvore vazia,
deixamos como está. Agora podemos começar com uma árvore, mover-nos para
onde quisermos e modificar um elemento, tudo isso mantendo o foco nesse
elemento para que possamos facilmente nos mover mais para cima ou para
baixo. Um exemplo:</p>
<pre class="haskell:hs"><code>ghci&gt; let newFocus = modify (\_ -&gt; &#39;P&#39;) (goRight (goLeft (freeTree,[])))</code></pre>
<p>Vamos para a esquerda, depois para a direita e então modificamos o
elemento raiz substituindo-o por um <code>'P'</code>. Isso fica ainda
melhor se usarmos <code>-:</code>:</p>
<pre class="haskell:hs"><code>ghci&gt; let newFocus = (freeTree,[]) -: goLeft -: goRight -: modify (\_ -&gt; &#39;P&#39;)</code></pre>
<p>Podemos então subir se quisermos e substituir um elemento por um
misterioso <code>'X'</code>:</p>
<pre class="haskell:hs"><code>ghci&gt; let newFocus2 = modify (\_ -&gt; &#39;X&#39;) (goUp newFocus)</code></pre>
<p>Ou se escrevêssemos com <code>-:</code>:</p>
<pre class="haskell:hs"><code>ghci&gt; let newFocus2 = newFocus -: goUp -: modify (\_ -&gt; &#39;X&#39;)</code></pre>
<p>Mover-se para cima é fácil porque as migalhas que deixamos formam a
parte da estrutura de dados em que não estamos focando, mas ela está
invertida, algo como virar uma meia do avesso. É por isso que quando
queremos subir, não temos que começar da raiz e descer, mas apenas
pegamos o topo da nossa árvore invertida, desinvertendo assim uma parte
dela e adicionando-a ao nosso foco.</p>
<p>Cada nó tem duas subárvores, mesmo que essas subárvores sejam árvores
vazias. Então, se estivermos focando em uma subárvore vazia, uma coisa
que podemos fazer é substituí-la por uma subárvore não vazia, anexando
assim uma árvore a um nó folha. O código para isso é simples:</p>
<pre class="haskell:hs"><code>attach :: Tree a -&gt; Zipper a -&gt; Zipper a
attach t (_, bs) = (t, bs)</code></pre>
<p>Recebemos uma árvore e um zipper e retornamos um novo zipper que tem
seu foco substituído pela árvore fornecida. Não só podemos estender
árvores desta forma, substituindo subárvores vazias por novas árvores,
como também podemos substituir subárvores inteiras existentes. Vamos
anexar uma árvore ao extremo esquerdo da nossa
<code>freeTree</code>:</p>
<pre class="haskell:hs"><code>ghci&gt; let farLeft = (freeTree,[]) -: goLeft -: goLeft -: goLeft -: goLeft
ghci&gt; let newFocus = farLeft -: attach (Node &#39;Z&#39; Empty Empty)</code></pre>
<p><code>newFocus</code> está agora focado na árvore que acabamos de
anexar e o resto da árvore jaz invertido nas migalhas de pão. Se
usássemos <code>topMost</code> para caminhar até o topo da árvore, seria
a mesma árvore que <code>freeTree</code>, mas com um <code>'Z'</code>
adicional no seu extremo esquerdo.</p>
<h3 id="indo-direto-para-o-topo-onde-o-ar-é-puro-e-limpo">Indo direto
para o topo, onde o ar é puro e limpo!</h3>
<p>Criar uma função que caminhe até o topo da árvore, independentemente
de onde estejamos focando, é realmente fácil. Aqui está ela:</p>
<pre class="haskell:hs"><code>topMost :: Zipper a -&gt; Zipper a
topMost (t,[]) = (t,[])
topMost z = topMost (goUp z)</code></pre>
<p>Se o nosso rastro de migalhas turbinadas estiver vazio, isso
significa que já estamos na raiz da nossa árvore, então apenas
retornamos o foco atual. Caso contrário, subimos para obter o foco do nó
pai e então aplicamos recursivamente <code>topMost</code> a ele. Então
agora podemos caminhar pela nossa árvore, indo para a esquerda, para a
direita e para cima, aplicando <code>modify</code> e <code>attach</code>
à medida que avançamos e, quando terminarmos as nossas modificações,
usamos <code>topMost</code> para focar na raiz da nossa árvore e ver as
mudanças que fizemos na perspectiva adequada.</p>
<h2 id="focusing-on-lists">Focando em listas</h2>
<p>Zippers podem ser usados com praticamente qualquer estrutura de
dados, então não é surpresa que eles possam ser usados para focar em
sublistas de listas. Afinal de contas, listas são muito parecidas com
árvores, só que onde um nó em uma árvore tem um elemento (ou não) e
várias subárvores, um nó em uma lista tem um elemento e apenas uma única
sublista. Quando <a
href="making-our-own-types-and-typeclasses.html#recursive-data-structures">implementamos
nossas próprias listas</a>, definimos o nosso tipo de dado assim:</p>
<pre class="haskell:hs"><code>data List a = Empty | Cons a (List a) deriving (Show, Read, Eq, Ord)</code></pre>
<p><img src="assets/images/zippers/picard.png" class="right" width="355"
height="380" alt="the best damn thing" /></p>
<p>Contraste isso com a nossa definição de árvore binária e fica fácil
ver como listas podem ser vistas como árvores onde cada nó tem apenas
uma subárvore.</p>
<p>Uma lista como <code>[1,2,3]</code> pode ser escrita como
<code>1:2:3:[]</code>. Ela consiste na cabeça da lista, que é
<code>1</code>, e depois na cauda da lista, que é <code>2:3:[]</code>.
Por sua vez, <code>2:3:[]</code> também tem uma cabeça, que é
<code>2</code>, e uma cauda, que é <code>3:[]</code>. Com
<code>3:[]</code>, o <code>3</code> é a cabeça e a cauda é a lista vazia
<code>[]</code>.</p>
<p>Vamos fazer um zipper para listas. Para mudar o foco nas sublistas de
uma lista, movemo-nos para frente ou para trás (enquanto com árvores nos
movíamos para cima, para a esquerda ou para a direita). A parte focada
será uma subárvore e junto com ela deixaremos migalhas de pão à medida
que avançamos. Agora, do que consistiria uma única migalha de pão para
uma lista? Quando estávamos lidando com árvores binárias, dissemos que
uma migalha tem que conter o elemento na raiz do nó pai junto com todas
as subárvores que não escolhemos. Também tinha que lembrar se fomos para
a esquerda ou para a direita. Então, tinha que ter toda a informação que
um nó tem, exceto pela subárvore em que escolhemos focar.</p>
<p>Listas são mais simples que árvores, então não temos que lembrar se
fomos para a esquerda ou para a direita, porque só existe um caminho
para ir mais fundo em uma lista. Como existe apenas uma subárvore para
cada nó, também não precisamos lembrar os caminhos que não tomamos.
Parece que tudo o que temos que lembrar é o elemento anterior. Se temos
uma lista como <code>[3,4,5]</code> e sabemos que o elemento anterior
era <code>2</code>, podemos voltar apenas colocando esse elemento no
início da nossa lista, obtendo <code>[2,3,4,5]</code>.</p>
<p>Como uma única migalha de pão aqui é apenas o elemento, não
precisamos realmente colocá-lo dentro de um tipo de dado, como fizemos
quando criamos o tipo <code>Crumb</code> para zippers de árvores:</p>
<pre class="haskell:hs"><code>type ListZipper a = ([a],[a])</code></pre>
<p>A primeira lista representa a lista em que estamos focando e a
segunda lista é a lista de migalhas de pão. Vamos fazer funções que
andam para frente e para trás em listas:</p>
<pre class="haskell:hs"><code>goForward :: ListZipper a -&gt; ListZipper a
goForward (x:xs, bs) = (xs, x:bs)

goBack :: ListZipper a -&gt; ListZipper a
goBack (xs, b:bs) = (b:xs, bs)</code></pre>
<p>Quando estamos indo para frente, focamos na cauda da lista atual e
deixamos o elemento da cabeça como uma migalha. Quando estamos nos
movendo para trás, pegamos a última migalha e a colocamos no início da
lista.</p>
<p>Aqui estão estas duas funções em ação:</p>
<pre class="haskell:hs"><code>ghci&gt; let xs = [1,2,3,4]
ghci&gt; goForward (xs,[])
([2,3,4],[1])
ghci&gt; goForward ([2,3,4],[1])
([3,4],[2,1])
ghci&gt; goForward ([3,4],[2,1])
([4],[3,2,1])
ghci&gt; goBack ([4],[3,2,1])
([3,4],[2,1])</code></pre>
<p>Vemos que as migalhas no caso das listas nada mais são do que a parte
invertida da nossa lista. O elemento do qual nos afastamos sempre vai
para a cabeça das migalhas, então é fácil voltar apenas pegando esse
elemento da cabeça das migalhas e tornando-o a cabeça do nosso foco.</p>
<p>Isso também torna mais fácil ver por que chamamos isso de zipper,
porque realmente parece o cursor de um zíper movendo-se para cima e para
baixo.</p>
<p>Se você estivesse criando um editor de texto, poderia usar uma lista
de strings para representar as linhas de texto que estão abertas
atualmente e então poderia usar um zipper para saber em qual linha o
cursor está focado no momento. Usando um zipper, também seria mais fácil
inserir novas linhas em qualquer lugar do texto ou excluir as
existentes.</p>
<h2 id="a-very-simple-file-system">Um sistema de arquivos muito
simples</h2>
<p>Agora que sabemos como os zippers funcionam, vamos usar árvores para
representar um sistema de arquivos muito simples e então fazer um zipper
para esse sistema de arquivos, o que nos permitirá mover entre pastas,
exatamente como costumamos fazer ao saltar pelo nosso sistema de
arquivos.</p>
<p>Se tomarmos uma visão simplista do sistema de arquivos hierárquico
médio, veremos que ele é composto principalmente de arquivos e pastas.
Arquivos são unidades de dados e vêm com um nome, enquanto pastas são
usadas para organizar those arquivos e podem conter arquivos ou outras
pastas. Então, digamos que um item em um sistema de arquivos é um
arquivo, que vem com um nome e alguns dados, ou uma pasta, que tem um
nome e depois um monte de itens que são eles próprios arquivos ou
pastas. Aqui está um tipo de dado para isso e alguns sinônimos de tipo
para sabermos o que é o quê:</p>
<pre class="haskell:hs"><code>type Name = String
type Data = String
data FSItem = File Name Data | Folder Name [FSItem] deriving (Show)</code></pre>
<p>Um arquivo vem com duas strings, que representam seu nome e os dados
que ele contém. Uma pasta vem com uma string que é o seu nome e uma
lista de itens. Se essa lista estiver vazia, então temos uma pasta
vazia.</p>
<p>Aqui está uma pasta com alguns arquivos e subpastas:</p>
<pre class="haskell:hs"><code>myDisk :: FSItem
myDisk =
    Folder &quot;root&quot;
        [ File &quot;goat_yelling_like_man.wmv&quot; &quot;baaaaaa&quot;
        , File &quot;pope_time.avi&quot; &quot;god bless&quot;
        , Folder &quot;pics&quot;
            [ File &quot;ape_throwing_up.jpg&quot; &quot;bleargh&quot;
            , File &quot;watermelon_smash.gif&quot; &quot;smash!!&quot;
            , File &quot;skull_man(scary).bmp&quot; &quot;Yikes!&quot;
            ]
        , File &quot;dijon_poupon.doc&quot; &quot;best mustard&quot;
        , Folder &quot;programs&quot;
            [ File &quot;fartwizard.exe&quot; &quot;10gotofart&quot;
            , File &quot;owl_bandit.dmg&quot; &quot;mov eax, h00t&quot;
            , File &quot;not_a_virus.exe&quot; &quot;really not a virus&quot;
            , Folder &quot;source code&quot;
                [ File &quot;best_hs_prog.hs&quot; &quot;main = print (fix error)&quot;
                , File &quot;random.hs&quot; &quot;main = print 4&quot;
                ]
            ]
        ]</code></pre>
<p>Isso é na verdade o que o meu disco contém agora.</p>
<h3 id="um-zipper-para-o-nosso-sistema-de-arquivos">Um zipper para o
nosso sistema de arquivos</h3>
<p><img src="assets/images/zippers/spongedisk.png" class="right"
width="243" height="271" alt="spongedisk" /></p>
<p>Agora que temos um sistema de arquivos, tudo o que precisamos é de um
zipper para podermos “zippar” e dar zoom por ele e adicionar, modificar
e remover arquivos tanto quanto pastas. Como acontece com as árvores
binárias e listas, vamos deixar migalhas de pão que contêm informações
sobre todas as coisas que escolhemos não visitar. Como dissemos, uma
única migalha de pão deve ser meio que como um nó, só que deve conter
tudo exceto a subárvore em que estamos focando atualmente. Ela também
deve notar onde o buraco está para que, uma vez que voltemos para cima,
possamos preencher o nosso foco anterior no buraco.</p>
<p>Neste caso, uma migalha de pão deve ser como uma pasta, só que deve
estar faltando a pasta que escolhemos atualmente. “Por que não como um
arquivo?”, você pergunta. Bem, porque uma vez que estamos focando em um
arquivo, não podemos nos mover mais profundamente no sistema de
arquivos, então não faz sentido deixar uma migalha de pão dizendo que
viemos de um arquivo. Um arquivo é algo como uma árvore vazia.</p>
<p>Se estamos focando na pasta <code>"root"</code> e depois focamos no
arquivo <code>"dijon_poupon.doc"</code>, como deve ser a migalha de pão
que deixamos? Bem, ela deve conter o nome de sua pasta pai junto com os
itens que vêm antes do arquivo em que estamos focando e os itens que vêm
depois dele. Portanto, tudo o que precisamos é de um <code>Name</code> e
duas listas de itens. Ao manter listas separadas para os itens que vêm
antes do item em que estamos focando e para os itens que vêm depois
dele, saberemos exatamente onde colocá-lo quando subirmos novamente.
Desta forma, sabemos onde está o buraco.</p>
<p>Aqui está o nosso tipo de migalha para o sistema de arquivos:</p>
<pre class="haskell:hs"><code>data FSCrumb = FSCrumb Name [FSItem] [FSItem] deriving (Show)</code></pre>
<p>E aqui está um sinônimo de tipo para o nosso zipper:</p>
<pre class="haskell:hs"><code>type FSZipper = (FSItem, [FSCrumb])</code></pre>
<p>Voltar para cima na hierarquia é muito simples. Apenas pegamos a
última migalha e montamos um novo foco a partir do foco atual e da
migalha. Assim:</p>
<pre class="haskell:hs"><code>fsUp :: FSZipper -&gt; FSZipper
fsUp (item, FSCrumb name ls rs:bs) = (Folder name (ls ++ [item] ++ rs), bs)</code></pre>
<p>Como nossa migalha sabia qual era o nome da pasta pai, bem como os
itens que vinham antes do nosso item focado na pasta (que é
<code>ls</code>) e os que vinham depois (que é <code>rs</code>), subir
foi fácil.</p>
<p>E quanto a ir mais fundo no sistema de arquivos? Se estivermos no
<code>"root"</code> e quisermos focar em
<code>"dijon_poupon.doc"</code>, a migalha que deixaremos incluirá o
nome <code>"root"</code> junto com os itens que precedem
<code>"dijon_poupon.doc"</code> e os que vêm depois dele.</p>
<p>Aqui está uma função que, dado um nome, foca em um arquivo ou pasta
localizado na pasta focada atual:</p>
<pre class="haskell:hs"><code>import Data.List (break)

fsTo :: Name -&gt; FSZipper -&gt; FSZipper
fsTo name (Folder folderName items, bs) =
    let (ls, item:rs) = break (nameIs name) items
    in  (item, FSCrumb folderName ls rs:bs)

nameIs :: Name -&gt; FSItem -&gt; Bool
nameIs name (Folder folderName _) = name == folderName
nameIs name (File fileName _) = name == fileName</code></pre>
<p><code>fsTo</code> recebe um <code>Name</code> e uma
<code>FSZipper</code> e retorna uma nova <code>FSZipper</code> que foca
no arquivo com o nome dado. Esse arquivo tem que estar na pasta focada
atual. Esta função não procura por todos os lados, ela apenas olha para
a pasta atual.</p>
<p><img src="assets/images/zippers/cool.png" class="left" width="205"
height="197" alt="wow cool great" /></p>
<p>Primeiro usamos <code>break</code> para quebrar a lista de itens em
uma pasta naqueles que precedem o arquivo que estamos procurando e
naqueles que vêm depois dele. Se você se lembra, <code>break</code>
recebe um predicado e uma lista e retorna um par de listas. A primeira
lista no par guarda os itens para os quais o predicado retorna
<code>False</code>. Então, uma vez que o predicado retorna
<code>True</code> para um item, ela coloca esse item e o resto da lista
no segundo item do par. Criamos uma função auxiliar chamada
<code>nameIs</code> que recebe um nome e um item do sistema de arquivos
e retorna <code>True</code> se os nomes coincidirem.</p>
<p>Então agora, <code>ls</code> é uma lista que contém os itens que
precedem o item que estamos procurando, <code>item</code> é esse próprio
item e <code>rs</code> é a lista de itens que vêm depois dele na sua
pasta. Agora que temos isso, apenas apresentamos o item que obtivemos do
<code>break</code> como o foco e construímos uma migalha que tem todos
os dados de que precisa.</p>
<p>Observe que se o nome que estamos procurando não estiver na pasta, o
padrão <code>item:rs</code> tentará fazer match em uma lista vazia e
teremos um erro.</p>
<h3 id="manipulando-o-nosso-sistema-de-arquivos">Manipulando o nosso
sistema de arquivos</h3>
<p>Além disso, se o nosso foco atual não for uma pasta, mas um arquivo,
também recebemos um erro e o programa trava.</p>
<p>Agora podemos nos mover para cima e para baixo no nosso sistema de
arquivos. Imaginemos que começamos na raiz e caminhamos até o arquivo
<code>"skull_man(scary).bmp"</code>:</p>
<pre class="haskell:hs"><code>ghci&gt; let newFocus = (myDisk,[]) -: fsTo &quot;pics&quot; -: fsTo &quot;skull_man(scary).bmp&quot;</code></pre>
<p><code>newFocus</code> agora é um zipper focado no arquivo
<code>"skull_man(scary).bmp"</code>. Vamos pegar o primeiro componente
do zipper (o foco em si) e ver se isso é realmente verdade:</p>
<pre class="haskell:hs"><code>ghci&gt; fst newFocus
File &quot;skull_man(scary).bmp&quot; &quot;Yikes!&quot;</code></pre>
<p>Vamos subir e focar no arquivo vizinho
<code>"watermelon_smash.gif"</code>:</p>
<pre class="haskell:hs"><code>ghci&gt; let newFocus2 = newFocus -: fsUp -: fsTo &quot;watermelon_smash.gif&quot;
ghci&gt; fst newFocus2
File &quot;watermelon_smash.gif&quot; &quot;smash!!&quot;</code></pre>
<p>Agora que sabemos como navegar no nosso sistema de arquivos,
manipulá-lo é fácil. Aqui está uma função que renomeia o arquivo ou
pasta atualmente focado:</p>
<pre class="haskell:hs"><code>fsRename :: Name -&gt; FSZipper -&gt; FSZipper
fsRename newName (Folder name items, bs) = (Folder newName items, bs)
fsRename newName (File name dat, bs) = (File newName dat, bs)</code></pre>
<p>Agora podemos renomear nossa pasta <code>"pics"</code> para
<code>"cspi"</code>:</p>
<pre class="haskell:hs"><code>ghci&gt; let newFocus = (myDisk,[]) -: fsTo &quot;pics&quot; -: fsRename &quot;cspi&quot; -: fsUp</code></pre>
<p>Descemos até a pasta <code>"pics"</code>, renomeamo-la e depois
subimos novamente.</p>
<p>Que tal uma função que cria um novo item na pasta atual?
Contemple:</p>
<pre class="haskell:hs"><code>fsNewFile :: FSItem -&gt; FSZipper -&gt; FSZipper
fsNewFile item (Folder folderName items, bs) =
    (Folder folderName (item:items), bs)</code></pre>
<p>Fácil como um abraço. Observe que isso travaria se tentássemos
adicionar um item mas não estivéssemos focando em uma pasta, mas sim em
um arquivo.</p>
<p>Vamos adicionar um arquivo à nossa pasta <code>"pics"</code> e depois
subir de volta para a raiz:</p>
<pre class="haskell:hs"><code>ghci&gt; let newFocus = (myDisk,[]) -: fsTo &quot;pics&quot; -: fsNewFile (File &quot;heh.jpg&quot; &quot;lol&quot;) -: fsUp</code></pre>
<p>O que é realmente legal sobre tudo isso é que, quando modificamos o
nosso sistema de arquivos, ele não o modifica realmente no lugar, mas
retorna um sistema de arquivos inteiramente novo. Dessa forma, temos
acesso ao nosso antigo sistema de arquivos (neste caso,
<code>myDisk</code>), bem como ao novo (o primeiro componente de
<code>newFocus</code>). Assim, ao usar zippers, ganhamos versionamento
de graça, o que significa que podemos sempre nos referir a versões mais
antigas das estruturas de dados mesmo depois de as termos mudado, por
assim dizer. Isso não é exclusividade dos zippers, mas é uma propriedade
do Haskell porque as suas estruturas de dados são imutáveis. Com
zippers, no entanto, ganhamos a habilidade de caminhar de forma fácil e
eficiente pelas nossas estruturas de dados, de modo que a persistência
das estruturas de dados do Haskell realmente começa a brilhar.</p>
<h2 id="watch-your-step">Cuidado onde pisa</h2>
<p>Até agora, enquanto caminhávamos pelas nossas estruturas de dados,
fossem elas árvores binárias, listas ou sistemas de arquivos, não nos
importávamos muito se dermos um passo longe demais e caíssemos. Por
exemplo, a nossa função <code>goLeft</code> recebe um zipper de uma
árvore binária e move o foco para a sua subárvore esquerda:</p>
<pre class="haskell:hs"><code>goLeft :: Zipper a -&gt; Zipper a
goLeft (Node x l r, bs) = (l, LeftCrumb x r:bs)</code></pre>
<p><img src="assets/images/zippers/bigtree.png" class="right"
width="247" height="367" alt="falling for you" /></p>
<p>Mas e se a árvore da qual estamos saindo for uma árvore vazia? Ou
seja, e se não for um <code>Node</code>, mas um <code>Empty</code>?
Neste caso, receberíamos um erro em tempo de execução porque o pattern
match falharia e não fizemos nenhum padrão para lidar com uma árvore
vazia, que não tem nenhuma subárvore. Até agora, apenas assumimos que
nunca tentaríamos focar na subárvore esquerda de uma árvore vazia, já
que sua subárvore esquerda não existe. Mas ir para a subárvore esquerda
de uma árvore vazia não faz muito sentido, e até agora apenas
convenientemente ignoramos isso.</p>
<p>Ou e se já estivéssemos na raiz de alguma árvore e não tivéssemos
nenhuma migalha de pão, mas ainda tentássemos subir? A mesma coisa
aconteceria. Parece que, ao usar zippers, qualquer passo pode ser o
nosso último (insira uma música sinistra aqui). Em outras palavras,
qualquer movimento pode resultar em sucesso, mas também pode resultar em
falha. Isso te lembra de algo? Claro, Monads! Mais especificamente, a
Maybe Monad, que adiciona um contexto de possível falha aos valores
normais.</p>
<p>Então, vamos usar a Maybe Monad para adicionar um contexto de
possível falha aos nossos movimentos. Vamos pegar as funções que
trabalham no nosso zipper de árvore binária e vamos transformá-las em
monadic functions. Primeiro, vamos cuidar da possível falha em
<code>goLeft</code> e <code>goRight</code>. Até agora, a falha das
funções que poderiam falhar foi sempre refletida no seu resultado, e
desta vez não é diferente. Aqui estão <code>goLeft</code> e
<code>goRight</code> com uma possibilidade adicional de falha:</p>
<pre class="haskell:hs"><code>goLeft :: Zipper a -&gt; Maybe (Zipper a)
goLeft (Node x l r, bs) = Just (l, LeftCrumb x r:bs)
goLeft (Empty, _) = Nothing

goRight :: Zipper a -&gt; Maybe (Zipper a)
goRight (Node x l r, bs) = Just (r, RightCrumb x l:bs)
goRight (Empty, _) = Nothing</code></pre>
<p>Legal, agora se tentarmos dar um passo à esquerda de uma árvore
vazia, recebemos um <code>Nothing</code>!</p>
<pre class="haskell:hs"><code>ghci&gt; goLeft (Empty, [])
Nothing
ghci&gt; goLeft (Node &#39;A&#39; Empty Empty, [])
Just (Empty,[LeftCrumb &#39;A&#39; Empty])</code></pre>
<p>Parece bom! E quanto a subir? O problema antes acontecia se
tentássemos subir mas não tivéssemos mais migalhas de pão, o que
significava que já estávamos na raiz da árvore. Esta é a função
<code>goUp</code> que lança um erro se não nos mantivermos dentro dos
limites da nossa árvore:</p>
<pre class="haskell:hs"><code>goUp :: Zipper a -&gt; Zipper a
goUp (t, LeftCrumb x r:bs) = (Node x t r, bs)
goUp (t, RightCrumb x l:bs) = (Node x l t, bs)</code></pre>
<p>Agora vamos modificá-la para falhar graciosamente:</p>
<pre class="haskell:hs"><code>goUp :: Zipper a -&gt; Maybe (Zipper a)
goUp (t, LeftCrumb x r:bs) = Just (Node x t r, bs)
goUp (t, RightCrumb x l:bs) = Just (Node x l t, bs)
goUp (_, []) = Nothing</code></pre>
<p>Se tivermos migalhas de pão, tudo está bem e retornamos um novo foco
com sucesso, mas se não tivermos, retornamos uma falha.</p>
<p>Antes, estas funções recebiam zippers e retornavam zippers, o que
significava que podíamos encadeá-las assim para caminhar:</p>
<pre class="haskell:hs"><code>ghci&gt; let newFocus = (freeTree,[]) -: goLeft -: goRight</code></pre>
<p>Mas agora, em vez de retornar <code>Zipper a</code>, elas retornam
<code>Maybe (Zipper a)</code>, então encadear funções desta forma não
funcionará. Tivemos um problema semelhante quando estávamos <a
href="a-fistful-of-monads.html#walk-the-line">lidando com o nosso
equilibrista</a> no capítulo sobre Monads. Ele também caminhava um passo
de cada vez e cada um dos seus passos poderia resultar em falha porque
um bando de pássaros poderia pousar num dos lados da sua vara de
equilíbrio e fazê-lo cair.</p>
<p>Agora, a piada é conosco porque somos nós que estamos caminhando e
estamos atravessando um labirinto de nossa própria autoria. Felizmente,
podemos aprender com o equilibrista e apenas fazer o que ele fez, que é
trocar a aplicação normal de funções pelo uso de <code>&gt;&gt;=</code>,
que recebe um valor com um contexto (no nosso caso, o
<code>Maybe (Zipper a)</code>, que tem um contexto de possível falha) e
o alimenta numa função enquanto garante que o contexto seja cuidado.
Então, assim como o nosso equilibrista, vamos trocar todos os nossos
operadores <code>-:</code> por <code>&gt;&gt;=</code>. Tudo bem, podemos
encadear as nossas funções novamente! Veja:</p>
<pre class="haskell:hs"><code>ghci&gt; let coolTree = Node 1 Empty (Node 3 Empty Empty)
ghci&gt; return (coolTree,[]) &gt;&gt;= goRight
Just (Node 3 Empty Empty,[RightCrumb 1 Empty])
ghci&gt; return (coolTree,[]) &gt;&gt;= goRight &gt;&gt;= goRight
Just (Empty,[RightCrumb 3 Empty,RightCrumb 1 Empty])
ghci&gt; return (coolTree,[]) &gt;&gt;= goRight &gt;&gt;= goRight &gt;&gt;= goRight
Nothing</code></pre>
<p>Usamos o <code>return</code> para colocar um zipper num
<code>Just</code> e depois usamos o <code>&gt;&gt;=</code> para
alimentar isso para a nossa função <code>goRight</code>. Primeiro,
criamos uma árvore que tem à sua esquerda uma subárvore vazia e à sua
direita um nó que tem duas subárvores vazias. Quando tentamos ir para a
direita uma vez, o resultado é um sucesso, porque a operação faz
sentido. Ir para a direita duas vezes também está tudo bem; acabamos com
o foco numa subárvore vazia. Mas ir para a direita três vezes não faria
sentido, porque não podemos ir para a direita de uma subárvore vazia,
razão pela qual o resultado é um <code>Nothing</code>.</p>
<p>Agora equipamos as nossas árvores com uma rede de segurança que nos
pegará caso caiamos. Uau, eu arrasei nesta metáfora.</p>
<p>O nosso sistema de arquivos também tem muitos casos em que uma
operação pode falhar, como tentar focar num arquivo ou pasta que não
existe. Como exercício, você pode equipar o nosso sistema de arquivos
com funções que falham graciosamente usando a Maybe Monad.</p>
            </article>
<div class="footdiv">
    <ul>
        <li style="text-align:left">
<a href="for-a-few-monads-more.html">Anterior (Por mais Alguns Monads)</a>
        </li>
        <li style="text-align:center">
            <a href="chapters.html">Índice de capítulos</a>
        </li>
        <li style="text-align:right">

        </li>
    </ul>
</div>

        </div>
    </div>
    <script type="text/javascript" src="sh/Scripts/shCore.js"></script>
    <script type="text/javascript" src="sh/Scripts/shBrushHaskell.js"></script>
    <script type="text/javascript" src="sh/Scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="assets/js/toggleShow.js"></script>
    <script type="text/javascript">
        dp.SyntaxHighlighter.HighlightAll('code');
    </script>
</body>
</html>
