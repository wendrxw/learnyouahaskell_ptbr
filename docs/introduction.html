<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aprenda Haskell para o Bem de Todos!</title>
    <link rel="stylesheet" href="assets/css/reset.css" type="text/css" />
    <link rel="stylesheet" href="assets/css/style.css" type="text/css" />
    <link rel="stylesheet" href="sh/Styles/SyntaxHighlighter.css" type="text/css" />
    <link rel="shortcut icon" href="assets/images/favicon.png" type="image/png" />
</head>
<body class="introcontent">
    <div class="bgwrapper">
        <div id="content">
<div class="footdiv" style="margin-bottom:25px;">
    <ul>
        <li style="text-align:left">

        </li>
        <li style="text-align:center">
            <a href="chapters.html">Índice de capítulos</a>
        </li>
        <li style="text-align:right">
<a href="starting-out.html" class="nxtlink">Próximo (Começando)</a>
        </li>
    </ul>
</div>

            <article>
<h1 id="introdução">Introdução</h1>
<h2 id="about-this-tutorial">Sobre este tutorial</h2>
<p>Bem-vindo ao <strong>Learn You a Haskell for Great Good</strong>! Se
você está lendo isso, é provável que queira aprender Haskell. Bem, você
veio ao lugar certo, mas vamos falar um pouco sobre este tutorial
primeiro.</p>
<p>Decidi escrever isso porque queria solidificar meu próprio
conhecimento de Haskell e porque pensei que poderia ajudar pessoas novas
em Haskell a aprendê-lo da minha perspectiva. Existem alguns tutoriais
sobre Haskell flutuando na internet. Quando eu estava começando em
Haskell, não aprendi com apenas um recurso. A maneira como aprendi foi
lendo vários tutoriais e artigos diferentes, porque cada um explicava
algo de uma maneira diferente do outro. Ao examinar vários recursos,
consegui juntar as peças e tudo se encaixou. Portanto, esta é uma
tentativa de adicionar outro recurso útil para aprender Haskell, para
que você tenha uma chance maior de encontrar um que goste.</p>
<p><img src="assets/images/introduction/bird.png" class="left"
width="230" height="192" alt="bird" /></p>
<p>Este tutorial é voltado para pessoas que têm experiência em
linguagens de programação imperativas (C, C++, Java, Python …), mas que
não programaram em uma linguagem funcional antes (Haskell, ML, OCaml …).
Embora eu aposte que, mesmo se você não tiver nenhuma experiência
significativa em programação, uma pessoa inteligente como você será
capaz de acompanhar e aprender Haskell.</p>
<p>O canal #haskell na rede Libera.Chat é um ótimo lugar para tirar
dúvidas se você estiver se sentindo travado. As pessoas lá são
extremamente gentis, pacientes e compreensivas com os novatos. Se o IRC
não é sua praia, <a
href="https://discourse.haskell.org">https://discourse.haskell.org</a> é
um fórum da comunidade popular com uma seção para aprendizes.</p>
<p>Eu falhei em aprender Haskell aproximadamente 2 vezes antes de
finalmente compreendê-lo, porque tudo parecia muito estranho para mim e
eu não entendia. Mas então, uma vez que tudo “clicou” e depois de
superar aquele obstáculo inicial, foi praticamente tudo tranquilo. Acho
que o que estou tentando dizer é: Haskell é ótimo e se você está
interessado em programação, deveria realmente aprendê-lo, mesmo que
pareça estranho no começo. Aprender Haskell é muito parecido com
aprender a programar pela primeira vez — é divertido! Isso obriga você a
pensar de forma diferente, o que nos leva à próxima seção…</p>
<h2 id="so-whats-haskell">Então, o que é Haskell?</h2>
<p><img src="assets/images/introduction/fx.png" class="right"
width="150" height="146" alt="fx" /> Haskell é uma <strong>linguagem de
programação puramente funcional</strong>. Em linguagens imperativas,
você realiza as coisas dando ao computador uma sequência de tarefas e,
em seguida, ele as executa. Ao executá-las, ele pode mudar de estado.
Por exemplo, você define a variável <code>a</code> como 5, faz algumas
coisas e depois a define como outra coisa. Você tem estruturas de fluxo
de controle para fazer alguma ação várias vezes. Na programação
puramente funcional, você não diz ao computador o que fazer como tal,
mas diz a ele o que as coisas <em>são</em>. O fatorial de um número é o
produto de todos os números de 1 até esse número, a soma de uma lista de
números é o primeiro número mais a soma de todos os outros números, e
assim por diante. Você expressa isso na forma de funções. Você também
não pode definir uma variável como algo e depois defini-la como outra
coisa mais tarde. Se você diz que <code>a</code> é 5, não pode dizer que
é outra coisa depois, porque acabou de dizer que era 5. O que você é,
algum tipo de mentiroso? Portanto, em linguagens puramente funcionais,
uma função não tem efeitos colaterais. A única coisa que uma função pode
fazer é calcular algo e retorná-lo como resultado. A princípio, isso
parece meio limitante, mas na verdade tem algumas consequências muito
boas: se uma função for chamada duas vezes com os mesmos parâmetros, é
garantido que retornará o mesmo resultado. Isso é chamado de
transparência referencial e não apenas permite que o compilador
raciocine sobre o comportamento do programa, mas também permite que você
deduza facilmente (e até prove) que uma função está correta e, em
seguida, construa funções mais complexas colando funções simples umas
nas outras.</p>
<p><img src="assets/images/introduction/lazy.png" class="right"
width="240" height="209" alt="lazy" /> Haskell é <strong>preguiçoso
(lazy)</strong>. Isso significa que, a menos que seja especificamente
instruído de outra forma, o Haskell não executará funções e calculará
coisas até que seja realmente forçado a mostrar um resultado. Isso
combina bem com a transparência referencial e permite que você pense nos
programas como uma série de <strong>transformações em dados</strong>.
Também permite coisas legais, como estruturas de dados infinitas.
Digamos que você tenha uma lista imutável de números
<code>xs = [1,2,3,4,5,6,7,8]</code> e uma função <code>doubleMe</code>
que multiplica cada elemento por 2 e depois retorna uma nova lista. Se
quiséssemos multiplicar nossa lista por 8 em uma linguagem imperativa e
fizéssemos <code>doubleMe(doubleMe(doubleMe(xs)))</code>, provavelmente
passaria pela lista uma vez e faria uma cópia e depois a retornaria. Em
seguida, passaria pela lista mais duas vezes e retornaria o resultado.
Em uma linguagem preguiçosa, chamar <code>doubleMe</code> em uma lista
sem forçá-la a mostrar o resultado acaba com o programa meio que dizendo
“Sim, sim, farei isso mais tarde!”. Mas assim que você quiser ver o
resultado, o primeiro <code>doubleMe</code> diz ao segundo que quer o
resultado, agora! O segundo diz isso ao terceiro e o terceiro
relutantemente devolve um 1 dobrado, que é um 2. O segundo recebe isso e
devolve 4 para o primeiro. O primeiro vê isso e diz que o primeiro
elemento é 8. Portanto, ele faz apenas uma passagem pela lista e somente
quando você realmente precisa. Dessa forma, quando você quer algo de uma
linguagem preguiçosa, pode apenas pegar alguns dados iniciais e
transformá-los e corrigi-los com eficiência para que se assemelhem ao
que você deseja no final.</p>
<p><img src="assets/images/introduction/boat.png" class="right"
width="160" height="153" alt="boat" /> Haskell é <strong>estaticamente
tipado</strong>. Quando você compila seu programa, o compilador sabe
qual pedaço de código é um número, qual é uma string e assim por diante.
Isso significa que muitos erros possíveis são detectados em tempo de
compilação. Se você tentar somar um número e uma string, o compilador
reclamará com você. Haskell usa um sistema de tipos muito bom que possui
<strong>inferência de tipos</strong>. Isso significa que você não
precisa rotular explicitamente cada pedaço de código com um tipo, porque
o sistema de tipos pode descobrir de forma inteligente muito sobre ele.
Se você disser <code>a = 5 + 4</code>, não precisa dizer a Haskell que
<code>a</code> é um número, ele pode descobrir isso sozinho. A
inferência de tipos também permite que seu código seja mais geral. Se
uma função que você cria recebe dois parâmetros e os soma e você não
declara explicitamente seu tipo, a função funcionará em quaisquer dois
parâmetros que ajam como números.</p>
<p>Haskell é <strong>elegante e conciso</strong>. Como usa muitos
conceitos de alto nível, os programas Haskell geralmente são mais curtos
que seus equivalentes imperativos. E programas mais curtos são mais
fáceis de manter do que os mais longos e têm menos bugs.</p>
<p>Haskell foi feito por um <strong>pessoal muito inteligente</strong>
(com PhDs). O trabalho em Haskell começou em 1987, quando um comitê de
pesquisadores se reuniu para projetar uma linguagem incrível. Em 2003, o
Haskell Report foi publicado, o que define uma versão estável da
linguagem.</p>
<h2 id="what-you-need">O que você precisa para começar</h2>
<p>Um editor de texto e um compilador Haskell. Você provavelmente já tem
seu editor de texto favorito instalado, então não perderemos tempo com
isso. Para os fins deste tutorial, usaremos o GHC, o compilador Haskell
mais amplamente utilizado. A melhor maneira de começar é baixar o <a
href="https://www.haskell.org/ghcup/">GHCup</a>, que é o instalador
Haskell recomendado.</p>
<p>O GHC pode pegar um arquivo Haskell (eles geralmente têm uma extensão
.hs) e compilá-lo, mas também possui um modo interativo que permite
interagir interativamente com arquivos. Interativamente. Você pode
chamar funções de arquivos que carrega e os resultados são exibidos
imediatamente. Para aprender, é muito mais fácil e rápido do que
compilar toda vez que você faz uma alteração e depois executar o
programa no prompt. O modo interativo é invocado digitando
<code>ghci</code> no seu prompt. Se você definiu algumas funções em um
arquivo chamado, digamos, <code>myfunctions.hs</code>, você carrega
essas funções digitando <code>:l myfunctions</code> e, em seguida, pode
brincar com elas, desde que <code>myfunctions.hs</code> esteja na mesma
pasta de onde o <code>ghci</code> foi invocado. Se você alterar o
arquivo .hs, basta executar <code>:l myfunctions</code> novamente ou
fazer <code>:r</code>, o que é equivalente porque recarrega o arquivo
atual. O fluxo de trabalho usual para mim ao brincar com as coisas é
definir algumas funções em um arquivo .hs, carregá-lo e mexer com elas e
depois alterar o arquivo .hs, carregá-lo novamente e assim por diante.
Isso também é o que faremos aqui.</p>
            </article>
<div class="footdiv">
    <ul>
        <li style="text-align:left">

        </li>
        <li style="text-align:center">
            <a href="chapters.html">Índice de capítulos</a>
        </li>
        <li style="text-align:right">
<a href="starting-out.html" class="nxtlink">Próximo (Começando)</a>
        </li>
    </ul>
</div>

        </div>
    </div>
    <script type="text/javascript" src="sh/Scripts/shCore.js"></script>
    <script type="text/javascript" src="sh/Scripts/shBrushHaskell.js"></script>
    <script type="text/javascript" src="sh/Scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="assets/js/toggleShow.js"></script>
    <script type="text/javascript">
        dp.SyntaxHighlighter.HighlightAll('code');
    </script>
</body>
</html>
