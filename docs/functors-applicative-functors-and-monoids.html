<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aprenda Haskell para o Bem de Todos!</title>
    <link rel="stylesheet" href="assets/css/reset.css" type="text/css" />
    <link rel="stylesheet" href="assets/css/style.css" type="text/css" />
    <link rel="stylesheet" href="sh/Styles/SyntaxHighlighter.css" type="text/css" />
    <link rel="shortcut icon" href="assets/images/favicon.png" type="image/png" />
</head>
<body class="introcontent">
    <div class="bgwrapper">
        <div id="content">
<div class="footdiv" style="margin-bottom:25px;">
    <ul>
        <li style="text-align:left">
<a href="functionally-solving-problems.html">Anterior (Resolvendo Problemas Funcionalmente)</a>
        </li>
        <li style="text-align:center">
            <a href="chapters.html">Índice de capítulos</a>
        </li>
        <li style="text-align:right">
<a href="a-fistful-of-monads.html" class="nxtlink">Próximo (Por um Punhado de Monads)</a>
        </li>
    </ul>
</div>

            <article>
<h1 id="functors-applicative-functors-e-monoids">Functors, Applicative
Functors e Monoids</h1>
<p>A combinação de pureza, funções de alta ordem, tipos de dados
algébricos parametrizados e typeclasses do Haskell nos permite
implementar polimorfismo em um nível muito mais alto do que é possível
em outras linguagens. Não precisamos pensar em tipos pertencentes a uma
grande hierarquia de tipos. Em vez disso, pensamos sobre como os tipos
podem agir e então os conectamos com as typeclasses apropriadas. Um
<code>Int</code> pode agir como muitas coisas. Ele pode agir como algo
que pode ser igualado, como algo ordenado, como algo enumerável,
etc.</p>
<p>Typeclasses são abertas, o que significa que podemos definir nosso
próprio tipo de dados, pensar sobre como ele pode agir e conectá-lo com
as typeclasses que definem seus comportamentos. Por causa disso e por
causa do ótimo sistema de tipos do Haskell que nos permite saber muito
sobre uma função apenas conhecendo sua declaração de tipo, podemos
definir typeclasses que definem um comportamento que é muito geral e
abstrato. Conhecemos typeclasses que definem operações para ver se duas
coisas são iguais ou comparar duas coisas por alguma ordem. Esses são
comportamentos muito abstratos e elegantes, mas não pensamos neles como
algo muito especial porque lidamos com eles na maior parte de nossas
vidas. Recentemente conhecemos Functors, que são basicamente coisas que
podem ser mapeadas. Esse é um exemplo de uma propriedade útil e ainda
assim bastante abstrata que as typeclasses podem descrever. Neste
capítulo, examinaremos mais de perto os Functors, juntamente com versões
ligeiramente mais fortes e úteis de Functors chamadas Applicative
Functors. Também daremos uma olhada em Monoids, que são meio que como
meias.</p>
<h2 id="functors-redux">Functors redux</h2>
<p><img
src="assets/images/functors-applicative-functors-and-monoids/frogtor.png"
class="right" width="369" height="243"
alt="frogs dont even need money" /></p>
<p>Ainda assim, aqui vai uma rápida recapitulação: Functors são coisas
que podem ser mapeadas, como listas, <code>Maybe</code>s, árvores e
afins. Em Haskell, eles são descritos pela typeclass
<code>Functor</code>, que tem apenas um método de typeclass, a saber
<code>fmap</code>, que tem um tipo de
<code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>. Ele diz: me dê uma
função que pega um <code>a</code> e retorna um <code>b</code> e uma
caixa com um <code>a</code> (ou vários deles) dentro dela e eu te darei
uma caixa com um <code>b</code> (ou vários deles) dentro dela. Ele meio
que aplica a função ao elemento dentro da caixa.</p>
<div class="hintbox">
<p><strong>Um conselho.</strong> Muitas vezes a analogia da caixa é
usada para ajudar você a ter alguma intuição de como os Functors
funcionam, e mais tarde, provavelmente usaremos a mesma analogia para
Applicative Functors e Monads. É uma analogia ok que ajuda as pessoas a
entender Functors no início, apenas não leve muito ao pé da letra,
porque para alguns Functors a analogia da caixa tem que ser esticada
muito para ainda manter alguma verdade. Um termo mais correto para o que
é um Functor seria <em>contexto computacional</em>. O contexto pode ser
que a computação pode ter um valor ou pode ter falhado
(<code>Maybe</code> e <code>Either a</code>) ou que pode haver mais
valores (listas), coisas assim.</p>
</div>
<p>Se quisermos fazer de um construtor de tipo uma instância de
<code>Functor</code>, ele tem que ter um kind de <code>* -&gt; *</code>,
o que significa que ele tem que tomar exatamente um tipo concreto como
parâmetro de tipo. Por exemplo, <code>Maybe</code> pode ser feito uma
instância porque ele pega um parâmetro de tipo para produzir um tipo
concreto, como <code>Maybe Int</code> ou <code>Maybe String</code>. Se
um construtor de tipo pega dois parâmetros, como <code>Either</code>,
temos que aplicar parcialmente o construtor de tipo até que ele pegue
apenas um parâmetro de tipo. Então não podemos escrever
<code>instance Functor Either where</code>, mas podemos escrever
<code>instance Functor (Either a) where</code> e então se imaginarmos
que <code>fmap</code> é apenas para <code>Either a</code>, ele teria uma
declaração de tipo de
<code>fmap :: (b -&gt; c) -&gt; Either a b -&gt; Either a c</code>. Como
você pode ver, a parte <code>Either a</code> é fixa, porque
<code>Either a</code> pega apenas um parâmetro de tipo, enquanto apenas
<code>Either</code> pega dois, então
<code>fmap :: (b -&gt; c) -&gt; Either b -&gt; Either c</code> não faria
muito sentido.</p>
<p>Aprendemos até agora como muitos tipos (bem, construtores de tipos na
verdade) são instâncias de <code>Functor</code>, como <code>[]</code>,
<code>Maybe</code>, <code>Either a</code> e um tipo <code>Tree</code>
que fizemos por conta própria. Vimos como podemos mapear funções sobre
eles para um grande bem. Nesta seção, daremos uma olhada em mais duas
instâncias de functor, a saber <code>IO</code> e
<code>(-&gt;) r</code>.</p>
<p>Se algum valor tem um tipo de, digamos, <code>IO String</code>, isso
significa que é uma ação de E/S que, quando executada, sairá para o
mundo real e pegará alguma string para nós, que ela produzirá como
resultado. Podemos usar <code>&lt;-</code> na sintaxe <em>do</em> para
vincular esse resultado a um nome. Mencionamos que ações de E/S são como
caixas com pezinhos que saem e buscam algum valor do mundo exterior para
nós. Podemos inspecionar o que elas buscaram, mas depois de inspecionar,
temos que embrulhar o valor de volta em <code>IO</code>. Ao pensar nessa
analogia da caixa com pezinhos, podemos ver como <code>IO</code> age
como um functor.</p>
<p>Vamos ver como <code>IO</code> é uma instância de
<code>Functor</code>. Quando damos <code>fmap</code> de uma função sobre
uma ação de E/S, queremos obter de volta uma ação de E/S que faz a mesma
coisa, mas tem nossa função aplicada sobre seu valor resultante.</p>
<pre class="haskell:hs"><code>instance Functor IO where
    fmap f action = do
        result &lt;- action
        return (f result)</code></pre>
<p>O resultado de mapear algo sobre uma ação de E/S será uma ação de
E/S, então logo de cara usamos a sintaxe <em>do</em> para colar duas
ações e fazer uma nova. Na implementação para <code>fmap</code>, fazemos
uma nova ação de E/S que primeiro executa a ação de E/S original e chama
seu resultado de <code>result</code>. Então, fazemos
<code>return (f result)</code>. <code>return</code> é, como você sabe,
uma função que faz uma ação de E/S que não faz nada além de apresentar
algo como seu resultado. A ação que um bloco <em>do</em> produz sempre
terá o valor resultante de sua última ação. É por isso que usamos return
para fazer uma ação de E/S que realmente não faz nada, ela apenas
apresenta <code>f result</code> como o resultado da nova ação de
E/S.</p>
<p>Podemos brincar com isso para ganhar alguma intuição. É muito
simples, na verdade. Confira este pedaço de código:</p>
<pre class="haskell:hs"><code>main = do line &lt;- getLine
          let line&#39; = reverse line
          putStrLn $ &quot;You said &quot; ++ line&#39; ++ &quot; backwards!&quot;
          putStrLn $ &quot;Yes, you really said&quot; ++ line&#39; ++ &quot; backwards!&quot;</code></pre>
<p>O usuário é solicitado por uma linha e nós a devolvemos ao usuário,
só que invertida. Aqui está como reescrever isso usando
<code>fmap</code>:</p>
<pre class="haskell:hs"><code>main = do line &lt;- fmap reverse getLine
          putStrLn $ &quot;You said &quot; ++ line ++ &quot; backwards!&quot;
          putStrLn $ &quot;Yes, you really said&quot; ++ line ++ &quot; backwards!&quot;</code></pre>
<p><img
src="assets/images/functors-applicative-functors-and-monoids/alien.png"
class="left" width="262" height="212" alt="w00ooOoooOO" /></p>
<p>Assim como quando damos <code>fmap</code> de <code>reverse</code>
sobre <code>Just "blah"</code> para obter <code>Just "halb"</code>,
podemos dar <code>fmap</code> de <code>reverse</code> sobre
<code>getLine</code>. <code>getLine</code> é uma ação de E/S que tem um
tipo de <code>IO String</code> e mapear <code>reverse</code> sobre ela
nos dá uma ação de E/S que sairá para o mundo real e pegará uma linha e
então aplicará <code>reverse</code> ao seu resultado. Como podemos
aplicar uma função a algo que está dentro de uma caixa
<code>Maybe</code>, podemos aplicar uma função ao que está dentro de uma
caixa <code>IO</code>, só que ela tem que sair para o mundo real para
pegar algo. Então, quando a vinculamos a um nome usando
<code>&lt;-</code>, o nome refletirá o resultado que já tem
<code>reverse</code> aplicado a ele.</p>
<p>A ação de E/S <code>fmap (++"!") getLine</code> se comporta
exatamente como <code>getLine</code>, só que seu resultado sempre tem
<code>"!"</code> anexado a ele!</p>
<p>Se olharmos para qual seria o tipo de <code>fmap</code> se fosse
limitado a <code>IO</code>, seria
<code>fmap :: (a -&gt; b) -&gt; IO a -&gt; IO b</code>.
<code>fmap</code> pega uma função e uma ação de E/S e retorna uma nova
ação de E/S que é como a antiga, exceto que a função é aplicada ao seu
resultado contido.</p>
<p>Se você se encontrar vinculando o resultado de uma ação de E/S a um
nome, apenas para aplicar uma função a isso e chamar isso de outra
coisa, considere usar <code>fmap</code>, porque parece mais bonito. Se
você quiser aplicar múltiplas transformações a alguns dados dentro de um
functor, você pode declarar sua própria função no nível superior, fazer
uma função lambda ou, idealmente, usar composição de funções:</p>
<pre class="haskell:hs"><code>import Data.Char
import Data.List

main = do line &lt;- fmap (intersperse &#39;-&#39; . reverse . map toUpper) getLine
          putStrLn line</code></pre>
<pre class="plain"><code>$ runhaskell fmapping_io.hs
hello there
E-R-E-H-T- -O-L-L-E-H</code></pre>
<p>Como você provavelmente sabe,
<code>intersperse '-' . reverse . map toUpper</code> é uma função que
pega uma string, mapeia <code>toUpper</code> sobre ela, aplica
<code>reverse</code> a esse resultado e então aplica
<code>intersperse '-'</code> a esse resultado. É como escrever
<code>(\xs -&gt; intersperse '-' (reverse (map toUpper xs)))</code>, só
que mais bonito.</p>
<p>Outra instância de <code>Functor</code> com a qual estamos lidando o
tempo todo, mas não sabíamos que era um <code>Functor</code> é
<code>(-&gt;) r</code>. Você provavelmente está um pouco confuso agora,
já que o que diabos <code>(-&gt;) r</code> significa? O tipo de função
<code>r -&gt; a</code> pode ser reescrito como <code>(-&gt;) r a</code>,
muito parecido com como podemos escrever <code>2 + 3</code> como
<code>(+) 2 3</code>. Quando olhamos para isso como
<code>(-&gt;) r a</code>, podemos ver <code>(-&gt;)</code> sob uma luz
ligeiramente diferente, porque vemos que é apenas um construtor de tipo
que pega dois parâmetros de tipo, assim como <code>Either</code>. Mas
lembre-se, dissemos que um construtor de tipo tem que pegar exatamente
um parâmetro de tipo para que possa ser feito uma instância de
<code>Functor</code>. É por isso que não podemos fazer
<code>(-&gt;)</code> uma instância de <code>Functor</code>, mas se
aplicarmos parcialmente a <code>(-&gt;) r</code>, não há problemas. Se a
sintaxe permitisse que construtores de tipo fossem parcialmente
aplicados com seções (como podemos aplicar parcialmente <code>+</code>
fazendo <code>(2+)</code>, que é o mesmo que <code>(+) 2</code>), você
poderia escrever <code>(-&gt;) r</code> como <code>(r -&gt;)</code>.
Como as funções são Functors? Bem, vamos dar uma olhada na
implementação, que fica em <code>Control.Monad.Instances</code></p>
<div class="hintbox">
<p>Geralmente marcamos funções que pegam qualquer coisa e retornam
qualquer coisa como <code>a -&gt; b</code>. <code>r -&gt; a</code> é a
mesma coisa, apenas usamos letras diferentes para as variáveis de
tipo.</p>
</div>
<pre class="haskell:hs"><code>instance Functor ((-&gt;) r) where
    fmap f g = (\x -&gt; f (g x))</code></pre>
<p>Se a sintaxe permitisse, poderia ter sido escrito como</p>
<pre class="haskell:hs"><code>instance Functor (r -&gt;) where
    fmap f g = (\x -&gt; f (g x))</code></pre>
<p>Mas não permite, então temos que escrever da maneira anterior.</p>
<p>Primeiro de tudo, vamos pensar sobre o tipo de <code>fmap</code>. É
<code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>. Agora o que
faremos é substituir mentalmente todos os <code>f</code>s, que são o
papel que nossa instância de Functor desempenha, por
<code>(-&gt;) r</code>s. Faremos isso para ver como <code>fmap</code>
deve se comportar para esta instância em particular. Obtemos
<code>fmap :: (a -&gt; b) -&gt; ((-&gt;) r a) -&gt; ((-&gt;) r b)</code>.
Agora o que podemos fazer é escrever os tipos <code>(-&gt;) r a</code> e
<code>(-&gt; r b)</code> como infixos <code>r -&gt; a</code> e
<code>r -&gt; b</code>, como normalmente fazemos com funções. O que
obtemos agora é
<code>fmap :: (a -&gt; b) -&gt; (r -&gt; a) -&gt; (r -&gt; b)</code>.</p>
<p>Hmmm OK. Mapear uma função sobre uma função tem que produzir uma
função, assim como mapear uma função sobre um <code>Maybe</code> tem que
produzir um <code>Maybe</code> e mapear uma função sobre uma lista tem
que produzir uma lista. O que o tipo
<code>fmap :: (a -&gt; b) -&gt; (r -&gt; a) -&gt; (r -&gt; b)</code>
para esta instância nos diz? Bem, vemos que pega uma função de
<code>a</code> para <code>b</code> e uma função de <code>r</code> para
<code>a</code> e retorna uma função de <code>r</code> para
<code>b</code>. Isso te lembra alguma coisa? Sim! Composição de funções!
Canalizamos a saída de <code>r -&gt; a</code> para a entrada de
<code>a -&gt; b</code> para obter uma função <code>r -&gt; b</code>, que
é exatamente do que se trata a composição de funções. Se você olhar como
a instância é definida acima, verá que é apenas composição de funções.
Outra maneira de escrever esta instância seria:</p>
<pre class="haskell:hs"><code>instance Functor ((-&gt;) r) where
    fmap = (.)</code></pre>
<p>Isso torna a revelação de que usar <code>fmap</code> sobre funções é
apenas composição meio óbvia. Faça
<code>:m + Control.Monad.Instances</code>, já que é onde a instância é
definida e então tente brincar mapeando sobre funções.</p>
<pre class="haskell:hs"><code>ghci&gt; :t fmap (*3) (+100)
fmap (*3) (+100) :: (Num a) =&gt; a -&gt; a
ghci&gt; fmap (*3) (+100) 1
303
ghci&gt; (*3) `fmap` (+100) $ 1
303
ghci&gt; (*3) . (+100) $ 1
303
ghci&gt; fmap (show . (*3)) (*100) 1
&quot;300&quot;</code></pre>
<p>Podemos chamar <code>fmap</code> como uma função infixa para que a
semelhança com <code>.</code> seja clara. Na segunda linha de entrada,
estamos mapeando <code>(*3)</code> sobre <code>(+100)</code>, o que
resulta em uma função que pegará uma entrada, chamará
<code>(+100)</code> nela e então chamará <code>(*3)</code> nesse
resultado. Chamamos essa função com <code>1</code>.</p>
<p>Como a analogia da caixa se sustenta aqui? Bem, se você esticar, ela
se sustenta. Quando usamos <code>fmap (+3)</code> sobre
<code>Just 3</code>, é fácil imaginar o <code>Maybe</code> como uma
caixa que tem algum conteúdo no qual aplicamos a função
<code>(+3)</code>. Mas e quando estamos fazendo
<code>fmap (*3) (+100)</code>? Bem, você pode pensar na função
<code>(+100)</code> como uma caixa que contém seu eventual resultado.
Meio como uma ação de E/S que pode ser pensada como uma caixa que sairá
para o mundo real e buscará algum resultado. Usar <code>fmap (*3)</code>
em <code>(+100)</code> criará outra função que age como
<code>(+100)</code>, só que antes de produzir um resultado,
<code>(*3)</code> será aplicado a esse resultado. Agora podemos ver como
<code>fmap</code> age exatamente como <code>.</code> para funções.</p>
<p>O fato de que <code>fmap</code> é composição de funções quando usado
em funções não é tão terrivelmente útil agora, mas pelo menos é muito
interessante. Também dobra um pouco nossas mentes e nos permite ver como
coisas que agem mais como computações do que caixas (<code>IO</code> e
<code>(-&gt;) r</code>) podem ser Functors. A função sendo mapeada sobre
uma computação resulta na mesma computação, mas o resultado dessa
computação é modificado com a função.</p>
<p><img
src="assets/images/functors-applicative-functors-and-monoids/lifter.png"
class="right" width="443" height="450"
alt="lifting a function is easier than lifting a million pounds" /></p>
<p>Antes de prosseguirmos para as regras que <code>fmap</code> deve
seguir, vamos pensar sobre o tipo de <code>fmap</code> mais uma vez. Seu
tipo é <code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>. Estamos
perdendo a restrição de classe <code>(Functor f) =&gt;</code>, mas a
deixamos de fora aqui por brevidade, porque estamos falando sobre
Functors de qualquer maneira, então sabemos o que o <code>f</code>
significa. Quando aprendemos pela primeira vez sobre <a
href="higher-order-functions.html#curried-functions">funções
curried</a>, dissemos que todas as funções Haskell na verdade pegam um
parâmetro. Uma função <code>a -&gt; b -&gt; c</code> na verdade pega
apenas um parâmetro de tipo <code>a</code> e então retorna uma função
<code>b -&gt; c</code>, que pega um parâmetro e retorna um
<code>c</code>. É assim que se chamarmos uma função com poucos
parâmetros (ou seja, parcialmente aplicá-la), obtemos de volta uma
função que pega o número de parâmetros que deixamos de fora (se
estivermos pensando em funções como pegando vários parâmetros
novamente). Então <code>a -&gt; b -&gt; c</code> pode ser escrito como
<code>a -&gt; (b -&gt; c)</code>, para tornar o currying mais
aparente.</p>
<p>Na mesma veia, se escrevermos
<code>fmap :: (a -&gt; b) -&gt; (f a -&gt; f b)</code>, podemos pensar
em <code>fmap</code> não como uma função que pega uma função e um
Functor e retorna um Functor, mas como uma função que pega uma função e
retorna uma nova função que é exatamente como a antiga, só que pega um
Functor como parâmetro e retorna um Functor como resultado. Ela pega uma
função <code>a -&gt; b</code> e retorna uma função
<code>f a -&gt; f b</code>. Isso é chamado de <em>levantar</em>
(lifting) uma função. Vamos brincar com essa ideia usando o comando
<code>:t</code> do GHCI:</p>
<pre class="haskell:hs"><code>ghci&gt; :t fmap (*2)
fmap (*2) :: (Num a, Functor f) =&gt; f a -&gt; f a
ghci&gt; :t fmap (replicate 3)
fmap (replicate 3) :: (Functor f) =&gt; f a -&gt; f [a]</code></pre>
<p>A expressão <code>fmap (*2)</code> é uma função que pega um functor
<code>f</code> sobre números e retorna um functor sobre números. Esse
functor pode ser uma lista, um <code>Maybe</code>, um
<code>Either String</code>, o que for. A expressão
<code>fmap (replicate 3)</code> pegará um functor sobre qualquer tipo e
retornará um functor sobre uma lista de elementos desse tipo.</p>
<div class="hintbox">
<p>Quando dizemos <em>um functor sobre números</em>, você pode pensar
nisso como <em>um functor que tem números nele</em>. O primeiro é um
pouco mais chique e tecnicamente mais correto, mas o último é geralmente
mais fácil de entender.</p>
</div>
<p>Isso é ainda mais aparente se aplicarmos parcialmente, digamos,
<code>fmap (++"!")</code> e então vincularmos a um nome no GHCI.</p>
<p>Você pode pensar em <code>fmap</code> como uma função que pega uma
função e um Functor e então mapeia essa função sobre o Functor, ou você
pode pensar nisso como uma função que pega uma função e levanta essa
função para que ela opere em Functors. Ambas as visões estão corretas e
em Haskell, equivalentes.</p>
<p>O tipo
<code>fmap (replicate 3) :: (Functor f) =&gt; f a -&gt; f [a]</code>
significa que a função funcionará em qualquer Functor. O que exatamente
ela fará depende de qual Functor a usamos. Se usarmos
<code>fmap (replicate 3)</code> em uma lista, a implementação da lista
para <code>fmap</code> será escolhida, que é apenas <code>map</code>. Se
usarmos em um <code>Maybe a</code>, ela aplicará
<code>replicate 3</code> ao valor dentro do <code>Just</code>, ou se for
<code>Nothing</code>, então permanece <code>Nothing</code>.</p>
<pre class="haskell:hs"><code>ghci&gt; fmap (replicate 3) [1,2,3,4]
[[1,1,1],[2,2,2],[3,3,3],[4,4,4]]
ghci&gt; fmap (replicate 3) (Just 4)
Just [4,4,4]
ghci&gt; fmap (replicate 3) (Right &quot;blah&quot;)
Right [&quot;blah&quot;,&quot;blah&quot;,&quot;blah&quot;]
ghci&gt; fmap (replicate 3) Nothing
Nothing
ghci&gt; fmap (replicate 3) (Left &quot;foo&quot;)
Left &quot;foo&quot;</code></pre>
<p>A seguir, vamos olhar para as <strong>leis dos Functors</strong>.
Para que algo seja um Functor, ele deve satisfazer algumas leis. Todos
os Functors devem exibir certos tipos de propriedades e comportamentos
semelhantes a Functors. Eles devem se comportar de forma confiável como
coisas que podem ser mapeadas. Chamar <code>fmap</code> em um Functor
deve apenas mapear uma função sobre o Functor, nada mais. Esse
comportamento é descrito nas leis dos Functors. Existem duas que todas
as instâncias de <code>Functor</code> devem seguir. Elas não são
aplicadas pelo Haskell automaticamente, então você tem que testá-las
você mesmo.</p>
<p><strong>A primeira lei dos Functors afirma que se mapearmos a função
<code>id</code> sobre um Functor, o Functor que obtemos de volta deve
ser o mesmo que o Functor original.</strong> Se escrevermos isso um
pouco mais formalmente, significa que <code
class="label law">fmap id = id</code>. Então, essencialmente, isso diz
que se fizermos <code>fmap id</code> sobre um Functor, deve ser o mesmo
que apenas chamar <code>id</code> no Functor. Lembre-se, <code>id</code>
é a função identidade, que apenas retorna seu parâmetro não modificado.
Também pode ser escrita como <code>\x -&gt; x</code>. Se virmos o
functor como algo que pode ser mapeado, a lei <code
class="label law">fmap id = id</code> parece meio trivial ou óbvia.</p>
<p>Vamos ver se essa lei se sustenta para alguns valores de
functores.</p>
<pre class="haskell:hs"><code>ghci&gt; fmap id (Just 3)
Just 3
ghci&gt; id (Just 3)
Just 3
ghci&gt; fmap id [1..5]
[1,2,3,4,5]
ghci&gt; id [1..5]
[1,2,3,4,5]
ghci&gt; fmap id []
[]
ghci&gt; fmap id Nothing
Nothing</code></pre>
<p>Se olharmos para a implementação de <code>fmap</code> para, digamos,
<code>Maybe</code>, podemos descobrir por que a primeira lei dos
functores se sustenta.</p>
<pre class="haskell:hs"><code>instance Functor Maybe where
    fmap f (Just x) = Just (f x)
    fmap f Nothing = Nothing</code></pre>
<p>Imaginamos que <code>id</code> desempenha o papel do parâmetro
<code>f</code> na implementação. Vemos que se dermos
<code>fmap id</code> sobre <code>Just x</code>, o resultado será
<code>Just (id x)</code>, e como <code>id</code> apenas retorna seu
parâmetro, podemos deduzir que <code>Just (id x)</code> é igual a
<code>Just x</code>. Então agora sabemos que se mapearmos
<code>id</code> sobre um valor <code>Maybe</code> com um construtor de
valor <code>Just</code>, obtemos o mesmo valor de volta.</p>
<p>Ver que mapear <code>id</code> sobre um valor <code>Nothing</code>
retorna o mesmo valor é trivial. Então, a partir dessas duas equações na
implementação para <code>fmap</code>, vemos que a lei
<code>fmap id = id</code> se sustenta.</p>
<p><img
src="assets/images/functors-applicative-functors-and-monoids/justice.png"
class="left" width="345" height="428"
alt="justice is blind, but so is my dog" /></p>
<p><strong>A segunda lei diz que compor duas funções e então mapear a
função resultante sobre um Functor deve ser o mesmo que primeiro mapear
uma função sobre o Functor e então mapear a outra.</strong> Formalmente
escrito, isso significa que <code
class="label law">fmap (f . g) = fmap f . fmap g</code>. Ou para
escrever de outra maneira, para qualquer Functor <em>F</em>, o seguinte
deve ser válido: <code
class="label law">fmap (f . g) F = fmap f (fmap g F)</code>.</p>
<p>Se pudermos mostrar que algum tipo obedece a ambas as leis dos
Functors, podemos confiar que ele terá os mesmos comportamentos
fundamentais que outros Functors quando se trata de mapeamento. Podemos
saber que quando usamos <code>fmap</code> nele, não haverá nada além de
mapeamento acontecendo nos bastidores e que ele agirá como uma coisa que
pode ser mapeada, ou seja, um Functor. Você descobre como a segunda lei
se sustenta para algum tipo olhando para a implementação de
<code>fmap</code> para esse tipo e então usando o método que usamos para
verificar se <code>Maybe</code> obedece à primeira lei. Se você quiser,
podemos verificar como a segunda lei dos Functors se sustenta para
<code>Maybe</code>. Se fizermos <code>fmap (f . g)</code> sobre
<code>Nothing</code>, obtemos <code>Nothing</code>, porque fazer um
<code>fmap</code> com qualquer função sobre <code>Nothing</code> retorna
<code>Nothing</code>. Se fizermos <code>fmap f (fmap g Nothing)</code>,
obtemos <code>Nothing</code>, pela mesma razão. OK, ver como a segunda
lei se sustenta para <code>Maybe</code> se for um valor
<code>Nothing</code> é muito fácil, quase trivial.</p>
<p>E se for um valor <code>Just <em>algo</em></code>? Bem, se fizermos
<code>fmap (f . g) (Just x)</code>, vemos pela implementação que é
implementado como <code>Just ((f . g) x)</code>, que é, claro,
<code>Just (f (g x))</code>. Se fizermos
<code>fmap f (fmap g (Just x))</code>, vemos pela implementação que
<code>fmap g (Just x)</code> é <code>Just (g x)</code>. Logo,
<code>fmap f (fmap g (Just x))</code> é igual a
<code>fmap f (Just (g x))</code> e pela implementação vemos que isso é
igual a <code>Just (f (g x))</code>.</p>
<p>Se você está um pouco confuso com essa prova, não se preocupe.
Certifique-se de entender como <a
href="higher-order-functions.html#composition">composição de funções</a>
funciona. Muitas vezes, você pode ver intuitivamente como essas leis se
sustentam porque os tipos agem como contêineres ou funções. Você também
pode simplesmente testá-las em um monte de valores diferentes de um tipo
e ser capaz de dizer com alguma certeza que um tipo de fato obedece às
leis.</p>
<p>Vamos dar uma olhada em um exemplo patológico de um construtor de
tipo sendo uma instância da typeclass <code>Functor</code>, mas não
sendo realmente um functor, porque ele não satisfaz as leis. Vamos dizer
que temos um tipo:</p>
<pre class="haskell:hs"><code>data CMaybe a = CNothing | CJust Int a deriving (Show)</code></pre>
<p>O C aqui significa <em>contador</em> (counter). É um tipo de dados
que se parece muito com <code>Maybe a</code>, só que a parte
<code>Just</code> contém dois campos em vez de um. O primeiro campo no
construtor de valor <code>CJust</code> sempre terá um tipo de
<code>Int</code>, e será algum tipo de contador e o segundo campo é do
tipo <code>a</code>, que vem do parâmetro de tipo e seu tipo, claro,
dependerá do tipo concreto que escolhermos para <code>CMaybe a</code>.
Vamos brincar com nosso novo tipo para ter alguma intuição sobre
ele.</p>
<pre class="haskell:hs"><code>ghci&gt; CNothing
CNothing
ghci&gt; CJust 0 &quot;haha&quot;
CJust 0 &quot;haha&quot;
ghci&gt; :t CNothing
CNothing :: CMaybe a
ghci&gt; :t CJust 0 &quot;haha&quot;
CJust 0 &quot;haha&quot; :: CMaybe [Char]
ghci&gt; CJust 100 [1,2,3]
CJust 100 [1,2,3]</code></pre>
<p>Se usarmos o construtor <code>CNothing</code>, não há campos, e se
usarmos o construtor <code>CJust</code>, o primeiro campo é um inteiro e
o segundo campo pode ser qualquer tipo. Vamos fazer disso uma instância
de <code>Functor</code> para que toda vez que usarmos <code>fmap</code>,
a função seja aplicada ao segundo campo, enquanto o primeiro campo é
incrementado em 1.</p>
<pre class="haskell:hs"><code>instance Functor CMaybe where
    fmap f CNothing = CNothing
    fmap f (CJust counter x) = CJust (counter+1) (f x)</code></pre>
<p>Isso é meio que como a implementação da instância para
<code>Maybe</code>, exceto que quando damos <code>fmap</code> sobre um
valor que não representa uma caixa vazia (um valor <code>CJust</code>),
não aplicamos apenas a função ao conteúdo, também aumentamos o contador
em 1. Tudo parece legal até agora, podemos até brincar com isso um
pouco:</p>
<pre class="haskell:hs"><code>ghci&gt; fmap (++&quot;ha&quot;) (CJust 0 &quot;ho&quot;)
CJust 1 &quot;hoha&quot;
ghci&gt; fmap (++&quot;he&quot;) (fmap (++&quot;ha&quot;) (CJust 0 &quot;ho&quot;))
CJust 2 &quot;hohahe&quot;
ghci&gt; fmap (++&quot;blah&quot;) CNothing
CNothing</code></pre>
<p>Isso obedece às leis dos functores? Para ver que algo não obedece a
uma lei, é suficiente encontrar apenas um contra-exemplo.</p>
<pre class="haskell:hs"><code>ghci&gt; fmap id (CJust 0 &quot;haha&quot;)
CJust 1 &quot;haha&quot;
ghci&gt; id (CJust 0 &quot;haha&quot;)
CJust 0 &quot;haha&quot;</code></pre>
<p>Ah! Sabemos que a primeira lei dos functores afirma que se mapearmos
<code>id</code> sobre um functor, deve ser o mesmo que apenas chamar
<code>id</code> com o mesmo functor, mas como vimos neste exemplo, isso
não é verdade para nosso functor <code>CMaybe</code>. Mesmo que seja
parte da typeclass <code>Functor</code>, não obedece às leis dos
functores e, portanto, não é um functor. Se alguém usasse nosso tipo
<code>CMaybe</code> como um functor, esperaria que ele obedecesse às
leis dos functores como um bom functor. Mas <code>CMaybe</code> falha em
ser um functor, embora finja ser um, então usá-lo como um functor pode
levar a algum código defeituoso. Quando usamos um functor, não deveria
importar se primeiro compomos algumas funções e depois as mapeamos sobre
o functor ou se apenas mapeamos cada função sobre um functor
sucessivamente. Mas com <code>CMaybe</code>, importa, porque ele
acompanha quantas vezes foi mapeado. Não é legal! Se quiséssemos que
<code>CMaybe</code> obedecesse às leis dos functores, teríamos que fazer
de modo que o campo <code>Int</code> permanecesse o mesmo quando
usássemos <code>fmap</code>.</p>
<p>A princípio, as leis dos functores podem parecer um pouco confusas e
desnecessárias, mas então vemos que se soubermos que um tipo obedece a
ambas as leis, podemos fazer certas suposições sobre como ele agirá. Se
um tipo obedece às leis dos functores, sabemos que chamar
<code>fmap</code> em um valor desse tipo apenas mapeará a função sobre
ele, nada mais. Isso leva a um código que é mais abstrato e extensível,
porque podemos usar leis para raciocinar sobre comportamentos que
qualquer functor deve ter e fazer funções que operam de forma confiável
em qualquer functor.</p>
<p>Todas as instâncias de <code>Functor</code> na biblioteca padrão
obedecem a essas leis, mas você pode verificar por si mesmo se não
acredita em mim. E da próxima vez que você fizer de um tipo uma
instância de <code>Functor</code>, reserve um minuto para garantir que
ele obedeça às leis dos functores. Depois de lidar com functores
suficientes, você meio que vê intuitivamente as propriedades e
comportamentos que eles têm em comum e não é difícil ver intuitivamente
se um tipo obedece às leis dos functores. Mas mesmo sem a intuição, você
sempre pode apenas passar pela implementação linha por linha e ver se as
leis se sustentam ou tentar encontrar um contra-exemplo.</p>
<p>Também podemos olhar para functores como coisas que produzem valores
em um contexto. Por exemplo, <code>Just 3</code> produz o valor
<code>3</code> no contexto de que pode ou não produzir quaisquer
valores. <code>[1,2,3]</code> produz três valores—<code>1</code>,
<code>2</code> e <code>3</code>, o contexto é que pode haver múltiplos
valores ou nenhum valor. A função <code>(+3)</code> produzirá um valor,
dependendo de qual parâmetro for dada.</p>
<h2 id="applicative-functors">Applicative Functors</h2>
<p><img
src="assets/images/functors-applicative-functors-and-monoids/present.png"
class="right" width="302" height="284"
alt="disregard this analogy" /></p>
<p>Nesta seção, daremos uma olhada em Applicative Functors, que são
Functors reforçados, representados em Haskell pela typeclass
<code>Applicative</code>, encontrada no módulo
<code>Control.Applicative</code>.</p>
<p>Como você sabe, as funções em Haskell são curried por padrão, o que
significa que uma função que parece pegar vários parâmetros na verdade
pega apenas um parâmetro e retorna uma função que pega o próximo
parâmetro e assim por diante. Se uma função é do tipo
<code>a -&gt; b -&gt; c</code>, costumamos dizer que ela pega dois
parâmetros e retorna um <code>c</code>, mas na verdade ela pega um
<code>a</code> e retorna uma função <code>b -&gt; c</code>. É por isso
que podemos chamar uma função como <code>f x y</code> ou como
<code>(f x) y</code>. Esse mecanismo é o que nos permite aplicar
parcialmente funções apenas chamando-as com poucos parâmetros, o que
resulta em funções que podemos passar para outras funções.</p>
<p>Até agora, quando estávamos mapeando funções sobre functores,
geralmente mapeávamos funções que pegam apenas um parâmetro. Mas o que
acontece quando mapeamos uma função como <code>*</code>, que pega dois
parâmetros, sobre um functor? Vamos dar uma olhada em alguns exemplos
concretos disso. Se tivermos <code>Just 3</code> e fizermos
<code>fmap (*) (Just 3)</code>, o que obtemos? Pela implementação da
instância de <code>Maybe</code> para <code>Functor</code>, sabemos que
se for um valor <code>Just <em>algo</em></code>, ela aplicará a função
ao <code><em>algo</em></code> dentro do <code>Just</code>. Portanto,
fazer <code>fmap (*) (Just 3)</code> resulta em
<code>Just ((*) 3)</code>, que também pode ser escrito como
<code>Just (* 3)</code> se usarmos seções. Interessante! Obtemos uma
função embrulhada em um <code>Just</code>!</p>
<pre class="haskell:hs"><code>ghci&gt; :t fmap (++) (Just &quot;hey&quot;)
fmap (++) (Just &quot;hey&quot;) :: Maybe ([Char] -&gt; [Char])
ghci&gt; :t fmap compare (Just &#39;a&#39;)
fmap compare (Just &#39;a&#39;) :: Maybe (Char -&gt; Ordering)
ghci&gt; :t fmap compare &quot;A LIST OF CHARS&quot;
fmap compare &quot;A LIST OF CHARS&quot; :: [Char -&gt; Ordering]
ghci&gt; :t fmap (\x y z -&gt; x + y / z) [3,4,5,6]
fmap (\x y z -&gt; x + y / z) [3,4,5,6] :: (Fractional a) =&gt; [a -&gt; a -&gt; a]</code></pre>
<p>Se mapearmos <code>compare</code>, que tem um tipo de
<code>(Ord a) =&gt; a -&gt; a -&gt; Ordering</code> sobre uma lista de
caracteres, obtemos uma lista de funções do tipo
<code>Char -&gt; Ordering</code>, porque a função <code>compare</code> é
parcialmente aplicada com os caracteres na lista. Não é uma lista de
função <code>(Ord a) =&gt; a -&gt; Ordering</code>, porque o primeiro
<code>a</code> que foi aplicado era um <code>Char</code> e então o
segundo <code>a</code> tem que decidir ser do tipo
<code>Char</code>.</p>
<p>Vemos como mapeando funções de “vários parâmetros” sobre functores,
obtemos functores que contêm funções dentro deles. Então, o que podemos
fazer com eles? Bem, para começar, podemos mapear funções que pegam
essas funções como parâmetros sobre eles, porque o que estiver dentro de
um functor será dado à função que estamos mapeando sobre ele como um
parâmetro.</p>
<pre class="haskell:hs"><code>ghci&gt; let a = fmap (*) [1,2,3,4]
ghci&gt; :t a
a :: [Integer -&gt; Integer]
ghci&gt; fmap (\f -&gt; f 9) a
[9,18,27,36]</code></pre>
<p>Mas o que acontece se tivermos um valor de functor
<code>Just (3 *)</code> e um valor de functor <code>Just 5</code> e
quisermos tirar a função de <code>Just (3 *)</code> e mapeá-la sobre
<code>Just 5</code>? Com functores normais, estamos sem sorte, porque
tudo o que eles suportam é apenas mapear funções normais sobre functores
existentes. Mesmo quando mapeamos <code>\f -&gt; f 9</code> sobre um
functor que continha funções dentro dele, estávamos apenas mapeando uma
função normal sobre ele. Mas não podemos mapear uma função que está
dentro de um functor sobre outro functor com o que <code>fmap</code> nos
oferece. Poderíamos fazer pattern matching no construtor
<code>Just</code> para tirar a função dele e então mapeá-la sobre
<code>Just 5</code>, mas estamos procurando uma maneira mais geral e
abstrata de fazer isso, que funcione em functores.</p>
<p>Conheça a typeclass <code>Applicative</code>. Ela fica no módulo
<code>Control.Applicative</code> e define dois métodos,
<code>pure</code> e <code>&lt;*&gt;</code>. Ela não fornece uma
implementação padrão para nenhum deles, então temos que definir ambos se
quisermos que algo seja um functor aplicativo. A classe é definida
assim:</p>
<pre class="haskell:hs"><code>class (Functor f) =&gt; Applicative f where
    pure :: a -&gt; f a
    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</code></pre>
<p>Essa definição de classe simples de três linhas nos diz muito! Vamos
começar na primeira linha. Ela inicia a definição da classe
<code>Applicative</code> e também introduz uma restrição de classe. Ela
diz que se quisermos fazer de um construtor de tipo parte da typeclass
<code>Applicative</code>, ele tem que estar em <code>Functor</code>
primeiro. É por isso que se sabemos que se um construtor de tipo é parte
da typeclass <code>Applicative</code>, ele também está em
<code>Functor</code>, então podemos usar <code>fmap</code> nele.</p>
<p>O primeiro método que ela define é chamado <code>pure</code>. Sua
declaração de tipo é <code>pure :: a -&gt; f a</code>. <code>f</code>
desempenha o papel de nossa instância de functor aplicativo aqui. Como
Haskell tem um sistema de tipos muito bom e porque tudo o que uma função
pode fazer é pegar alguns parâmetros e retornar algum valor, podemos
dizer muito a partir de uma declaração de tipo e isso não é exceção.
<code>pure</code> deve pegar um valor de qualquer tipo e retornar um
functor aplicativo com esse valor dentro dele. Quando dizemos <em>dentro
dele</em>, estamos usando a analogia da caixa novamente, embora tenhamos
visto que ela nem sempre resiste ao escrutínio. Mas a declaração de tipo
<code>a -&gt; f a</code> ainda é bastante descritiva. Pegamos um valor e
o embrulhamos em um functor aplicativo que tem esse valor como resultado
dentro dele.</p>
<p>Uma maneira melhor de pensar sobre <code>pure</code> seria dizer que
ele pega um valor e o coloca em algum tipo de contexto padrão (ou puro)
- um contexto mínimo que ainda produz esse valor.</p>
<p>A função <code>&lt;*&gt;</code> é realmente interessante. Ela tem uma
declaração de tipo de <code>f (a -&gt; b) -&gt; f a -&gt; f b</code>.
Isso te lembra alguma coisa? Claro,
<code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>. É uma espécie de
<code>fmap</code> reforçado. Enquanto <code>fmap</code> pega uma função
e um functor e aplica a função dentro do functor, <code>&lt;*&gt;</code>
pega um functor que tem uma função nele e outro functor e meio que
extrai essa função do primeiro functor e então a mapeia sobre o segundo.
Quando digo <em>extrair</em>, na verdade quero dizer <em>executar</em> e
então extrair, talvez até <em>sequenciar</em>. Veremos o porquê em
breve.</p>
<p>Vamos dar uma olhada na implementação da instância
<code>Applicative</code> para <code>Maybe</code>.</p>
<pre class="haskell:hs"><code>instance Applicative Maybe where
    pure = Just
    Nothing &lt;*&gt; _ = Nothing
    (Just f) &lt;*&gt; something = fmap f something</code></pre>
<p>Novamente, da definição da classe vemos que o <code>f</code> que
desempenha o papel do Applicative Functor deve pegar um tipo concreto
como parâmetro, então escrevemos
<code>instance Applicative Maybe where</code> em vez de escrever
<code>instance Applicative (Maybe a) where</code>.</p>
<p>Primeiro, <code>pure</code>. Dissemos anteriormente que ele deve
pegar algo e embrulhá-lo em um Applicative Functor. Escrevemos
<code>pure = Just</code>, porque construtores de valor como
<code>Just</code> são funções normais. Poderíamos ter escrito também
<code>pure x = Just x</code>.</p>
<p>Em seguida, temos a definição para <code>&lt;*&gt;</code>. Não
podemos extrair uma função de um <code>Nothing</code>, porque ele não
tem nenhuma função dentro dele. Então dizemos que se tentarmos extrair
uma função de um <code>Nothing</code>, o resultado é um
<code>Nothing</code>. Se você olhar para a definição da classe para
<code>Applicative</code>, verá que há uma restrição de classe
<code>Functor</code>, o que significa que podemos assumir que ambos os
parâmetros de <code>&lt;*&gt;</code> são functores. Se o primeiro
parâmetro não for um <code>Nothing</code>, mas um <code>Just</code> com
alguma função dentro dele, dizemos que queremos então mapear essa função
sobre o segundo parâmetro. Isso também cuida do caso em que o segundo
parâmetro é <code>Nothing</code>, porque fazer <code>fmap</code> com
qualquer função sobre um <code>Nothing</code> retornará um
<code>Nothing</code>.</p>
<p>Então, para <code>Maybe</code>, <code>&lt;*&gt;</code> extrai a
função do valor da esquerda se for um <code>Just</code> e a mapeia sobre
o valor da direita. Se algum dos parâmetros for <code>Nothing</code>,
<code>Nothing</code> é o resultado.</p>
<p>OK, legal, ótimo. Vamos dar uma volta com isso.</p>
<pre class="haskell:hs"><code>ghci&gt; Just (+3) &lt;*&gt; Just 9
Just 12
ghci&gt; pure (+3) &lt;*&gt; Just 10
Just 13
ghci&gt; pure (+3) &lt;*&gt; Just 9
Just 12
ghci&gt; Just (++&quot;hahah&quot;) &lt;*&gt; Nothing
Nothing
ghci&gt; Nothing &lt;*&gt; Just &quot;woot&quot;
Nothing</code></pre>
<p>Vemos como fazer <code>pure (+3)</code> e <code>Just (+3)</code> é o
mesmo neste caso. Use <code>pure</code> se estiver lidando com valores
<code>Maybe</code> em um contexto aplicativo (ou seja, usando-os com
<code>&lt;*&gt;</code>), caso contrário, fique com <code>Just</code>. As
primeiras quatro linhas de entrada demonstram como a função é extraída e
então mapeada, mas neste caso, elas poderiam ter sido alcançadas apenas
mapeando funções desembrulhadas sobre Functors. A última linha é
interessante, porque tentamos extrair uma função de um
<code>Nothing</code> e então mapeá-la sobre algo, o que, claro, resulta
em um <code>Nothing</code>.</p>
<p>Com Functors normais, você pode apenas mapear uma função sobre um
Functor e então não pode tirar o resultado de nenhuma maneira geral,
mesmo que o resultado seja uma função parcialmente aplicada. Applicative
Functors, por outro lado, permitem operar em vários Functors com uma
única função. Confira este pedaço de código:</p>
<pre class="haskell:hs"><code>ghci&gt; pure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 5
Just 8
ghci&gt; pure (+) &lt;*&gt; Just 3 &lt;*&gt; Nothing
Nothing
ghci&gt; pure (+) &lt;*&gt; Nothing &lt;*&gt; Just 5
Nothing</code></pre>
<p><img
src="assets/images/functors-applicative-functors-and-monoids/whale.png"
class="right" width="214" height="177" alt="whaale" /></p>
<p>O que está acontecendo aqui? Vamos dar uma olhada, passo a passo.
<code>&lt;*&gt;</code> é associativo à esquerda, o que significa que
<code>pure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 5</code> é o mesmo que
<code>(pure (+) &lt;*&gt; Just 3) &lt;*&gt; Just 5</code>. Primeiro, a
função <code>+</code> é colocada em um functor, que é neste caso um
valor <code>Maybe</code> que contém a função. Então, a princípio, temos
<code>pure (+)</code>, que é <code>Just (+)</code>. Em seguida,
<code>Just (+) &lt;*&gt; Just 3</code> acontece. O resultado disso é
<code>Just (3+)</code>. Isso é devido à aplicação parcial. Apenas
aplicar <code>3</code> à função <code>+</code> resulta em uma função que
pega um parâmetro e adiciona 3 a ele. Finalmente,
<code>Just (3+) &lt;*&gt; Just 5</code> é realizado, o que resulta em um
<code>Just 8</code>.</p>
<p>Isso não é incrível?! Applicative Functors e o Applicative style de
fazer <code>pure f &lt;*&gt; x &lt;*&gt; y &lt;*&gt; ...</code> nos
permitem pegar uma função que espera parâmetros que não estão
necessariamente embrulhados em Functors e usar essa função para operar
em vários valores que estão em contextos de Functor. A função pode pegar
quantos parâmetros quisermos, porque é sempre parcialmente aplicada
passo a passo entre ocorrências de <code>&lt;*&gt;</code>.</p>
<p>Isso se torna ainda mais prático e aparente se considerarmos o fato
de que <code>pure f &lt;*&gt; x</code> é igual a <code>fmap f x</code>.
Esta é uma das leis dos Applicatives. Daremos uma olhada mais de perto
nelas mais tarde, mas por enquanto, podemos meio que intuitivamente ver
que isso é verdade. Pense sobre isso, faz sentido. Como dissemos antes,
<code>pure</code> coloca um valor em um contexto padrão. Se apenas
colocarmos uma função em um contexto padrão e então extrairmos e a
aplicarmos a um valor dentro de outro Applicative Functor, fizemos o
mesmo que apenas mapear essa função sobre esse Applicative Functor. Em
vez de escrever
<code>pure f &lt;*&gt; x &lt;*&gt; y &lt;*&gt; ...</code>, podemos
escrever <code>fmap f x &lt;*&gt; y &lt;*&gt; ...</code>. É por isso que
<code>Control.Applicative</code> exporta uma função chamada
<code>&lt;$&gt;</code>, que é apenas <code>fmap</code> como um operador
infixo. Aqui está como ela é definida:</p>
<pre class="haskell:hs"><code>(&lt;$&gt;) :: (Functor f) =&gt; (a -&gt; b) -&gt; f a -&gt; f b
f &lt;$&gt; x = fmap f x</code></pre>
<div class="hintbox">
<p><strong>Yo!</strong> Lembrete rápido: variáveis de tipo são
independentes de nomes de parâmetros ou outros nomes de valor. O
<code>f</code> na declaração de função aqui é uma variável de tipo com
uma restrição de classe dizendo que qualquer construtor de tipo que
substitua <code>f</code> deve estar na typeclass <code>Functor</code>. O
<code>f</code> no corpo da função denota uma função que mapeamos sobre
<code>x</code>. O fato de termos usado <code>f</code> para representar
ambos não significa que eles de alguma forma representem a mesma
coisa.</p>
</div>
<p>Ao usar <code>&lt;$&gt;</code>, o Applicative style realmente brilha,
porque agora se quisermos aplicar uma função <code>f</code> entre três
Applicative Functors, podemos escrever
<code>f &lt;$&gt; x &lt;*&gt; y &lt;*&gt; z</code>. Se os parâmetros não
fossem Applicative Functors, mas valores normais, escreveríamos
<code>f x y z</code>.</p>
<p>Vamos dar uma olhada mais de perto em como isso funciona. Temos um
valor de <code>Just "johntra"</code> e um valor de
<code>Just "volta"</code> e queremos juntá-los em uma
<code>String</code> dentro de um functor <code>Maybe</code>. Fazemos
isso:</p>
<pre class="haskell:hs"><code>ghci&gt; (++) &lt;$&gt; Just &quot;johntra&quot; &lt;*&gt; Just &quot;volta&quot;
Just &quot;johntravolta&quot;</code></pre>
<p>Antes de vermos como isso acontece, compare a linha acima com
esta:</p>
<pre class="haskell:hs"><code>ghci&gt; (++) &quot;johntra&quot; &quot;volta&quot;
&quot;johntravolta&quot;</code></pre>
<p>Demais! Para usar uma função normal em Applicative Functors, apenas
espalhe alguns <code>&lt;$&gt;</code> e <code>&lt;*&gt;</code> por aí e
a função operará em Applicatives e retornará um Applicative. Quão legal
é isso?</p>
<p>De qualquer forma, quando fazemos
<code>(++) &lt;$&gt; Just "johntra" &lt;*&gt; Just "volta"</code>,
primeiro <code>(++)</code>, que tem um tipo de
<code>(++) :: [a] -&gt; [a] -&gt; [a]</code> é mapeado sobre
<code>Just "johntra"</code>, resultando em um valor que é o mesmo que
<code>Just ("johntra"++)</code> e tem um tipo de
<code>Maybe ([Char] -&gt; [Char])</code>. Observe como o primeiro
parâmetro de <code>(++)</code> foi comido e como os <code>a</code>s se
transformaram em <code>Char</code>s. E agora
<code>Just ("johntra"++) &lt;*&gt; Just "volta"</code> acontece, o que
tira a função do <code>Just</code> e a mapeia sobre
<code>Just "volta"</code>, resultando em
<code>Just "johntravolta"</code>. Se algum dos dois valores tivesse sido
<code>Nothing</code>, o resultado também teria sido
<code>Nothing</code>.</p>
<p>Até agora, usamos apenas <code>Maybe</code> em nossos exemplos e você
pode estar pensando que functores aplicativos são todos sobre
<code>Maybe</code>. Existem muitas outras instâncias de
<code>Applicative</code>, então vamos conhecê-las!</p>
<p>Listas (na verdade o construtor de tipo de lista, <code>[]</code>)
são Applicative Functors. Que surpresa! Aqui está como <code>[]</code> é
uma instância de <code>Applicative</code>:</p>
<pre class="haskell:hs"><code>instance Applicative [] where
    pure x = [x]
    fs &lt;*&gt; xs = [f x | f &lt;- fs, x &lt;- xs]</code></pre>
<p>Anteriormente, dissemos que <code>pure</code> pega um valor e o
coloca em um contexto padrão. Ou em outras palavras, um contexto mínimo
que ainda produz esse valor. O contexto mínimo para listas seria a lista
vazia, <code>[]</code>, mas a lista vazia representa a falta de um
valor, então ela não pode conter em si mesma o valor em que usamos
<code>pure</code>. É por isso que <code>pure</code> pega um valor e o
coloca em uma lista singleton. Da mesma forma, o contexto mínimo para o
functor aplicativo <code>Maybe</code> seria um <code>Nothing</code>, mas
ele representa a falta de um valor em vez de um valor, então
<code>pure</code> é implementado como <code>Just</code> na implementação
da instância para <code>Maybe</code>.</p>
<pre class="haskell:hs"><code>ghci&gt; pure &quot;Hey&quot; :: [String]
[&quot;Hey&quot;]
ghci&gt; pure &quot;Hey&quot; :: Maybe String
Just &quot;Hey&quot;</code></pre>
<p>E quanto a <code>&lt;*&gt;</code>? Se olharmos para qual seria o tipo
de <code>&lt;*&gt;</code> se fosse limitado apenas a listas, obtemos
<code>(&lt;*&gt;) :: [a -&gt; b] -&gt; [a] -&gt; [b]</code>. É
implementado com uma <a
href="starting-out.html#im-a-list-comprehension">list comprehension</a>.
<code>&lt;*&gt;</code> tem que de alguma forma extrair a função de seu
parâmetro esquerdo e então mapeá-la sobre o parâmetro direito. Mas a
questão aqui é que a lista da esquerda pode ter zero funções, uma função
ou várias funções dentro dela. A lista da direita também pode conter
vários valores. É por isso que usamos uma compreensão de lista para
extrair de ambas as listas. Aplicamos todas as funções possíveis da
lista esquerda a todos os valores possíveis da lista direita. A lista
resultante tem todas as combinações possíveis de aplicar uma função da
lista esquerda a um valor na direita.</p>
<pre class="haskell:hs"><code>ghci&gt; [(*0),(+100),(^2)] &lt;*&gt; [1,2,3]
[0,0,0,101,102,103,1,4,9]</code></pre>
<p>A lista da esquerda tem três funções e a lista da direita tem três
valores, então a lista resultante terá nove elementos. Cada função na
lista da esquerda é aplicada a cada valor na da direita. Se tivermos uma
lista de funções que pegam dois parâmetros, podemos aplicar essas
funções entre duas listas.</p>
<pre class="haskell:hs"><code>ghci&gt; [(+),(*)] &lt;*&gt; [1,2] &lt;*&gt; [3,4]
[4,5,5,6,3,4,6,8]</code></pre>
<p>Como <code>&lt;*&gt;</code> é associativo à esquerda,
<code>[(+),(*)] &lt;*&gt; [1,2]</code> acontece primeiro, resultando em
uma lista que é a mesma que <code>[(1+),(2+),(1*),(2*)]</code>, porque
cada função à esquerda é aplicada a cada valor à direita. Então,
<code>[(1+),(2+),(1*),(2*)] &lt;*&gt; [3,4]</code> acontece, o que
produz o resultado final.</p>
<p>Usar o estilo aplicativo com listas é divertido! Veja:</p>
<pre class="haskell:hs"><code>ghci&gt; (++) &lt;$&gt; [&quot;ha&quot;,&quot;heh&quot;,&quot;hmm&quot;] &lt;*&gt; [&quot;?&quot;,&quot;!&quot;,&quot;.&quot;]
[&quot;ha?&quot;,&quot;ha!&quot;,&quot;ha.&quot;,&quot;heh?&quot;,&quot;heh!&quot;,&quot;heh.&quot;,&quot;hmm?&quot;,&quot;hmm!&quot;,&quot;hmm.&quot;]</code></pre>
<p>Novamente, veja como usamos uma função normal que pega duas strings
entre dois functores aplicativos de strings apenas inserindo os
operadores aplicativos apropriados.</p>
<p>Você pode ver listas como computações não determinísticas. Um valor
como <code>100</code> ou <code>"what"</code> pode ser visto como uma
computação determinística que tem apenas um resultado, enquanto uma
lista como <code>[1,2,3]</code> pode ser vista como uma computação que
não consegue decidir qual resultado quer ter, então ela nos apresenta
todos os resultados possíveis. Então, quando você faz algo como
<code>(+) &lt;$&gt; [1,2,3] &lt;*&gt; [4,5,6]</code>, pode pensar nisso
como adicionar duas computações não determinísticas com <code>+</code>,
apenas para produzir outra computação não determinística que é ainda
menos certa sobre seu resultado.</p>
<p>Usar o Applicative style em listas é muitas vezes um bom substituto
para compreensões de lista. No segundo capítulo, queríamos ver todos os
produtos possíveis de <code>[2,5,10]</code> e <code>[8,10,11]</code>,
então fizemos isso:</p>
<pre class="haskell:hs"><code>ghci&gt; [ x*y | x &lt;- [2,5,10], y &lt;- [8,10,11]]
[16,20,22,40,50,55,80,100,110]</code></pre>
<p>Estamos apenas extraindo de duas listas e aplicando uma função entre
cada combinação de elementos. Isso pode ser feito no Applicative style
também:</p>
<pre class="haskell:hs"><code>ghci&gt; (*) &lt;$&gt; [2,5,10] &lt;*&gt; [8,10,11]
[16,20,22,40,50,55,80,100,110]</code></pre>
<p>Isso parece mais claro para mim, porque é mais fácil ver que estamos
apenas chamando <code>*</code> entre duas computações não
determinísticas. Se quiséssemos todos os produtos possíveis dessas duas
listas que são maiores que 50, apenas faríamos:</p>
<pre class="haskell:hs"><code>ghci&gt; filter (&gt;50) $ (*) &lt;$&gt; [2,5,10] &lt;*&gt; [8,10,11]
[55,80,100,110]</code></pre>
<p>É fácil ver como <code>pure f &lt;*&gt; xs</code> é igual a
<code>fmap f xs</code> com listas. <code>pure f</code> é apenas
<code>[f]</code> e <code>[f] &lt;*&gt; xs</code> aplicará cada função na
lista esquerda a cada valor na direita, mas há apenas uma função na
lista esquerda, então é como mapear.</p>
<p>Outra instância de <code>Applicative</code> que já encontramos é
<code>IO</code>. É assim que a instância é implementada:</p>
<pre class="haskell:hs"><code>instance Applicative IO where
    pure = return
    a &lt;*&gt; b = do
        f &lt;- a
        x &lt;- b
        return (f x)</code></pre>
<p><img
src="assets/images/functors-applicative-functors-and-monoids/knight.png"
class="left" width="195" height="458" alt="ahahahah!" /></p>
<p>Já que <code>pure</code> é tudo sobre colocar um valor em um contexto
mínimo que ainda o mantém como seu resultado, faz sentido que
<code>pure</code> seja apenas <code>return</code>, porque
<code>return</code> faz exatamente isso; ele faz uma ação de E/S que não
faz nada, apenas produz algum valor como seu resultado, mas realmente
não faz nenhuma operação de E/S como imprimir no terminal ou ler de um
arquivo.</p>
<p>Se <code>&lt;*&gt;</code> fosse especializado para <code>IO</code>,
teria um tipo de
<code>(&lt;*&gt;) :: IO (a -&gt; b) -&gt; IO a -&gt; IO b</code>. Ele
pegaria uma ação de E/S que produz uma função como seu resultado e outra
ação de E/S e criaria uma nova ação de E/S a partir dessas duas que,
quando executada, primeiro executa a primeira para obter a função e
depois executa a segunda para obter o valor e então produziria essa
função aplicada ao valor como seu resultado. Usamos a sintaxe
<em>do</em> para implementá-lo aqui. Lembre-se, a sintaxe <em>do</em> é
sobre pegar várias ações de E/S e colá-las em uma, que é exatamente o
que fazemos aqui.</p>
<p>Com <code>Maybe</code> e <code>[]</code>, poderíamos pensar em
<code>&lt;*&gt;</code> como simplesmente extraindo uma função de seu
parâmetro esquerdo e então meio que aplicando-a sobre o direito. Com
<code>IO</code>, extrair ainda está no jogo, mas agora também temos uma
noção de <em>sequenciamento</em>, porque estamos pegando duas ações de
E/S e estamos sequenciando, ou colando-as em uma. Temos que extrair a
função da primeira ação de E/S, mas para extrair um resultado de uma
ação de E/S, ela tem que ser executada.</p>
<p>Considere isto:</p>
<pre class="haskell:hs"><code>myAction :: IO String
myAction = do
    a &lt;- getLine
    b &lt;- getLine
    return $ a ++ b</code></pre>
<p>Esta é uma ação de E/S que solicitará ao usuário duas linhas e
produzirá como resultado essas duas linhas concatenadas. Conseguimos
isso colando duas ações de E/S <code>getLine</code> e um
<code>return</code>, porque queríamos que nossa nova ação de E/S colada
contivesse o resultado de <code>a ++ b</code>. Outra maneira de escrever
isso seria usar o Applicative style.</p>
<pre class="haskell:hs"><code>myAction :: IO String
myAction = (++) &lt;$&gt; getLine &lt;*&gt; getLine</code></pre>
<p>O que estávamos fazendo antes era fazer uma ação de E/S que aplicava
uma função entre os resultados de duas outras ações de E/S, e isso é a
mesma coisa. Lembre-se, <code>getLine</code> é uma ação de E/S com o
tipo <code>getLine :: IO String</code>. Quando usamos
<code>&lt;*&gt;</code> entre dois Applicative Functors, o resultado é um
Applicative Functor, então tudo isso faz sentido.</p>
<p>Se regredirmos à analogia da caixa, podemos imaginar
<code>getLine</code> como uma caixa que sairá para o mundo real e nos
buscará uma string. Fazer
<code>(++) &lt;$&gt; getLine &lt;*&gt; getLine</code> faz uma caixa nova
e maior que envia essas duas caixas para buscar linhas do terminal e
então apresenta a concatenação dessas duas linhas como seu
resultado.</p>
<p>O tipo da expressão
<code>(++) &lt;$&gt; getLine &lt;*&gt; getLine</code> é
<code>IO String</code>, o que significa que essa expressão é uma ação de
E/S completamente normal como qualquer outra, que também contém um valor
resultante dentro dela, assim como outras ações de E/S. É por isso que
podemos fazer coisas como:</p>
<pre class="haskell:hs"><code>main = do
    a &lt;- (++) &lt;$&gt; getLine &lt;*&gt; getLine
    putStrLn $ &quot;The two lines concatenated turn out to be: &quot; ++ a</code></pre>
<p>Se você se encontrar vinculando algumas ações de E/S a nomes e então
chamando alguma função nelas e apresentando isso como resultado usando
<code>return</code>, considere usar o Applicative style porque é
indiscutivelmente um pouco mais conciso e terso.</p>
<p>Outra instância de <code>Applicative</code> é <code>(-&gt;) r</code>,
então funções. Elas são raramente usadas com o Applicative style fora do
code golf, mas ainda são interessantes como aplicativos, então vamos dar
uma olhada em como a instância da função é implementada.</p>
<div class="hintbox">
<p>Se você está confuso sobre o que <code>(-&gt;) r</code> significa,
confira a seção anterior onde explicamos como <code>(-&gt;) r</code> é
um Functor.</p>
</div>
<pre class="haskell:hs"><code>instance Applicative ((-&gt;) r) where
    pure x = (\_ -&gt; x)
    f &lt;*&gt; g = \x -&gt; f x (g x)</code></pre>
<p>Quando embrulhamos um valor em um Applicative Functor com
<code>pure</code>, o resultado que ele produz sempre tem que ser esse
valor. Um contexto padrão mínimo que ainda produz esse valor como
resultado. É por isso que na implementação da instância de função,
<code>pure</code> pega um valor e cria uma função que ignora seu
parâmetro e sempre retorna esse valor. Se olharmos para o tipo de
<code>pure</code>, mas especializado para a instância
<code>(-&gt;) r</code>, é <code>pure :: a -&gt; (r -&gt; a)</code>.</p>
<pre class="haskell:hs"><code>ghci&gt; (pure 3) &quot;blah&quot;
3</code></pre>
<p>Por causa do currying, a aplicação de função é associativa à
esquerda, então podemos omitir os parênteses.</p>
<pre class="haskell:hs"><code>ghci&gt; pure 3 &quot;blah&quot;
3</code></pre>
<p>A implementação da instância para <code>&lt;*&gt;</code> é um pouco
enigmática, então é melhor apenas dar uma olhada em como usar funções
como Applicative Functors no Applicative style.</p>
<pre class="haskell:hs"><code>ghci&gt; :t (+) &lt;$&gt; (+3) &lt;*&gt; (*100)
(+) &lt;$&gt; (+3) &lt;*&gt; (*100) :: (Num a) =&gt; a -&gt; a
ghci&gt; (+) &lt;$&gt; (+3) &lt;*&gt; (*100) $ 5
508</code></pre>
<p>Chamar <code>&lt;*&gt;</code> com dois Applicative Functors resulta
em um Applicative Functor, então se o usarmos em duas funções, obtemos
de volta uma função. Então o que acontece aqui? Quando fazemos
<code>(+) &lt;$&gt; (+3) &lt;*&gt; (*100)</code>, estamos criando uma
função que usará <code>+</code> nos resultados de <code>(+3)</code> e
<code>(*100)</code> e retornará isso. Para demonstrar em um exemplo
real, quando fizemos
<code>(+) &lt;$&gt; (+3) &lt;*&gt; (*100) $ 5</code>, o <code>5</code>
primeiro foi aplicado a <code>(+3)</code> e <code>(*100)</code>,
resultando em <code>8</code> e <code>500</code>. Então, <code>+</code> é
chamado com <code>8</code> e <code>500</code>, resultando em
<code>508</code>.</p>
<pre class="haskell:hs"><code>ghci&gt; (\x y z -&gt; [x,y,z]) &lt;$&gt; (+3) &lt;*&gt; (*2) &lt;*&gt; (/2) $ 5
[8.0,10.0,2.5]</code></pre>
<p><img
src="assets/images/functors-applicative-functors-and-monoids/jazzb.png"
class="right" width="400" height="230" alt="SLAP" /></p>
<p>O mesmo aqui. Criamos uma função que chamará a função
<code>\x y z -&gt; [x,y,z]</code> com os eventuais resultados de
<code>(+3)</code>, <code>(*2)</code> e <code>(/2)</code>. O
<code>5</code> é alimentado para cada uma das três funções e então
<code>\x y z -&gt; [x, y, z]</code> é chamado com esses resultados.</p>
<p>Você pode pensar em funções como caixas que contêm seus eventuais
resultados, então fazer <code>k &lt;$&gt; f &lt;*&gt; g</code> cria uma
função que chamará <code>k</code> com os eventuais resultados de
<code>f</code> e <code>g</code>. Quando fazemos algo como
<code>(+) &lt;$&gt; Just 3 &lt;*&gt; Just 5</code>, estamos usando
<code>+</code> em valores que podem ou não estar lá, o que também
resulta em um valor que pode ou não estar lá. Quando fazemos
<code>(+) &lt;$&gt; (+10) &lt;*&gt; (+5)</code>, estamos usando
<code>+</code> nos valores de retorno futuros de <code>(+10)</code> e
<code>(+5)</code> e o resultado também é algo que produzirá um valor
apenas quando chamado com um parâmetro.</p>
<p>Não usamos funções como Applicatives com frequência, mas isso ainda é
muito interessante. Não é muito importante que você entenda como a
instância <code>(-&gt;) r</code> para <code>Applicative</code> funciona,
então não se desespere se não estiver entendendo isso agora. Tente
brincar com o Applicative style e funções para construir uma intuição
para funções como Applicatives.</p>
<p>Uma instância de <code>Applicative</code> que ainda não encontramos é
<code>ZipList</code>, e ela vive em
<code>Control.Applicative</code>.</p>
<p>Acontece que na verdade existem mais maneiras de listas serem
Applicative Functors. Uma maneira é a que já cobrimos, que diz que
chamar <code>&lt;*&gt;</code> com uma lista de funções e uma lista de
valores resulta em uma lista que tem todas as combinações possíveis de
aplicar funções da lista esquerda aos valores na lista direita. Se
fizermos <code>[(+3),(*2)] &lt;*&gt; [1,2]</code>, <code>(+3)</code>
será aplicado tanto a <code>1</code> quanto a <code>2</code> e
<code>(*2)</code> também será aplicado tanto a <code>1</code> quanto a
<code>2</code>, resultando em uma lista que tem quatro elementos, ou
seja, <code>[4,5,2,4]</code>.</p>
<p>No entanto, <code>[(+3),(*2)] &lt;*&gt; [1,2]</code> também poderia
funcionar de tal maneira que a primeira função na lista esquerda é
aplicada ao primeiro valor na direita, a segunda função é aplicada ao
segundo valor, e assim por diante. Isso resultaria em uma lista com dois
valores, ou seja, <code>[4,4]</code>. Você poderia ver isso como
<code>[1 + 3, 2 * 2]</code>.</p>
<p>Como um tipo não pode ter duas instâncias para a mesma typeclass, o
tipo <code>ZipList a</code> foi introduzido, que tem um construtor
<code>ZipList</code> que tem apenas um campo, e esse campo é uma lista.
Aqui está a instância:</p>
<pre class="haskell:hs"><code>instance Applicative ZipList where
        pure x = ZipList (repeat x)
        ZipList fs &lt;*&gt; ZipList xs = ZipList (zipWith (\f x -&gt; f x) fs xs)</code></pre>
<p><code>&lt;*&gt;</code> faz exatamente o que dissemos. Aplica a
primeira função ao primeiro valor, a segunda função ao segundo valor,
etc. Isso é feito com <code>zipWith (\f x -&gt; f x) fs xs</code>. Por
causa de como <code>zipWith</code> funciona, a lista resultante será tão
longa quanto a mais curta das duas listas.</p>
<p><code>pure</code> também é interessante aqui. Ele pega um valor e o
coloca em uma lista que apenas tem esse valor repetindo indefinidamente.
<code>pure "haha"</code> resulta em
<code>ZipList (["haha","haha","haha"...</code>. Isso pode ser um pouco
confuso, já que dissemos que <code>pure</code> deveria colocar um valor
em um contexto mínimo que ainda produz esse valor. E você pode estar
pensando que uma lista infinita de algo dificilmente é mínima. Mas faz
sentido com zip lists, porque tem que produzir o valor em cada posição.
Isso também satisfaz a lei de que <code>pure f &lt;*&gt; xs</code> deve
ser igual a <code>fmap f xs</code>. Se <code>pure 3</code> apenas
retornasse <code>ZipList [3]</code>,
<code>pure (*2) &lt;*&gt; ZipList [1,5,10]</code> resultaria em
<code>ZipList [2]</code>, porque a lista resultante de duas listas
zipadas tem o comprimento da mais curta das duas. Se ziparmos uma lista
finita com uma lista infinita, o comprimento da lista resultante será
sempre igual ao comprimento da lista finita.</p>
<p>Então, como zip lists funcionam em um Applicative style? Vamos ver.
Ah, o tipo <code>ZipList a</code> não tem uma instância
<code>Show</code>, então temos que usar a função <code
class="label function">getZipList</code> para extrair uma lista bruta de
uma zip list.</p>
<pre class="haskell:hs"><code>ghci&gt; getZipList $ (+) &lt;$&gt; ZipList [1,2,3] &lt;*&gt; ZipList [100,100,100]
[101,102,103]
ghci&gt; getZipList $ (+) &lt;$&gt; ZipList [1,2,3] &lt;*&gt; ZipList [100,100..]
[101,102,103]
ghci&gt; getZipList $ max &lt;$&gt; ZipList [1,2,3,4,5,3] &lt;*&gt; ZipList [5,3,1,2]
[5,3,3,4]
ghci&gt; getZipList $ (,,) &lt;$&gt; ZipList &quot;dog&quot; &lt;*&gt; ZipList &quot;cat&quot; &lt;*&gt; ZipList &quot;rat&quot;
[(&#39;d&#39;,&#39;c&#39;,&#39;r&#39;),(&#39;o&#39;,&#39;a&#39;,&#39;a&#39;),(&#39;g&#39;,&#39;t&#39;,&#39;t&#39;)]</code></pre>
<div class="hintbox">
<p>A função <code>(,,)</code> é a mesma que
<code>\x y z -&gt; (x,y,z)</code>. Além disso, a função <code>(,)</code>
é a mesma que <code>\x y -&gt; (x,y)</code>.</p>
</div>
<p>Além de <code>zipWith</code>, a biblioteca padrão tem funções como
<code>zipWith3</code>, <code>zipWith4</code>, até 7.
<code>zipWith</code> pega uma função que pega dois parâmetros e zipa
duas listas com ela. <code>zipWith3</code> pega uma função que pega três
parâmetros e zipa três listas com ela, e assim por diante. Nada de
especial, apenas aplica uma função entre dois Applicatives, escondendo o
Applicative style com o qual nos familiarizamos. A razão pela qual
estamos olhando para isso é porque ela mostra claramente por que
Applicative Functors são mais poderosos do que apenas Functors comuns.
Com Functors comuns, podemos apenas mapear funções sobre um Functor. Mas
com Applicative Functors, podemos aplicar uma função entre vários
Functors. Também é interessante olhar para o tipo desta função como
<code>(a -&gt; b -&gt; c) -&gt; (f a -&gt; f b -&gt; f c)</code>. Quando
olhamos para ela assim, podemos dizer que <code>liftA2</code> pega uma
função binária normal e a promove para uma função que opera em dois
Functors.</p>
<p>Aqui está um conceito interessante: podemos pegar dois Applicative
Functors e combiná-los em um Applicative Functor que tem dentro dele os
resultados desses dois Applicative Functors em uma lista. Por exemplo,
temos <code>Just 3</code> e <code>Just 4</code>. Vamos assumir que o
segundo tem uma lista singleton dentro dele, porque isso é realmente
fácil de conseguir:</p>
<pre class="haskell:hs"><code>ghci&gt; fmap (\x -&gt; [x]) (Just 4)
Just [4]</code></pre>
<p>OK, então digamos que temos <code>Just 3</code> e
<code>Just [4]</code>. Como obtemos <code>Just [3,4]</code>? Fácil.</p>
<pre class="haskell:hs"><code>ghci&gt; liftA2 (:) (Just 3) (Just [4])
Just [3,4]
ghci&gt; (:) &lt;$&gt; Just 3 &lt;*&gt; Just [4]
Just [3,4]</code></pre>
<p>Lembre-se, <code>:</code> é uma função que pega um elemento e uma
lista e retorna uma nova lista com esse elemento no início. Agora que
temos <code>Just [3,4]</code>, poderíamos combinar isso com
<code>Just 2</code> para produzir <code>Just [2,3,4]</code>? Claro que
poderíamos. Parece que podemos combinar qualquer quantidade de
Applicatives em um Applicative que tem uma lista dos resultados desses
Applicatives dentro dele. Vamos tentar implementar uma função que pega
uma lista de Applicatives e retorna um Applicative que tem uma lista
como seu valor resultante. Vamos chamá-la de <code>sequenceA</code>.</p>
<pre class="haskell:hs"><code>sequenceA :: (Applicative f) =&gt; [f a] -&gt; f [a]
sequenceA [] = pure []
sequenceA (x:xs) = (:) &lt;$&gt; x &lt;*&gt; sequenceA xs</code></pre>
<p>Ah, recursão! Primeiro, olhamos para o tipo. Ela transformará uma
lista de Applicatives em um Applicative com uma lista. A partir disso,
podemos estabelecer algumas bases para uma condição de borda. Se
quisermos transformar uma lista vazia em um Applicative com uma lista de
resultados, bem, apenas colocamos uma lista vazia em um contexto padrão.
Agora vem a recursão. Se tivermos uma lista com uma cabeça e uma cauda
(lembre-se, <code>x</code> é um Applicative e <code>xs</code> é uma
lista deles), chamamos <code>sequenceA</code> na cauda, o que resulta em
um Applicative com uma lista. Então, apenas prefixamos the valor dentro
do Applicative <code>x</code> nessa lista dentro do Applicative, e é
isso!</p>
<p>Então se fizermos <code>sequenceA [Just 1, Just 2]</code>, isso é
<code>(:) &lt;$&gt; Just 1 &lt;*&gt; sequenceA [Just 2]</code>. Isso é
igual a
<code>(:) &lt;$&gt; Just 1 &lt;*&gt; ((:) &lt;$&gt; Just 2 &lt;*&gt; sequenceA [])</code>.
Ah! Sabemos que <code>sequenceA []</code> acaba sendo
<code>Just []</code>, então esta expressão agora é
<code>(:) &lt;$&gt; Just 1 &lt;*&gt; ((:) &lt;$&gt; Just 2 &lt;*&gt; Just [])</code>,
que é <code>(:) &lt;$&gt; Just 1 &lt;*&gt; Just [2]</code>, que é
<code>Just [1,2]</code>!</p>
<p>Outra maneira de implementar <code>sequenceA</code> é com um fold.
Lembre-se, praticamente qualquer função onde passamos por uma lista
elemento por elemento e acumulamos um resultado ao longo do caminho pode
ser implementada com um fold.</p>
<pre class="haskell:hs"><code>sequenceA :: (Applicative f) =&gt; [f a] -&gt; f [a]
sequenceA = foldr (liftA2 (:)) (pure [])</code></pre>
<p>Abordamos a lista pela direita e começamos com um valor acumulador de
<code>pure []</code>. Fazemos <code>liftA2 (:)</code> entre o acumulador
e o último elemento da lista, o que resulta em um aplicativo que tem um
singleton nele. Então fazemos <code>liftA2 (:)</code> com o agora último
elemento e o acumulador atual e assim por diante, até ficarmos apenas
com o acumulador, que contém uma lista dos resultados de todos os
aplicativos.</p>
<p>Vamos dar uma volta com nossa função em alguns Applicatives.</p>
<pre class="haskell:hs"><code>ghci&gt; sequenceA [Just 3, Just 2, Just 1]
Just [3,2,1]
ghci&gt; sequenceA [Just 3, Nothing, Just 1]
Nothing
ghci&gt; sequenceA [(+3),(+2),(+1)] 3
[6,5,4]
ghci&gt; sequenceA [[1,2,3],[4,5,6]]
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
ghci&gt; sequenceA [[1,2,3],[4,5,6],[3,4,4],[]]
[]</code></pre>
<p>Ah! Muito legal. Quando usado em valores <code>Maybe</code>,
<code>sequenceA</code> cria um valor <code>Maybe</code> com todos os
resultados dentro dele como uma lista. Se um dos valores fosse
<code>Nothing</code>, então o resultado também é um
<code>Nothing</code>. Isso é legal quando você tem uma lista de valores
<code>Maybe</code> e está interessado nos valores apenas se nenhum deles
for um <code>Nothing</code>.</p>
<p>Quando usado com funções, <code>sequenceA</code> pega uma lista de
funções e retorna uma função que retorna uma lista. Em nosso exemplo,
fizemos uma função que pegava um número como parâmetro e o aplicava a
cada função na lista e então retornava uma lista de resultados.
<code>sequenceA [(+3),(+2),(+1)] 3</code> chamará <code>(+3)</code> com
<code>3</code>, <code>(+2)</code> com <code>3</code> e <code>(+1)</code>
com <code>3</code> e apresentará todos esses resultados como uma
lista.</p>
<p>Fazer <code>(+) &lt;$&gt; (+3) &lt;*&gt; (*2)</code> criará uma
função que pega um parâmetro, o alimenta para <code>(+3)</code> e
<code>(*2)</code> e então chama <code>+</code> com esses dois
resultados. Na mesma veia, faz sentido que
<code>sequenceA [(+3),(*2)]</code> faz uma função que pega um parâmetro
e o alimenta para todas as funções na lista. Em vez de chamar
<code>+</code> com os resultados das funções, uma combinação de
<code>:</code> e <code>pure []</code> é usada para reunir esses
resultados em uma lista, que é o resultado dessa função.</p>
<p>Usar <code>sequenceA</code> é legal quando temos uma lista de funções
e queremos alimentar a mesma entrada para todas elas e então ver a lista
de resultados. Por exemplo, temos um número e estamos nos perguntando se
ele satisfaz todos os predicados em uma lista. Uma maneira de fazer isso
seria assim:</p>
<pre class="haskell:hs"><code>ghci&gt; map (\f -&gt; f 7) [(&gt;4),(&lt;10),odd]
[True,True,True]
ghci&gt; and $ map (\f -&gt; f 7) [(&gt;4),(&lt;10),odd]
True</code></pre>
<p>Lembre-se, <code>and</code> pega uma lista de booleanos e retorna
<code>True</code> se todos forem <code>True</code>. Outra maneira de
alcançar a mesma coisa seria com <code>sequenceA</code>:</p>
<pre class="haskell:hs"><code>ghci&gt; sequenceA [(&gt;4),(&lt;10),odd] 7
[True,True,True]
ghci&gt; and $ sequenceA [(&gt;4),(&lt;10),odd] 7
True</code></pre>
<p><code>sequenceA [(&gt;4),(&lt;10),odd]</code> cria uma função que
pegará um número e o alimentará para todos os predicados em
<code>[(&gt;4),(&lt;10),odd]</code> e retornará uma lista de booleanos.
Ela transforma uma lista com o tipo
<code>(Num a) =&gt; [a -&gt; Bool]</code> em uma função com o tipo
<code>(Num a) =&gt; a -&gt; [Bool]</code>. Muito legal, hein?</p>
<p>Porque listas são homogêneas, todas as funções na lista têm que ser
funções do mesmo tipo, claro. Você não pode ter uma lista como
<code>[ord, (+3)]</code>, porque <code>ord</code> pega um caractere e
retorna um número, enquanto <code>(+3)</code> pega um número e retorna
um número.</p>
<p>Quando usado com <code>[]</code>, <code>sequenceA</code> pega uma
lista de listas e retorna uma lista de listas. Hmm, interessante. Ela na
verdade cria listas que têm todas as combinações possíveis de seus
elementos. Para ilustração, aqui está o acima feito com
<code>sequenceA</code> e depois feito com uma compreensão de lista:</p>
<pre class="haskell:hs"><code>ghci&gt; sequenceA [[1,2,3],[4,5,6]]
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
ghci&gt; [[x,y] | x &lt;- [1,2,3], y &lt;- [4,5,6]]
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
ghci&gt; sequenceA [[1,2],[3,4]]
[[1,3],[1,4],[2,3],[2,4]]
ghci&gt; [[x,y] | x &lt;- [1,2], y &lt;- [3,4]]
[[1,3],[1,4],[2,3],[2,4]]
ghci&gt; sequenceA [[1,2],[3,4],[5,6]]
[[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
ghci&gt; [[x,y,z] | x &lt;- [1,2], y &lt;- [3,4], z &lt;- [5,6]]
[[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]</code></pre>
<p>Isso pode ser um pouco difícil de entender, mas se você brincar com
isso por um tempo, verá como funciona. Digamos que estamos fazendo
<code>sequenceA [[1,2],[3,4]]</code>. Para ver como isso acontece, vamos
usar a definição
<code>sequenceA (x:xs) = (:) &lt;$&gt; x &lt;*&gt; sequenceA xs</code>
de <code>sequenceA</code> e a condição de borda
<code>sequenceA [] = pure []</code>. Você não precisa seguir esta
avaliação, mas pode ajudar se tiver problemas para imaginar como
<code>sequenceA</code> funciona em listas de listas, porque pode ser um
pouco confuso.</p>
<ul>
<li>Começamos com <code>sequenceA [[1,2],[3,4]]</code></li>
<li>Isso avalia para
<code>(:) &lt;$&gt; [1,2] &lt;*&gt; sequenceA [[3,4]]</code></li>
<li>Avaliando o <code>sequenceA</code> interno ainda mais, obtemos
<code>(:) &lt;$&gt; [1,2] &lt;*&gt; ((:) &lt;$&gt; [3,4] &lt;*&gt; sequenceA [])</code></li>
<li>Atingimos a condição de borda, então isso agora é
<code>(:) &lt;$&gt; [1,2] &lt;*&gt; ((:) &lt;$&gt; [3,4] &lt;*&gt; [[]])</code></li>
<li>Agora, avaliamos a parte
<code>(:) &lt;$&gt; [3,4] &lt;*&gt; [[]]</code>, que usará
<code>:</code> com todos os valores possíveis na lista esquerda (valores
possíveis são <code>3</code> e <code>4</code>) com todos os valores
possíveis na lista direita (único valor possível é <code>[]</code>), o
que resulta em <code>[3:[], 4:[]]</code>, que é <code>[[3],[4]]</code>.
Então agora temos
<code>(:) &lt;$&gt; [1,2] &lt;*&gt; [[3],[4]]</code></li>
<li>Agora, <code>:</code> é usado com todos os valores possíveis da
lista esquerda (<code>1</code> e <code>2</code>) com todos os valores
possíveis da lista direita (<code>[3]</code> e <code>[4]</code>), o que
resulta em <code>[1:[3], 1:[4], 2:[3], 2:[4]]</code>, que é
<code>[[1,3],[1,4],[2,3],[2,4]</code></li>
</ul>
<p>Fazer <code>(+) &lt;$&gt; [1,2] &lt;*&gt; [4,5,6]</code> resulta em
uma computação não determinística <code>x + y</code> onde <code>x</code>
assume todos os valores de <code>[1,2]</code> e <code>y</code> assume
todos os valores de <code>[4,5,6]</code>. Representamos isso como uma
lista que contém todos os resultados possíveis. Da mesma forma, quando
fazemos <code>sequence [[1,2],[3,4],[5,6],[7,8]]</code>, o resultado é
uma computação não determinística <code>[x,y,z,w]</code>, onde
<code>x</code> assume todos os valores de <code>[1,2]</code>,
<code>y</code> assume todos os valores de <code>[3,4]</code> e assim por
diante. Para representar o resultado dessa computação não
determinística, usamos uma lista, onde cada elemento na lista é uma
lista possível. É por isso que o resultado é uma lista de listas.</p>
<p>Quando usado com ações de E/S, <code>sequenceA</code> é a mesma coisa
que <code>sequence</code>! Pega uma lista de ações de E/S e retorna uma
ação de E/S que executará cada uma dessas ações e terá como resultado
uma lista dos resultados dessas ações de E/S. Isso porque para
transformar um valor <code>[IO a]</code> em um valor
<code>IO [a]</code>, para fazer uma ação de E/S que produz uma lista de
resultados quando executada, todas essas ações de E/S têm que ser
sequenciadas para que sejam executadas uma após a outra quando a
avaliação for forçada. Você não pode obter o resultado de uma ação de
E/S sem executá-la.</p>
<pre class="haskell:hs"><code>ghci&gt; sequenceA [getLine, getLine, getLine]
heyh
ho
woo
[&quot;heyh&quot;,&quot;ho&quot;,&quot;woo&quot;]</code></pre>
<p>Como Functors normais, Applicative Functors vêm com algumas leis. A
mais importante é a que já mencionamos, ou seja, que <code
class="label law">pure f &lt;*&gt; x = fmap f x</code> se mantém. Como
exercício, você pode provar esta lei para alguns dos Applicative
Functors que encontramos neste capítulo. As outras leis dos Applicative
Functors são:</p>
<ul>
<li><code class="label law">pure id &lt;*&gt; v = v</code></li>
<li><code
class="label law">pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w)</code></li>
<li><code
class="label law">pure f &lt;*&gt; pure x = pure (f x)</code></li>
<li><code
class="label law">u &lt;*&gt; pure y = pure ($ y) &lt;*&gt; u</code></li>
</ul>
<p>Não vamos repasá-las em detalhes agora porque isso ocuparia muitas
páginas e provavelmente seria meio chato, mas se você estiver pronto
para a tarefa, pode dar uma olhada mais de perto nelas e ver se elas se
mantêm para algumas das instâncias.</p>
<p>Em conclusão, Applicative Functors não são apenas interessantes, eles
também são úteis, porque nos permitem combinar diferentes computações,
como computações de E/S, computações não determinísticas, computações
que podem ter falhado, etc. usando o Applicative style. Apenas usando
<code>&lt;$&gt;</code> e <code>&lt;*&gt;</code> podemos usar funções
normais para operar uniformemente em qualquer número de Applicative
Functors e tirar proveito da semântica de cada um.</p>
<h2 id="the-newtype-keyword">A palavra-chave newtype</h2>
<p><img
src="assets/images/functors-applicative-functors-and-monoids/maoi.png"
class="left" width="107" height="202" alt="why so serious?" /></p>
<p>Até agora, aprendemos como fazer nossos próprios tipos de dados
algébricos usando a palavra-chave <strong>data</strong>. Também
aprendemos como dar sinônimos a tipos existentes com a palavra-chave
<strong>type</strong>. Nesta seção, daremos uma olhada em como fazer
novos tipos a partir de tipos de dados existentes usando a palavra-chave
<strong>newtype</strong> e por que gostaríamos de fazer isso em primeiro
lugar.</p>
<p>Na seção anterior, vimos que há na verdade mais maneiras para o tipo
de lista ser um Applicative Functor. Uma maneira é ter
<code>&lt;*&gt;</code> pegando cada função da lista que é seu parâmetro
esquerdo e aplicando-a a cada valor na lista que está à direita,
resultando em todas as combinações possíveis de aplicar uma função da
lista esquerda a um valor na lista direita.</p>
<pre class="haskell:hs"><code>ghci&gt; [(+1),(*100),(*5)] &lt;*&gt; [1,2,3]
[2,3,4,100,200,300,5,10,15]</code></pre>
<p>A segunda maneira é pegar a primeira função no lado esquerdo de
<code>&lt;*&gt;</code> e aplicá-la ao primeiro valor à direita, depois
pegar a segunda função da lista no lado esquerdo e aplicá-la ao segundo
valor à direita, e assim por diante. Basicamente, é meio que como zipar
as duas listas juntas. Mas as listas já são uma instância de
<code>Applicative</code>, então como também fizemos das listas uma
instância de <code>Applicative</code> dessa segunda maneira? Se você se
lembra, dissemos que o tipo <code>ZipList a</code> foi introduzido por
esse motivo, que tem um construtor de valor, <code>ZipList</code>, que
tem apenas um campo. Colocamos a lista que estamos embrulhando nesse
campo. Então, <code>ZipList</code> foi feita uma instância de
<code>Applicative</code>, de modo que quando queremos usar listas como
Applicatives na maneira de zipar, apenas as embrulhamos com o construtor
<code>ZipList</code> e então, depois que terminamos, as desembrolhamos
com <code>getZipList</code>:</p>
<pre class="haskell:hs"><code>ghci&gt; getZipList $ ZipList [(+1),(*100),(*5)] &lt;*&gt; ZipList [1,2,3]
[2,200,15]</code></pre>
<p>Então, o que isso tem a ver com essa palavra-chave <em>newtype</em>?
Bem, pense em como poderíamos escrever a declaração de dados para nosso
tipo <code>ZipList a</code>. Uma maneira seria fazer assim:</p>
<pre class="haskell:hs"><code>data ZipList a = ZipList [a]</code></pre>
<p>Um tipo que tem apenas um construtor de valor e esse construtor de
valor tem apenas um campo que é uma lista de coisas. Também poderíamos
querer usar a sintaxe de registro para obter automaticamente uma função
que extrai uma lista de uma <code>ZipList</code>:</p>
<pre class="haskell:hs"><code>data ZipList a = ZipList { getZipList :: [a] }</code></pre>
<p>Isso parece bom e na verdade funcionaria muito bem. Tínhamos duas
maneiras de tornar um tipo existente uma instância de uma typeclass,
então usamos a palavra-chave <em>data</em> para apenas embrulhar esse
tipo em outro tipo e fizemos o outro tipo uma instância da segunda
maneira.</p>
<p>A palavra-chave <em>newtype</em> em Haskell é feita exatamente para
esses casos quando queremos apenas pegar um tipo e embrulhá-lo em algo
para apresentá-lo como outro tipo. Nas bibliotecas reais,
<code>ZipList a</code> é definido assim:</p>
<pre class="haskell:hs"><code>newtype ZipList a = ZipList { getZipList :: [a] }</code></pre>
<p>Em vez da palavra-chave <em>data</em>, a palavra-chave
<em>newtype</em> é usada. Agora por que isso? Bem, para começar,
<em>newtype</em> é mais rápido. Se você usar a palavra-chave
<em>data</em> para embrulhar um tipo, há alguma sobrecarga para todo
esse embrulho e desembrulho quando seu programa está em execução. Mas se
você usar <em>newtype</em>, o Haskell sabe que você está apenas usando
isso para embrulhar um tipo existente em um novo tipo (daí o nome),
porque você quer que seja o mesmo internamente, mas tenha um tipo
diferente. Com isso em mente, o Haskell pode se livrar do embrulho e
desembrulho assim que resolver qual valor é de que tipo.</p>
<p>Então, por que não usar apenas <em>newtype</em> o tempo todo em vez
de <em>data</em> então? Bem, quando você faz um novo tipo a partir de um
tipo existente usando a palavra-chave <em>newtype</em>, você pode ter
apenas um construtor de valor e esse construtor de valor pode ter apenas
um campo. Mas com <em>data</em>, você pode criar tipos de dados que têm
vários construtores de valor e cada construtor pode ter zero ou mais
campos:</p>
<pre class="haskell:hs"><code>data Profession = Fighter | Archer | Accountant

data Race = Human | Elf | Orc | Goblin

data PlayerCharacter = PlayerCharacter Race Profession</code></pre>
<p>Ao usar <em>newtype</em>, você está restrito a apenas um construtor
com um campo.</p>
<p>Também podemos usar a palavra-chave <em>deriving</em> com
<em>newtype</em> assim como faríamos com <em>data</em>. Podemos derivar
instâncias para <code>Eq</code>, <code>Ord</code>, <code>Enum</code>,
<code>Bounded</code>, <code>Show</code> e <code>Read</code>. Se
derivarmos a instância para uma typeclass, o tipo que estamos
embrulhando deve estar nessa typeclass para começar. Faz sentido, porque
<em>newtype</em> apenas embrulha um tipo existente. Então agora se
fizermos o seguinte, podemos imprimir e igualar valores de nosso novo
tipo:</p>
<pre class="haskell:hs"><code>newtype CharList = CharList { getCharList :: [Char] } deriving (Eq, Show)</code></pre>
<p>Vamos dar uma chance a isso:</p>
<pre class="haskell:hs"><code>ghci&gt; CharList &quot;this will be shown!&quot;
CharList {getCharList = &quot;this will be shown!&quot;}
ghci&gt; CharList &quot;benny&quot; == CharList &quot;benny&quot;
True
ghci&gt; CharList &quot;benny&quot; == CharList &quot;oysters&quot;
False</code></pre>
<p>Neste <em>newtype</em> em particular, o construtor de valor tem o
seguinte tipo:</p>
<pre class="haskell:hs"><code>CharList :: [Char] -&gt; CharList</code></pre>
<p>Ele pega um valor <code>[Char]</code>, como <code>"my sharona"</code>
e retorna um valor <code>CharList</code>. A partir dos exemplos acima,
onde usamos o construtor de valor <code>CharList</code>, vemos que
realmente é o caso. Por outro lado, a função <code>getCharList</code>,
que foi gerada para nós porque usamos sintaxe de registro em nosso
<em>newtype</em>, tem esse tipo:</p>
<pre class="haskell:hs"><code>getCharList :: CharList -&gt; [Char]</code></pre>
<p>Ela pega um valor <code>CharList</code> e o converte para um valor
<code>[Char]</code>. Você pode pensar nisso como embrulhar e
desembrulhar, mas também pode pensar nisso como converter valores de um
tipo para o outro.</p>
<h3 id="usando-newtype-para-fazer-instâncias-de-typeclass">Usando
newtype para fazer instâncias de typeclass</h3>
<p>Muitas vezes, queremos tornar nossos tipos instâncias de certas
typeclasses, mas os parâmetros de tipo simplesmente não coincidem para o
que queremos fazer. É fácil fazer de <code>Maybe</code> uma instância de
<code>Functor</code>, porque a typeclass <code>Functor</code> é definida
assim:</p>
<pre class="haskell:hs"><code>class Functor f where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code></pre>
<p>Então apenas começamos com:</p>
<pre class="haskell:hs"><code>instance Functor Maybe where</code></pre>
<p>E então implementamos <code>fmap</code>. Todos os parâmetros de tipo
batem porque o <code>Maybe</code> toma o lugar de <code>f</code> na
definição da typeclass <code>Functor</code> e assim se olharmos para
<code>fmap</code> como se ele funcionasse apenas em <code>Maybe</code>,
ele acaba se comportando como:</p>
<pre class="haskell:hs"><code>fmap :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b</code></pre>
<p><img
src="assets/images/functors-applicative-functors-and-monoids/krakatoa.png"
class="right" width="322" height="280" alt="wow, very evil" /></p>
<p>Não é uma beleza? Agora, e se quiséssemos tornar a tupla uma
instância de <code>Functor</code> de tal maneira que quando fazemos
<code>fmap</code> de uma função sobre uma tupla, ela é aplicada ao
primeiro componente da tupla? Dessa forma, fazer
<code>fmap (+3) (1,1)</code> resultaria em <code>(4,1)</code>. Acontece
que escrever a instância para isso é meio difícil. Com
<code>Maybe</code>, apenas dizemos
<code>instance Functor Maybe where</code> porque apenas construtores de
tipo que pegam exatamente um parâmetro podem ser feitos uma instância de
<code>Functor</code>. Mas parece que não há maneira de fazer algo assim
com <code>(a,b)</code> para que o parâmetro de tipo <code>a</code> acabe
sendo o que muda quando usamos <code>fmap</code>. Para contornar isso,
podemos dar <em>newtype</em> em nossa tupla de tal maneira que o segundo
parâmetro de tipo represente o tipo do primeiro componente na tupla:</p>
<pre class="haskell:hs"><code>newtype Pair b a = Pair { getPair :: (a,b) }</code></pre>
<p>E agora, podemos torná-lo uma instância de <code>Functor</code> para
que a função seja mapeada sobre o primeiro componente:</p>
<pre class="haskell:hs"><code>instance Functor (Pair c) where
    fmap f (Pair (x,y)) = Pair (f x, y)</code></pre>
<p>Como você pode ver, podemos fazer pattern matching em tipos definidos
com <em>newtype</em>. Fazemos pattern matching para obter a tupla
subjacente, então aplicamos a função <code>f</code> ao primeiro
componente na tupla e então usamos o construtor de valor
<code>Pair</code> para converter a tupla de volta para nosso
<code>Pair b a</code>. Se imaginarmos qual seria o tipo de
<code>fmap</code> se ele funcionasse apenas em nossos novos pares,
seria:</p>
<pre class="haskell:hs"><code>fmap :: (a -&gt; b) -&gt; Pair c a -&gt; Pair c b</code></pre>
<p>Novamente, dissemos <code>instance Functor (Pair c) where</code> e
então <code>Pair c</code> tomou o lugar do <code>f</code> na definição
da typeclass para <code>Functor</code>:</p>
<pre class="haskell:hs"><code>class Functor f where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code></pre>
<p>Então agora, se convertermos uma tupla em um <code>Pair b a</code>,
podemos usar <code>fmap</code> sobre ela e a função será mapeada sobre o
primeiro componente:</p>
<pre class="haskell:hs"><code>ghci&gt; getPair $ fmap (*100) (Pair (2,3))
(200,3)
ghci&gt; getPair $ fmap reverse (Pair (&quot;london calling&quot;, 3))
(&quot;gnillac nodnol&quot;,3)</code></pre>
<h3 id="sobre-a-preguiça-do-newtype">Sobre a preguiça do newtype</h3>
<p>Mencionamos que <em>newtype</em> geralmente é mais rápido que
<em>data</em>. A única coisa que pode ser feita com <em>newtype</em> é
transformar um tipo existente em um novo tipo, então, internamente, o
Haskell pode representar os valores dos tipos definidos com
<em>newtype</em> exatamente como os originais, apenas lembrando que seus
tipos agora são distintos. Esse fato significa que <em>newtype</em> não
é apenas mais rápido, é também mais preguiçoso. Vamos dar uma olhada no
que isso significa.</p>
<p>Como dissemos antes, o Haskell é preguiçoso por padrão, o que
significa que apenas quando tentamos imprimir os resultados de nossas
funções é que qualquer cálculo ocorrerá. Além disso, apenas os cálculos
necessários para nossa função nos dizer o resultado serão realizados. O
valor <code>undefined</code> (indefinido) em Haskell representa um
cálculo errôneo. Se tentarmos avaliá-lo (ou seja, forçar o Haskell a
realmente calculá-lo) imprimindo-o no terminal, o Haskell terá um ataque
de pelanca (tecnicamente referido como uma exceção):</p>
<pre class="haskell:hs"><code>ghci&gt; undefined
*** Exception: Prelude.undefined</code></pre>
<p>No entanto, se fizermos uma lista que contém alguns valores
<code>undefined</code>, mas solicitarmos apenas a cabeça da lista, que
não é <code>undefined</code>, tudo correrá bem porque o Haskell
realmente não precisa avaliar nenhum outro elemento em uma lista se
quisermos ver apenas qual é o primeiro elemento:</p>
<pre class="haskell:hs"><code>ghci&gt; head [3,4,5,undefined,2,undefined]
3</code></pre>
<p>Agora considere o seguinte tipo:</p>
<pre class="haskell:hs"><code>data CoolBool = CoolBool { getCoolBool :: Bool }</code></pre>
<p>É o seu tipo de dados algébrico comum que foi definido com a
palavra-chave <em>data</em>. Ele tem um construtor de valor, que tem um
campo cujo tipo é <code>Bool</code>. Vamos fazer uma função que faça
pattern matching em um <code>CoolBool</code> e retorne o valor
<code>"hello"</code>, independentemente de o <code>Bool</code> dentro do
<code>CoolBool</code> ser <code>True</code> ou <code>False</code>:</p>
<pre class="haskell:hs"><code>helloMe :: CoolBool -&gt; String
helloMe (CoolBool _) = &quot;hello&quot;</code></pre>
<p>Em vez de aplicar essa função a um <code>CoolBool</code> normal,
vamos jogar uma bola curva e aplicá-la a <code>undefined</code>!</p>
<pre class="haskell:hs"><code>ghci&gt; helloMe undefined
&quot;*** Exception: Prelude.undefined</code></pre>
<p>Nossa! Uma exceção! Agora, por que essa exceção aconteceu? Tipos
definidos com a palavra-chave <em>data</em> podem ter vários
construtores de valor (embora <code>CoolBool</code> tenha apenas um).
Portanto, para verificar se o valor atribuído à nossa função está em
conformidade com o padrão <code>(CoolBool _)</code>, o Haskell deve
avaliar o valor apenas o suficiente para ver qual construtor de valor
foi usado quando fizemos o valor. E quando tentamos avaliar um valor
<code>undefined</code>, mesmo que um pouco, uma exceção é lançada.</p>
<p>Em vez de usar a palavra-chave <em>data</em> para
<code>CoolBool</code>, vamos tentar usar <em>newtype</em>:</p>
<pre class="haskell:hs"><code>newtype CoolBool = CoolBool { getCoolBool :: Bool }</code></pre>
<p>Não precisamos alterar nossa função <code>helloMe</code>, porque a
sintaxe de pattern matching é a mesma se você usa <em>newtype</em> ou
<em>data</em> para definir seu tipo. Vamos fazer a mesma coisa aqui e
aplicar <code>helloMe</code> a um valor <code>undefined</code>:</p>
<pre class="haskell:hs"><code>ghci&gt; helloMe undefined
&quot;hello&quot;</code></pre>
<p><img
src="assets/images/functors-applicative-functors-and-monoids/shamrock.png"
class="right" width="184" height="230"
alt="top of the mornin to ya!!!" /></p>
<p>Funcionou! Hmmm, por que isso? Bem, como dissemos, quando usamos
<em>newtype</em>, o Haskell pode representar internamente os valores do
novo tipo da mesma maneira que os valores originais. Ele não precisa
adicionar outra caixa ao redor deles, apenas precisa estar ciente de que
os valores são de tipos diferentes. E como o Haskell sabe que os tipos
feitos com a palavra-chave <em>newtype</em> só podem ter um construtor,
ele não precisa avaliar o valor passado para a função para garantir que
esteja em conformidade com o padrão <code>(CoolBool _)</code> porque
tipos <em>newtype</em> só podem ter um construtor de valor possível e um
campo!</p>
<p>Essa diferença no comportamento pode parecer trivial, mas na verdade
é muito importante porque nos ajuda a perceber que, embora os tipos
definidos com <em>data</em> e <em>newtype</em> se comportem da mesma
forma do ponto de vista do programador, porque ambos têm construtores de
valor e campos, eles são na verdade dois mecanismos diferentes. Enquanto
<em>data</em> pode ser usado para criar seus próprios tipos do zero,
<em>newtype</em> é para criar um tipo completamente novo a partir de um
tipo existente. O pattern matching em valores <em>newtype</em> não é
como tirar algo de uma caixa (como é com <em>data</em>), é mais sobre
fazer uma conversão direta de um tipo para outro.</p>
<h3 id="type-vs.-newtype-vs.-data"><code>type</code>
vs. <code>newtype</code> vs. <code>data</code></h3>
<p>Nesse ponto, você pode estar um pouco confuso sobre qual exatamente é
a diferença entre <em>type</em>, <em>data</em> e <em>newtype</em>, então
vamos refrescar nossa memória um pouco.</p>
<p>A palavra-chave <strong>type</strong> é para criar sinônimos de tipo.
O que isso significa é que apenas damos outro nome a um tipo já
existente para que seja mais fácil se referir a ele. Digamos que fizemos
o seguinte:</p>
<pre class="haskell:hs"><code>type IntList = [Int]</code></pre>
<p>Tudo o que isso faz é nos permitir referir ao tipo <code>[Int]</code>
como <code>IntList</code>. Eles podem ser usados ​​de forma
intercambiável. Não obtemos um construtor de valor <code>IntList</code>
ou algo assim. Como <code>[Int]</code> e <code>IntList</code> são apenas
duas maneiras de se referir ao mesmo tipo, não importa qual nome usamos
em nossas anotações de tipo:</p>
<pre class="haskell:hs"><code>ghci&gt; ([1,2,3] :: IntList) ++ ([1,2,3] :: [Int])
[1,2,3,1,2,3]</code></pre>
<p>Usamos sinônimos de tipo quando queremos tornar nossas assinaturas de
tipo mais descritivas, dando aos tipos nomes que nos dizem algo sobre
seu objetivo no contexto das funções em que estão sendo usados. Por
exemplo, quando usamos uma lista de associação do tipo
<code>[(String,String)]</code> para representar uma lista telefônica,
damos a ela o sinônimo de tipo <code>PhoneBook</code> para que as
assinaturas de tipo de nossas funções fossem mais fáceis de ler.</p>
<p>A palavra-chave <strong>newtype</strong> é para pegar tipos
existentes e embrulhá-los em novos tipos, principalmente para que seja
mais fácil torná-los instâncias de certas typeclasses. Quando usamos
<em>newtype</em> para embrulhar um tipo existente, o tipo que obtemos é
separado do tipo original. Se fizermos o seguinte <em>newtype</em>:</p>
<pre class="haskell:hs"><code>newtype CharList = CharList { getCharList :: [Char] }</code></pre>
<p>Não podemos usar <code>++</code> para juntar uma
<code>CharList</code> e uma lista do tipo <code>[Char]</code>. Não
podemos nem usar <code>++</code> para juntar duas
<code>CharList</code>s, porque <code>++</code> funciona apenas em listas
e o tipo <code>CharList</code> não é uma lista, embora possa ser dito
que contém uma. Podemos, no entanto, converter duas
<code>CharList</code>s em listas, usar <code>++</code> nelas e depois
converter isso de volta para uma <code>CharList</code>.</p>
<p>Quando usamos sintaxe de registro em nossas declarações
<em>newtype</em>, obtemos funções para converter entre o novo tipo e o
tipo original: ou seja, o construtor de valor do nosso <em>newtype</em>
e a função para extrair o valor em seu campo. O novo tipo também não é
feito automaticamente uma instância das typeclasses às quais o tipo
original pertence, então temos que derivá-las ou escrevê-las
manualmente.</p>
<p>Na prática, você pode pensar nas declarações <em>newtype</em> como
declarações <em>data</em> que só podem ter um construtor e um campo. Se
você se pegar escrevendo tal declaração <em>data</em>, considere usar
<em>newtype</em>.</p>
<p>A palavra-chave <strong>data</strong> é para fazer seus próprios
tipos de dados e com eles você pode enlouquecer. Eles podem ter quantos
construtores e campos você desejar e podem ser usados para implementar
qualquer tipo de dados algébrico por conta própria. Tudo, desde listas e
tipos semelhantes a <code>Maybe</code> até árvores.</p>
<p>Se você quer apenas que suas assinaturas de tipo pareçam mais limpas
e sejam mais descritivas, provavelmente você quer sinônimos de tipo. Se
você quer pegar um tipo existente e embrulhá-lo em um novo tipo para
torná-lo uma instância de uma typeclass, é provável que você esteja
procurando por um <em>newtype</em>. E se você quer fazer algo
completamente novo, as chances são boas de que você esteja procurando
pela palavra-chave <em>data</em>.</p>
<h2 id="monoids">Monoids</h2>
<p><img
src="assets/images/functors-applicative-functors-and-monoids/pirateship.png"
class="right" width="460" height="417"
alt="wow this is pretty much the gayest pirate ship ever" /></p>
<p>Começamos com typeclasses simples como <code>Eq</code>, que é para
tipos cujos valores podem ser igualados, e <code>Ord</code>, que é para
coisas que podem ser colocadas em uma ordem e depois passamos para
outras mais interessantes, como <code>Functor</code> e
<code>Applicative</code>.</p>
<p>Quando criamos um tipo, pensamos sobre quais comportamentos ele
suporta, ou seja, como ele pode agir e, com base nisso, decidimos de
quais typeclasses torná-lo uma instância. Se faz sentido que os valores
de nosso tipo sejam igualados, nós o tornamos uma instância da typeclass
<code>Eq</code>. Se vemos que nosso tipo é algum tipo de Functor, nós o
tornamos uma instância de <code>Functor</code>, e assim por diante.</p>
<p>Agora considere o seguinte: <code>*</code> é uma função que pega dois
números e os multiplica. Se multiplicarmos algum número por
<code>1</code>, o resultado é sempre igual a esse número. Não importa se
fazemos <code>1 * x</code> ou <code>x * 1</code>, o resultado é sempre
<code>x</code>. Da mesma forma, <code>++</code> é também uma função que
pega duas coisas e retorna uma terceira. Só que em vez de multiplicar
números, ela pega duas listas e as concatena. E muito parecido com
<code>*</code>, ela também tem um certo valor que não muda o outro
quando usado com <code>++</code>. Esse valor é a lista vazia:
<code>[]</code>.</p>
<pre class="haskell:hs"><code>ghci&gt; 4 * 1
4
ghci&gt; 1 * 9
9
ghci&gt; [1,2,3] ++ []
[1,2,3]
ghci&gt; [] ++ [0.5, 2.5]
[0.5,2.5]</code></pre>
<p>Parece que ambos <code>*</code> junto com <code>1</code> e
<code>++</code> junto com <code>[]</code> compartilham algumas
propriedades comuns:</p>
<ul>
<li>A função pega dois parâmetros.</li>
<li>Os parâmetros e o valor retornado têm o mesmo tipo.</li>
<li>Existe tal valor que não muda outros valores quando usado com a
função binária.</li>
</ul>
<p>Há outra coisa que essas duas operações têm em comum que pode não ser
tão óbvia quanto nossas observações anteriores: quando temos três ou
mais valores e queremos usar a função binária para reduzi-los a um único
resultado, a ordem em que aplicamos a função binária aos valores não
importa. Não importa se fazemos <code>(3 * 4) * 5</code> ou
<code>3 * (4 * 5)</code>. De qualquer maneira, o resultado é
<code>60</code>. O mesmo vale para <code>++</code>:</p>
<pre class="haskell:hs"><code>ghci&gt; (3 * 2) * (8 * 5)
240
ghci&gt; 3 * (2 * (8 * 5))
240
ghci&gt; &quot;la&quot; ++ (&quot;di&quot; ++ &quot;da&quot;)
&quot;ladida&quot;
ghci&gt; (&quot;la&quot; ++ &quot;di&quot;) ++ &quot;da&quot;
&quot;ladida&quot;</code></pre>
<p>Chamamos essa propriedade de <em>associatividade</em>. <code>*</code>
é associativo, e <code>++</code> também, mas <code>-</code>, por
exemplo, não é. As expressões <code>(5 - 3) - 4</code> e
<code>5 - (3 - 4)</code> resultam em números diferentes.</p>
<p>Ao perceber e anotar essas propriedades, nós encontramos Monoids! Um
Monoid é quando você tem uma função binária associativa e um valor que
age como uma identidade em relação a essa função. Quando algo age como
uma identidade em relação a uma função, significa que quando chamado com
essa função e algum outro valor, o resultado é sempre igual a esse outro
valor. <code>1</code> é a identidade em relação a <code>*</code> e
<code>[]</code> é a identidade em relação a <code>++</code>. Existem
muitos outros Monoids para serem encontrados no mundo de Haskell, e é
por isso que a typeclass <code>Monoid</code> existe. É para tipos que
podem agir como Monoids. Vamos ver como a typeclass é definida:</p>
<pre class="haskell:hs"><code>class Monoid m where
    mempty :: m
    mappend :: m -&gt; m -&gt; m
    mconcat :: [m] -&gt; m
    mconcat = foldr mappend mempty</code></pre>
<p><img
src="assets/images/functors-applicative-functors-and-monoids/balloondog.png"
class="right" width="260" height="326" alt="woof dee do!!!" /></p>
<p>A typeclass <code>Monoid</code> é definida em
<code>import Data.Monoid</code>. Vamos levar algum tempo e nos
familiarizar adequadamente com ela.</p>
<p>Primeiro de tudo, vemos que apenas tipos concretos podem ser feitos
instâncias de <code>Monoid</code>, porque o <code>m</code> na definição
da typeclass não pega nenhum parâmetro de tipo. Isso é diferente de
<code>Functor</code> e <code>Applicative</code>, que exigem que suas
instâncias sejam construtores de tipo que pegam um parâmetro.</p>
<p>A primeira função é <code>mempty</code>. Não é realmente uma função,
já que não pega parâmetros, então é uma constante polimórfica, meio que
como <code>minBound</code> de <code>Bounded</code>. <code>mempty</code>
representa o valor de identidade para um Monoid específico.</p>
<p>Em seguido, temos <code>mappend</code>, que, como você provavelmente
adivinhou, é a função binária. Ela pega dois valores do mesmo tipo e
retorna um valor desse tipo também. Vale a pena notar que a decisão de
nomear <code>mappend</code> como é nomeado foi meio infeliz, porque
implica que estamos anexando duas coisas de alguma forma. Embora
<code>++</code> realmente pegue duas listas e anexe uma à outra,
<code>*</code> realmente não faz nenhum anexo, apenas multiplica dois
números. Quando encontrarmos outras instâncias de <code>Monoid</code>,
veremos que a maioria delas também não anexa valores, então evite pensar
em termos de anexar e apenas pense em termos de <code>mappend</code> ser
uma função binária que pega dois valores de monóide e retorna um
terceiro.</p>
<p>A última função nesta definição de typeclass é <code>mconcat</code>.
Ela pega uma lista de valores de monóide e os reduz a um único valor
fazendo <code>mappend</code> entre os elementos da lista. Ela tem uma
implementação padrão, que apenas pega <code>mempty</code> como valor
inicial e dobra (fold) a lista da direita com <code>mappend</code>. Como
a implementação padrão é boa para a maioria das instâncias, não nos
preocuparemos muito com <code>mconcat</code> de agora em diante. Ao
tornar um tipo uma instância de <code>Monoid</code>, basta implementar
<code>mempty</code> e <code>mappend</code>. A razão pela qual
<code>mconcat</code> está lá é porque para algumas instâncias, pode
haver uma maneira mais eficiente de implementar <code>mconcat</code>,
mas para a maioria das instâncias a implementação padrão é boa o
suficiente.</p>
<p>Antes de passar para instâncias específicas de <code>Monoid</code>,
vamos dar uma breve olhada nas leis dos Monoids. Mencionamos que deve
haver um valor que atue como identidade em relação à função binária e
que a função binária deve ser associativa. É possível fazer instâncias
de <code>Monoid</code> que não seguem essas regras, mas tais instâncias
não servem para ninguém, porque ao usar a typeclass <code>Monoid</code>,
confiamos em suas instâncias agindo como Monoids. Caso contrário, qual é
o ponto? É por isso que ao fazer instâncias, temos que ter certeza de
que elas seguem essas leis:</p>
<ul>
<li><code class="label law">mempty `mappend` x = x</code></li>
<li><code class="label law">x `mappend` mempty = x</code></li>
<li><code
class="label law">(x `mappend` y) `mappend` z = x `mappend` (y `mappend` z)</code></li>
</ul>
<p>As duas primeiras afirmam que <code>mempty</code> tem que agir como a
identidade em relação a <code>mappend</code> e a terceira diz que
<code>mappend</code> tem que ser associativa, ou seja, que a ordem em
que usamos <code>mappend</code> para reduzir vários valores de Monoid em
um não importa. O Haskell não impõe essas leis, então nós, como
programadores, temos que ter cuidado para que nossas instâncias de fato
as obedeçam.</p>
<h3 id="listas-são-monoids">Listas são Monoids</h3>
<p>Sim, listas são Monoids! Como vimos, a função <code>++</code> e a
lista vazia <code>[]</code> formam um Monoid. A instância é muito
simples:</p>
<pre class="haskell:hs"><code>instance Monoid [a] where
    mempty = []
    mappend = (++)</code></pre>
<p>Listas são uma instância da typeclass <code>Monoid</code>
independentemente do tipo dos elementos que elas contêm. Observe que
escrevemos <code>instance Monoid [a]</code> e não
<code>instance Monoid []</code>, porque <code>Monoid</code> requer um
tipo concreto para uma instância.</p>
<p>Dando a isso um teste, não encontramos surpresas:</p>
<pre class="haskell:hs"><code>ghci&gt; [1,2,3] `mappend` [4,5,6]
[1,2,3,4,5,6]
ghci&gt; (&quot;one&quot; `mappend` &quot;two&quot;) `mappend` &quot;tree&quot;
&quot;onetwotree&quot;
ghci&gt; &quot;one&quot; `mappend` (&quot;two&quot; `mappend` &quot;tree&quot;)
&quot;onetwotree&quot;
ghci&gt; &quot;one&quot; `mappend` &quot;two&quot; `mappend` &quot;tree&quot;
&quot;onetwotree&quot;
ghci&gt; &quot;pang&quot; `mappend` mempty
&quot;pang&quot;
ghci&gt; mconcat [[1,2],[3,6],[9]]
[1,2,3,6,9]
ghci&gt; mempty :: [a]
[]</code></pre>
<p><img
src="assets/images/functors-applicative-functors-and-monoids/smug.png"
class="left" width="157" height="144" alt="smug as hell" /></p>
<p>Observe que na última linha, tivemos que escrever uma anotação de
tipo explícita, porque se apenas fizéssemos <code>mempty</code>, o GHCi
não saberia qual instância usar, então tivemos que dizer que queríamos a
instância da lista. Fomos capazes de usar o tipo geral de
<code>[a]</code> (em oposição a especificar <code>[Int]</code> ou
<code>[String]</code>) porque a lista vazia pode agir como se contivesse
qualquer tipo.</p>
<p>Como <code>mconcat</code> tem uma implementação padrão, nós a obtemos
de graça quando tornamos algo uma instância de <code>Monoid</code>. No
caso da lista, <code>mconcat</code> acaba sendo apenas
<code>concat</code>. Ela pega uma lista de listas e a achata, porque
esse é o equivalente a fazer <code>++</code> entre todas as listas
adjacentes em uma lista.</p>
<p>As leis dos Monoids realmente se mantêm para a instância da lista.
Quando temos várias listas e as <code>mappend</code> (ou
<code>++</code>) juntas, não importa quais fazemos primeiro, porque elas
são apenas unidas nas extremidades de qualquer maneira. Além disso, a
lista vazia age como a identidade, então tudo está bem. Observe que os
Monoids não exigem que <code>a `mappend` b</code> seja igual a
<code>b `mappend` a</code>. No caso da lista, eles claramente não
são:</p>
<pre class="haskell:hs"><code>ghci&gt; &quot;one&quot; `mappend` &quot;two&quot;
&quot;onetwo&quot;
ghci&gt; &quot;two&quot; `mappend` &quot;one&quot;
&quot;twoone&quot;</code></pre>
<p>E tudo bem. O fato de que para multiplicação <code>3 * 5</code> e
<code>5 * 3</code> são os mesmos é apenas uma propriedade da
multiplicação, mas não se mantém para todos (e de fato, a maioria) os
Monoids.</p>
<h3 id="product-e-sum"><code>Product</code> e <code>Sum</code></h3>
<p>Já examinamos uma maneira de os números serem considerados Monoids.
Basta ter a função binária sendo <code>*</code> e o valor de identidade
<code>1</code>. Acontece que essa não é a única maneira de os números
serem Monoids. Outra maneira é ter a função binária sendo <code>+</code>
e o valor de identidade <code>0</code>:</p>
<pre class="haskell:hs"><code>ghci&gt; 0 + 4
4
ghci&gt; 5 + 0
5
ghci&gt; (1 + 3) + 5
9
ghci&gt; 1 + (3 + 5)
9</code></pre>
<p>As leis dos Monoids se mantêm, porque se você adicionar 0 a qualquer
número, o resultado é esse número. E a adição também é associativa,
então não temos problemas lá. Então, agora que existem duas maneiras
igualmente válidas para os números serem Monoids, qual maneira escolher?
Bem, não precisamos escolher. Lembre-se, quando existem várias maneiras
de um tipo ser uma instância da mesma typeclass, podemos embrulhar esse
tipo em um <em>newtype</em> e então tornar o novo tipo uma instância da
typeclass de uma maneira diferente. Podemos ter nosso bolo e comê-lo
também.</p>
<p>O módulo <code>Data.Monoid</code> exporta dois tipos para isso, a
saber <code>Product</code> e <code>Sum</code>. <code>Product</code> é
definido assim:</p>
<pre class="haskell:hs"><code>newtype Product a =  Product { getProduct :: a }
    deriving (Eq, Ord, Read, Show, Bounded)</code></pre>
<p>Simples, apenas um embrulho <em>newtype</em> com um parâmetro de tipo
juntamente com algumas instâncias derivadas. Sua instância para
<code>Monoid</code> vai mais ou menos assim:</p>
<pre class="haskell:hs"><code>instance Num a =&gt; Monoid (Product a) where
    mempty = Product 1
    Product x `mappend` Product y = Product (x * y)</code></pre>
<p><code>mempty</code> é apenas <code>1</code> embrulhado em um
construtor <code>Product</code>. <code>mappend</code> faz pattern
matching no construtor <code>Product</code>, multiplica os dois números
e então embrulha o número resultante de volta. Como você pode ver, há
uma restrição de classe <code>Num a</code>. Então isso significa que
<code>Product a</code> é uma instância de <code>Monoid</code> para todos
os <code>a</code>s que já são uma instância de <code>Num</code>. Para
usar <code>Product a</code> como um monóide, temos que fazer algum
embrulho e desembrulho de <em>newtype</em>:</p>
<pre class="haskell:hs"><code>ghci&gt; getProduct $ Product 3 `mappend` Product 9
27
ghci&gt; getProduct $ Product 3 `mappend` mempty
3
ghci&gt; getProduct $ Product 3 `mappend` Product 4 `mappend` Product 2
24
ghci&gt; getProduct . mconcat . map Product $ [3,4,2]
24</code></pre>
<p>Isso é legal como uma vitrine da typeclass <code>Monoid</code>, mas
ninguém em sã consciência usaria essa maneira de multiplicar números em
vez de apenas escrever <code>3 * 9</code> e <code>3 * 1</code>. Mas um
pouco mais tarde, veremos como essas instâncias de <code>Monoid</code>
que podem parecer triviais agora podem ser úteis.</p>
<p><code>Sum</code> é definido como <code>Product</code> e a instância é
semelhante também. Nós o usamos da mesma maneira:</p>
<pre class="haskell:hs"><code>ghci&gt; getSum $ Sum 2 `mappend` Sum 9
11
ghci&gt; getSum $ mempty `mappend` Sum 3
3
ghci&gt; getSum . mconcat . map Sum $ [1,2,3]
6</code></pre>
<h3 id="any-e-all"><code>Any</code> e <code>All</code></h3>
<p>Outro tipo que pode agir como um Monoid de duas maneiras distintas,
mas igualmente válidas, é <code>Bool</code>. A primeira maneira é fazer
a função <em>ou</em> <code>||</code> agir como a função binária
juntamente com <code>False</code> como o valor de identidade. A maneira
como o <em>ou</em> funciona na lógica é que se qualquer um de seus dois
parâmetros for <code>True</code>, ele retorna <code>True</code>, caso
contrário, retorna <code>False</code>. Então, se usarmos
<code>False</code> como valor de identidade, ele retornará
<code>False</code> quando fizermos <em>ou</em> com <code>False</code> e
<code>True</code> quando fizermos <em>ou</em> com <code>True</code>. O
construtor <em>newtype</em> <code>Any</code> é uma instância de
<code>Monoid</code> dessa maneira. É definido assim:</p>
<pre class="haskell:hs"><code>newtype Any = Any { getAny :: Bool }
    deriving (Eq, Ord, Read, Show, Bounded)</code></pre>
<p>Sua instância parece ser assim:</p>
<pre class="haskell:hs"><code>instance Monoid Any where
        mempty = Any False
        Any x `mappend` Any y = Any (x || y)</code></pre>
<p>A razão pela qual é chamado <code>Any</code> é porque
<code>x `mappend` y</code> será <code>True</code> se <em>qualquer</em>
um desses dois for <code>True</code>. Mesmo que três ou mais
<code>Bool</code>s embrulhados em <code>Any</code> sejam
<code>mappend</code> juntos, o resultado será <code>True</code> se
qualquer um deles for <code>True</code>:</p>
<pre class="haskell:hs"><code>ghci&gt; getAny $ Any True `mappend` Any False
True
ghci&gt; getAny $ mempty `mappend` Any True
True
ghci&gt; getAny . mconcat . map Any $ [False, False, False, True]
True
ghci&gt; getAny $ mempty `mappend` mempty
False</code></pre>
<p>A outra maneira de <code>Bool</code> ser uma instância de
<code>Monoid</code> é fazer meio que o oposto: ter
<code>&amp;&amp;</code> sendo a função binária e então fazer
<code>True</code> o valor de identidade. O <em>e</em> lógico retornará
<code>True</code> apenas se ambos os seus parâmetros forem
<code>True</code>. Esta é a declaração <em>newtype</em>, nada
chique:</p>
<pre class="haskell:hs"><code>newtype All = All { getAll :: Bool }
        deriving (Eq, Ord, Read, Show, Bounded)</code></pre>
<p>E esta é a instância:</p>
<pre class="haskell:hs"><code>instance Monoid All where
        mempty = All True
        All x `mappend` All y = All (x &amp;&amp; y)</code></pre>
<p>Quando fazemos <code>mappend</code> em valores do tipo
<code>All</code>, o resultado será <code>True</code> apenas se
<em>todos</em> os valores usados nas operações <code>mappend</code>
forem <code>True</code>:</p>
<pre class="haskell:hs"><code>ghci&gt; getAll $ mempty `mappend` All True
True
ghci&gt; getAll $ mempty `mappend` All False
False
ghci&gt; getAll . mconcat . map All $ [True, True, True]
True
ghci&gt; getAll . mconcat . map All $ [True, True, False]
False</code></pre>
<p>Assim como com multiplicação e adição, geralmente indicamos
explicitamente as funções binárias em vez de embrulhá-las em
<em>newtype</em>s e depois usar <code>mappend</code> e
<code>mempty</code>. <code>mconcat</code> parece ser útil para
<code>Any</code> e <code>All</code>, mas geralmente é mais fácil usar as
funções <code>or</code> e <code>and</code>, que pegam listas de
<code>Bool</code>s e retornam <code>True</code> se qualquer um deles for
<code>True</code> ou se todos eles forem <code>True</code>,
respectivamente.</p>
<h3 id="the-ordering-monoid">The Ordering Monoid</h3>
<p>Ei, lembra do tipo <code>Ordering</code>? Ele é usado como o
resultado ao comparar coisas e pode ter três valores: <code>LT</code>,
<code>EQ</code> e <code>GT</code>, que significam <em>less than</em>
(menor que), <em>equal</em> (igual) e <em>greater than</em> (maior que),
respectivamente:</p>
<pre class="haskell:hs"><code>ghci&gt; 1 `compare` 2
LT
ghci&gt; 2 `compare` 2
EQ
ghci&gt; 3 `compare` 2
GT</code></pre>
<p>Com listas, números e valores booleanos, encontrar Monoids foi apenas
uma questão de olhar para funções comumente usadas já existentes e ver
se elas exibem algum tipo de comportamento de Monoid. Com
<code>Ordering</code>, temos que olhar um pouco mais para reconhecer um
Monoid, mas acontece que sua instância <code>Monoid</code> é tão
intuitiva quanto as que encontramos até agora e também bastante
útil:</p>
<pre class="haskell:hs"><code>instance Monoid Ordering where
    mempty = EQ
    LT `mappend` _ = LT
    EQ `mappend` y = y
    GT `mappend` _ = GT</code></pre>
<p><img
src="assets/images/functors-applicative-functors-and-monoids/bear.png"
class="right" width="330" height="339"
alt="did anyone ORDER pizza?!?! I can’t BEAR these puns!" /></p>
<p>A instância é configurada assim: quando fazemos <code>mappend</code>
em dois valores <code>Ordering</code>, o da esquerda é mantido, a menos
que o valor da esquerda seja <code>EQ</code>, caso em que o da direita é
o resultado. A identidade é <code>EQ</code>. A princípio, isso pode
parecer meio arbitrário, mas na verdade se assemelha à maneira como
comparamos alfabeticamente palavras. Comparamos as duas primeiras letras
e, se forem diferentes, já podemos decidir qual palavra iria primeiro em
um dicionário. No entanto, se as duas primeiras letras forem iguais,
passamos a comparar o próximo par de letras e repetimos o processo.</p>
<p>Por exemplo, se fôssemos comparar alfabeticamente as palavras
<code>"ox"</code> e <code>"on"</code>, primeiro compararíamos as
primeiras duas letras de cada palavra, veríamos que são iguais e então
passaríamos a comparar a segunda letra de cada palavra. Vemos que
<code>'x'</code> é alfabeticamente maior que <code>'n'</code>, e assim
sabemos como as palavras se comparam. Para ganhar alguma intuição para
<code>EQ</code> sendo a identidade, podemos notar que se fôssemos enfiar
a mesma letra na mesma posição em ambas as palavras, isso não mudaria
sua ordem alfabética. <code>"oix"</code> ainda é alfabeticamente maior
que <code>"oin"</code>.</p>
<p>É importante notar que na instância <code>Monoid</code> para
<code>Ordering</code>, <code>x `mappend` y</code> não é igual a
<code>y `mappend` x</code>. Como o primeiro parâmetro é mantido a menos
que seja <code>EQ</code>, <code>LT `mappend` GT</code> resultará em
<code>LT</code>, enquanto <code>GT `mappend` LT</code> resultará em
<code>GT</code>:</p>
<pre class="haskell:hs"><code>ghci&gt; LT `mappend` GT
LT
ghci&gt; GT `mappend` LT
GT
ghci&gt; mempty `mappend` LT
LT
ghci&gt; mempty `mappend` GT
GT</code></pre>
<p>OK, então como esse monóide é útil? Digamos que você estivesse
escrevendo uma função que pega duas strings, compara seus comprimentos e
retorna um <code>Ordering</code>. Mas se as strings forem do mesmo
comprimento, então em vez de retornar <code>EQ</code> imediatamente,
queremos compará-las alfabeticamente. Uma maneira de escrever isso seria
assim:</p>
<pre class="haskell:hs"><code>lengthCompare :: String -&gt; String -&gt; Ordering
lengthCompare x y = let a = length x `compare` length y
                        b = x `compare` y
                    in  if a == EQ then b else a</code></pre>
<p>Nomeamos o resultado da comparação dos comprimentos de <code>a</code>
e o resultado da comparação alfabética de <code>b</code> e então se
acontecer de os comprimentos serem iguais, retornamos sua ordem
alfabética.</p>
<p>Mas ao empregar nosso entendimento de como <code>Ordering</code> é um
Monoid, podemos reescrever essa função de uma maneira muito mais
simples:</p>
<pre class="haskell:hs"><code>import Data.Monoid

lengthCompare :: String -&gt; String -&gt; Ordering
lengthCompare x y = (length x `compare` length y) `mappend`
                    (x `compare` y)</code></pre>
<p>Podemos experimentar isso:</p>
<pre class="haskell:hs"><code>ghci&gt; lengthCompare &quot;zen&quot; &quot;ants&quot;
LT
ghci&gt; lengthCompare &quot;zen&quot; &quot;ant&quot;
GT</code></pre>
<p>Lembre-se, quando usamos <code>mappend</code>, seu parâmetro esquerdo
é sempre mantido a menos que seja <code>EQ</code>, caso em que o direito
é mantido. É por isso que colocamos a comparação que consideramos ser o
primeiro, mais importante critério como o primeiro parâmetro. Se
quiséssemos expandir essa função para também comparar pelo número de
vogais e definir isso como o segundo critério mais importante para
comparação, apenas a modificaríamos assim:</p>
<pre class="haskell:hs"><code>import Data.Monoid

lengthCompare :: String -&gt; String -&gt; Ordering
lengthCompare x y = (length x `compare` length y) `mappend`
                    (vowels x `compare` vowels y) `mappend`
                    (x `compare` y)
    where vowels = length . filter (`elem` &quot;aeiou&quot;)</code></pre>
<p>Fizemos uma função auxiliar, que pega uma string e nos diz quantas
vogais ela tem, primeiro filtrando-a apenas para letras que estão na
string <code>"aeiou"</code> e depois aplicando <code>length</code> a
isso.</p>
<pre class="haskell:hs"><code>ghci&gt; lengthCompare &quot;zen&quot; &quot;anna&quot;
LT
ghci&gt; lengthCompare &quot;zen&quot; &quot;ana&quot;
LT
ghci&gt; lengthCompare &quot;zen&quot; &quot;ann&quot;
GT</code></pre>
<p>Muito legal. Aqui, vemos como no primeiro exemplo os comprimentos são
considerados diferentes e então <code>LT</code> é retornado, porque o
comprimento de <code>"zen"</code> é menor que o comprimento de
<code>"anna"</code>. No segundo exemplo, os comprimentos são os mesmos,
mas a segunda string tem mais vogais, então <code>LT</code> é retornado
novamente. No terceiro exemplo, ambas têm o mesmo comprimento e o mesmo
número de vogais, então são comparadas alfabeticamente e
<code>"zen"</code> ganha.</p>
<h3 id="the-maybe-monoid">The Maybe Monoid</h3>
<p>Vamos dar uma olhada nas várias maneiras que <code>Maybe a</code>
pode ser feito uma instância de <code>Monoid</code> e para que essas
instâncias são úteis.</p>
<p>Uma maneira é tratar <code>Maybe a</code> como um Monoid apenas se
seu parâmetro de tipo <code>a</code> for um Monoid também e então
implementar <code>mappend</code> de tal maneira que use a operação
<code>mappend</code> dos valores que estão embrulhados com
<code>Just</code>. Usamos <code>Nothing</code> como a identidade, e
então se um dos dois valores que estamos fazendo <code>mappend</code>
for <code>Nothing</code>, mantemos o outro valor. Aqui está a declaração
da instância:</p>
<pre class="haskell:hs"><code>instance Monoid a =&gt; Monoid (Maybe a) where
    mempty = Nothing
    Nothing `mappend` m = m
    m `mappend` Nothing = m
    Just m1 `mappend` Just m2 = Just (m1 `mappend` m2)</code></pre>
<p>Observe a restrição de classe. Ela diz que <code>Maybe a</code> é uma
instância de <code>Monoid</code> apenas se <code>a</code> for uma
instância de <code>Monoid</code>. Se fizermos <code>mappend</code> de
algo com um <code>Nothing</code>, o resultado é esse algo. Se fizermos
<code>mappend</code> de dois valores <code>Just</code>, o conteúdo dos
<code>Just</code>s é <code>mappended</code> e então embrulhado de volta
em um <code>Just</code>. Podemos fazer isso porque a restrição de classe
garante que o tipo do que está dentro do <code>Just</code> é uma
instância de <code>Monoid</code>.</p>
<pre class="haskell:hs"><code>ghci&gt; Nothing `mappend` Just &quot;andy&quot;
Just &quot;andy&quot;
ghci&gt; Just LT `mappend` Nothing
Just LT
ghci&gt; Just (Sum 3) `mappend` Just (Sum 4)
Just (Sum {getSum = 7})</code></pre>
<p>Isso é útil quando você está lidando com Monoids como resultados de
cálculos que podem ter falhado. Por causa dessa instância, não temos que
verificar se os cálculos falharam vendo se são um valor
<code>Nothing</code> ou <code>Just</code>; podemos apenas continuar a
tratá-los como Monoids normais.</p>
<p>Mas e se o tipo do conteúdo de <code>Maybe</code> não for uma
instância de <code>Monoid</code>? Observe que na declaração de instância
anterior, o único caso em que temos que confiar que o conteúdo são
Monoids é quando ambos os parâmetros de <code>mappend</code> são valores
<code>Just</code>. Mas se não sabemos se o conteúdo são Monoids, não
podemos usar <code>mappend</code> entre eles, então o que devemos fazer?
Bem, uma coisa que podemos fazer é apenas descartar o segundo valor e
manter o primeiro. Para isso, o tipo <code>First a</code> existe e esta
é a sua definição:</p>
<pre class="haskell:hs"><code>newtype First a = First { getFirst :: Maybe a }
    deriving (Eq, Ord, Read, Show)</code></pre>
<p>Pegamos um <code>Maybe a</code> e o embrulhamos com um
<em>newtype</em>. A instância <code>Monoid</code> é a seguinte:</p>
<pre class="haskell:hs"><code>instance Monoid (First a) where
    mempty = First Nothing
    First (Just x) `mappend` _ = First (Just x)
    First Nothing `mappend` x = x</code></pre>
<p>Assim como dissemos. <code>mempty</code> é apenas um
<code>Nothing</code> embrulhado com o construtor <em>newtype</em>
<code>First</code>. Se o primeiro parâmetro de <code>mappend</code> for
um valor <code>Just</code>, ignoramos o segundo. Se o primeiro for um
<code>Nothing</code>, então apresentamos o segundo parâmetro como
resultado, independentemente de ser um <code>Just</code> ou um
<code>Nothing</code>:</p>
<pre class="haskell:hs"><code>ghci&gt; getFirst $ First (Just &#39;a&#39;) `mappend` First (Just &#39;b&#39;)
Just &#39;a&#39;
ghci&gt; getFirst $ First Nothing `mappend` First (Just &#39;b&#39;)
Just &#39;b&#39;
ghci&gt; getFirst $ First (Just &#39;a&#39;) `mappend` First Nothing
Just &#39;a&#39;</code></pre>
<p><code>First</code> é útil quando temos um monte de valores
<code>Maybe</code> e queremos apenas saber se algum deles é um
<code>Just</code>. A função <code>mconcat</code> vem a calhar:</p>
<pre class="haskell:hs"><code>ghci&gt; getFirst . mconcat . map First $ [Nothing, Just 9, Just 10]
Just 9</code></pre>
<p>Se quisermos um Monoid sobre <code>Maybe a</code> de tal forma que o
segundo parâmetro seja mantido se ambos os parâmetros de
<code>mappend</code> forem valores <code>Just</code>,
<code>Data.Monoid</code> fornece um tipo <code>Last a</code>, que
funciona como <code>First a</code>, só que o último valor
não-<code>Nothing</code> é mantido ao fazer <code>mappend</code> e usar
<code>mconcat</code>:</p>
<pre class="haskell:hs"><code>ghci&gt; getLast . mconcat . map Last $ [Nothing, Just 9, Just 10]
Just 10
ghci&gt; getLast $ Last (Just &quot;one&quot;) `mappend` Last (Just &quot;two&quot;)
Just &quot;two&quot;</code></pre>
<h3 id="usando-monoids-para-dobrar-estruturas-de-dados">Usando Monoids
para dobrar estruturas de dados</h3>
<p>Uma das maneiras mais interessantes de colocar Monoids para trabalhar
é fazê-los nos ajudar a definir dobras (folds) sobre várias estruturas
de dados. Até agora, fizemos apenas dobras sobre listas, mas listas não
são a única estrutura de dados que pode ser dobrada. Podemos definir
dobras sobre quase qualquer estrutura de dados. Árvores especialmente se
prestam bem a dobras.</p>
<p>Como existem tantas estruturas de dados que funcionam bem com dobras,
a typeclass <code class="label class">Foldable</code> foi introduzida.
Muito parecido com <code>Functor</code> é para coisas que podem ser
mapeadas, <code>Foldable</code> é para coisas que podem ser dobradas!
Ela pode ser encontrada em <code>Data.Foldable</code> e porque exporta
funções cujos nomes entram em conflito com os do <code>Prelude</code>, é
melhor importada qualificada (e servida com manjericão):</p>
<pre class="haskell:hs"><code>import qualified Foldable as F</code></pre>
<p>Para economizar preciosos toques de tecla, escolhemos importá-la
qualificada como <code>F</code>. Certo, então quais são algumas das
funções que essa typeclass define? Bem, entre elas estão
<code>foldr</code>, <code>foldl</code>, <code>foldr1</code> e
<code>foldl1</code>. Hã? Mas já conhecemos essas funções, o que há de
tão novo nisso? Vamos comparar os tipos de <code>foldr</code> de
<code>Foldable</code> e o <code>foldr</code> do <code>Prelude</code>
para ver como eles diferem:</p>
<pre class="haskell:hs"><code>ghci&gt; :t foldr
foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
ghci&gt; :t F.foldr
F.foldr :: (F.Foldable t) =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b</code></pre>
<p>Ah! Então, enquanto <code>foldr</code> pega uma lista e a dobra, o
<code>foldr</code> de <code>Data.Foldable</code> aceita qualquer tipo
que possa ser dobrado, não apenas listas! Como esperado, ambas as
funções <code>foldr</code> fazem o mesmo para listas:</p>
<pre class="haskell:hs"><code>ghci&gt; foldr (*) 1 [1,2,3]
6
ghci&gt; F.foldr (*) 1 [1,2,3]
6</code></pre>
<p>Ok então, quais são algumas outras estruturas de dados que suportam
dobras? Bem, tem o <code>Maybe</code> que todos conhecemos e amamos!</p>
<pre class="haskell:hs"><code>ghci&gt; F.foldl (+) 2 (Just 9)
11
ghci&gt; F.foldr (||) False (Just True)
True</code></pre>
<p>Mas dobrar sobre um valor <code>Maybe</code> não é terrivelmente
interessante, porque quando se trata de dobrar, ele apenas age como uma
lista com um elemento se for um valor <code>Just</code> e como uma lista
vazia se for <code>Nothing</code>. Então, vamos examinar uma estrutura
de dados um pouco mais complexa então.</p>
<p>Lembre-se da estrutura de dados de árvore do capítulo <a
href="making-our-own-types-and-typeclasses.html#recursive-data-structures">Making
Our Own Types and Typeclasses</a>? Nós a definimos assim:</p>
<pre class="haskell:hs"><code>data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)</code></pre>
<p>Dissemos que uma árvore é ou uma árvore vazia que não contém nenhum
valor ou é um nó que contém um valor e também duas outras árvores.
Depois de defini-la, nós a tornamos uma instância de
<code>Functor</code> e com isso ganhamos a habilidade de
<code>fmap</code> funções sobre ela. Agora, vamos torná-la uma instância
de <code>Foldable</code> para que tenhamos a habilidade de dobrá-la. Uma
maneira de tornar um construtor de tipo uma instância de
<code>Foldable</code> é apenas implementar diretamente
<code>foldr</code> para ele. Mas outra maneira, muitas vezes muito mais
fácil, é implementar a função <code>foldMap</code>, que também faz parte
da typeclass <code>Foldable</code>. A função <code>foldMap</code> tem o
seguinte tipo:</p>
<pre class="haskell:hs"><code>foldMap :: (Monoid m, Foldable t) =&gt; (a -&gt; m) -&gt; t a -&gt; m</code></pre>
<p>Seu primeiro parâmetro é uma função que pega um valor do tipo que
nossa estrutura dobrável contém (denotado aqui com <code>a</code>) e
retorna um valor de Monoid. Seu segundo parâmetro é uma estrutura
dobrável que contém valores do tipo <code>a</code>. Ela mapeia essa
função sobre a estrutura dobrável, produzindo assim uma estrutura
dobrável que contém valores de Monoid. Então, fazendo
<code>mappend</code> entre esses valores de Monoid, ela os une todos em
um único valor de Monoid. Essa função pode soar meio estranha no
momento, mas veremos que é muito fácil de implementar. O que também é
legal é que implementar essa função é tudo o que é preciso para o nosso
tipo ser feito uma instância de <code>Foldable</code>. Então, se apenas
implementarmos <code>foldMap</code> para algum tipo, obtemos
<code>foldr</code> e <code>foldl</code> nesse tipo de graça!</p>
<p>É assim que fazemos <code>Tree</code> uma instância de
<code>Foldable</code>:</p>
<pre class="haskell:hs"><code>instance F.Foldable Tree where
    foldMap f Empty = mempty
    foldMap f (Node x l r) = F.foldMap f l `mappend`
                             f x           `mappend`
                             F.foldMap f r</code></pre>
<p><img
src="assets/images/functors-applicative-functors-and-monoids/accordion.png"
class="right" width="366" height="280"
alt="find the visual pun or whatever" /></p>
<p>Pensamos assim: se nos for fornecida uma função que pega um elemento
de nossa árvore e retorna um valor de Monoid, como reduzimos nossa
árvore inteira a um único valor de Monoid? Quando estávamos fazendo
<code>fmap</code> sobre nossa árvore, aplicávamos a função que estávamos
mapeando a um nó e então mapeávamos recursivamente a função sobre a
subárvore esquerda, bem como a direita. Aqui, somos encarregados de não
apenas mapear uma função, mas também de unir os resultados em um único
valor de Monoid usando <code>mappend</code>. Primeiro consideramos o
caso da árvore vazia — uma árvore triste e solitária que não tem valores
ou subárvores. Ela não contém nenhum valor que possamos dar à nossa
função criadora de Monoids, então apenas dizemos que se nossa árvore
estiver vazia, o valor de Monoid em que ela se torna é
<code>mempty</code>.</p>
<p>O caso de um nó não vazio é um pouco mais interessante. Ele contém
duas subárvores, bem como um valor. Neste caso, recursivamente
<code>foldMap</code> a mesma função <code>f</code> sobre as subárvores
esquerda e direita. Lembre-se, nosso <code>foldMap</code> resulta em um
único valor de Monoid. Também aplicamos nossa função <code>f</code> ao
valor no nó. Agora temos três valores de Monoid (dois de nossas
subárvores e um da aplicação de <code>f</code> ao valor no nó) e apenas
temos que juntá-los em um único valor. Para esse propósito, usamos
<code>mappend</code>, e naturalmente a subárvore esquerda vem primeiro,
depois o valor do nó e então a subárvore direita.</p>
<p>Observe que não tivemos que fornecer a função que pega um valor e
retorna um valor de Monoid. Recebemos essa função como parâmetro para
<code>foldMap</code> e tudo o que temos a decidir é onde aplicar essa
função e como unir os Monoids resultantes dela.</p>
<p>Agora que temos uma instância <code>Foldable</code> para nosso tipo
de árvore, obtemos <code>foldr</code> e <code>foldl</code> de graça!
Considere esta árvore:</p>
<pre class="haskell:hs"><code>testTree = Node 5
            (Node 3
                (Node 1 Empty Empty)
                (Node 6 Empty Empty)
            )
            (Node 9
                (Node 8 Empty Empty)
                (Node 10 Empty Empty)
            )</code></pre>
<p>Ela tem <code>5</code> em sua raiz e então seu nó esquerdo tem
<code>3</code> com <code>1</code> à esquerda e <code>6</code> à direita.
O nó direito da raiz tem um <code>9</code> e então um <code>8</code> à
sua esquerda e um <code>10</code> no lado direito distante. Com uma
instância <code>Foldable</code>, podemos fazer todas as dobras que
podemos fazer em listas:</p>
<pre class="haskell:hs"><code>ghci&gt; F.foldl (+) 0 testTree
42
ghci&gt; F.foldl (*) 1 testTree
64800</code></pre>
<p>E também, <code>foldMap</code> não é útil apenas para fazer novas
instâncias de <code>Foldable</code>; ele vem a calhar para reduzir nossa
estrutura a um único valor de Monoid. Por exemplo, se quisermos saber se
algum número em nossa árvore é igual a <code>3</code>, podemos fazer
isso:</p>
<pre class="haskell:hs"><code>ghci&gt; getAny $ F.foldMap (\x -&gt; Any $ x == 3) testTree
True</code></pre>
<p>Aqui, <code>\x -&gt; Any $ x == 3</code> é uma função que pega um
número e retorna um valor de Monoid, ou seja, um <code>Bool</code>
embrulhado em <code>Any</code>. <code>foldMap</code> aplica essa função
a cada elemento em nossa árvore e então reduz os Monoids resultantes em
um único Monoid com <code>mappend</code>. Se fizermos isso:</p>
<pre class="haskell:hs"><code>ghci&gt; getAny $ F.foldMap (\x -&gt; Any $ x &gt; 15) testTree
False</code></pre>
<p>Todos os nós em nossa árvore conteriam o valor <code>Any False</code>
depois de ter a função lambda aplicada a eles. Mas para acabar
<code>True</code>, <code>mappend</code> para <code>Any</code> tem que
ter pelo menos um valor <code>True</code> como parâmetro. É por isso que
o resultado final é <code>False</code>, o que faz sentido porque nenhum
valor em nossa árvore é maior que <code>15</code>.</p>
<p>Também podemos transformar facilmente nossa árvore em uma lista
fazendo um <code>foldMap</code> com a função <code>\x -&gt; [x]</code>.
Ao primeiro projetar essa função em nossa árvore, cada elemento se torna
uma lista singleton. A ação <code>mappend</code> que ocorre entre todos
esses resultados de lista singleton resulta em uma única lista que
contém todos os elementos que estão em nossa árvore:</p>
<pre class="haskell:hs"><code>ghci&gt; F.foldMap (\x -&gt; [x]) testTree
[1,3,6,5,8,9,10]</code></pre>
<p>O que é legal é que todos esses truques não se limitam a árvores,
eles funcionam em qualquer instância de <code>Foldable</code>.</p>
            </article>
<div class="footdiv">
    <ul>
        <li style="text-align:left">
<a href="functionally-solving-problems.html">Anterior (Resolvendo Problemas Funcionalmente)</a>
        </li>
        <li style="text-align:center">
            <a href="chapters.html">Índice de capítulos</a>
        </li>
        <li style="text-align:right">
<a href="a-fistful-of-monads.html" class="nxtlink">Próximo (Por um Punhado de Monads)</a>
        </li>
    </ul>
</div>

        </div>
    </div>
    <script type="text/javascript" src="sh/Scripts/shCore.js"></script>
    <script type="text/javascript" src="sh/Scripts/shBrushHaskell.js"></script>
    <script type="text/javascript" src="sh/Scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="assets/js/toggleShow.js"></script>
    <script type="text/javascript">
        dp.SyntaxHighlighter.HighlightAll('code');
    </script>
</body>
</html>
